msgid ""
msgstr "Project-Id-Version: 0\nPOT-Creation-Date: 2022-07-30 18:23+0200\nPO-Revision-Date: 2022-09-25 17:30+0000\nLast-Translator: Allan Nordhøy <epost@anotheragency.no>\nLanguage-Team: Norwegian Bokmål <https://hosted.weblate.org/projects/debian-handbook/09_unix-services/nb_NO/>\nLanguage: nb-NO\nMIME-Version: 1.0\nContent-Type: application/x-publican; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nPlural-Forms: nplurals=2; plural=n != 1;\nX-Generator: Weblate 4.14.1\n"

msgid "System boot"
msgstr "Systemoppstart"

msgid "Initscripts"
msgstr "Initskript"

msgid "SSH"
msgstr "SSH"

msgid "Telnet"
msgstr "Telnet"

msgid "Rights"
msgstr "Rettigheter"

msgid "Permissions"
msgstr "Tillatelser"

msgid "Supervision"
msgstr "Tilsyn"

msgid "Inetd"
msgstr "Inetd"

msgid "Cron"
msgstr "Cron"

msgid "Backup"
msgstr "Sikkerhetskopiering"

msgid "Hotplug"
msgstr "Driftskobling"

msgid "PCMCIA"
msgstr "PCMCIA"

msgid "APM"
msgstr "APM"

msgid "ACPI"
msgstr "ACPI"

msgid "Unix Services"
msgstr "Unix-tjenester"

msgid "This chapter covers a number of basic services that are common to many Unix systems. All administrators should be familiar with them."
msgstr "Dette kapitlet dekker en rekke grunnleggende tjenester felles for mange Unix-systemer. Alle administratorer bør være kjent med dem."

msgid "System Boot"
msgstr "Systemoppstart"

msgid "<primary>booting</primary><secondary>the system</secondary>"
msgstr "<primary>oppstart</primary><secondary>systemet</secondary>"

msgid "<primary>BIOS</primary>"
msgstr "<primary>BIOS</primary>"

msgid "<primary>MBR</primary>"
msgstr "<primary>MBR</primary>"

msgid "<primary>ESP</primary>"
msgstr "<primary>ESP</primary>"

msgid "<primary>Compatibility Support Mode</primary><see>CSM</see>"
msgstr "<primary>Compatibility Support Mode</primary><see>CSM</see>"

msgid "<primary>CSM</primary>"
msgstr "<primary>CSM</primary>"

msgid "When you boot the computer, the many messages scrolling by on the console display many automatic initializations and configurations that are being executed. Sometimes you may wish to slightly alter how this stage works, which means that you need to understand it well. That is the purpose of this section."
msgstr "Når du starter datamaskinen, vises de mange meldinger på konsollskjermen mange automatiske oppsett og igangsettinger. Noen ganger kan du ønske å endre litt på hvordan dette stadiet fungerer, noe som betyr at du må forstå det godt. Det er hensikten med dette avsnittet."

msgid "On systems with a BIOS, first, the BIOS takes control of the computer, initializes the controllers and hardware, detects the disks, and bridges everything together. Then it looks up the <emphasis>Master Boot Record</emphasis> (MBR) of the first disk in the boot order and loads the code stored there (first stage). This code then launches the second stage and finally executes the bootloader."
msgstr "På systemer med BIOS, må BIOS først ta kontroll over datamaskinen, igangsette kontrollere og maskinvare, oppdage diskene, og knytte det hele sammen. Deretter sjekker den <emphasis>hovedoppstartssporet</emphasis> (MBR) for første disk i oppstartsrekkefølgen og laster inn koden som er lagret der (første trinn). Denne koden starter så andre trinn og kjører til slutt oppstartslasteren."

msgid "In contrast to the BIOS, UEFI is more sophisticated, it knows filesystems and can read the partition tables. The interface searches the system storage for a partition labeled with a specific globally unique identifier (<acronym>GUID</acronym>) that marks it as the <acronym>EFI System Partition</acronym> (<acronym>ESP</acronym>), where the bootloaders, boot managers, UEFI shell, etc., are located, and launches the desired bootloader. If Secure Boot is enabled, the boot process will verify authenticity of the EFI binaries there by signature (thus <emphasis role=\"pkg\">grub-efi-<replaceable>arch</replaceable>-signed</emphasis> is required in this case). The UEFI specification also defines support for booting in legacy BIOS mode. This is called the <emphasis>Compatibility Support Module</emphasis> (<acronym>CSM</acronym>). If CSM is enabled, it will attempt to boot from a drive's MBR. However, many new systems do no longer support the CSM mode."
msgstr "Til forskjell fra BIOS er UEFI mer sofistikert mtp. at det vet om filsystemer og kan lese partisjonstabeller. Grensesnittet søker i systemlagringen etter en partisjon merket med en globalt unik identifikator (<acronym>GUID</acronym>) som markerer den som <acronym>EFI-systemoartisjonen</acronym> (<acronym>ESP</acronym>), der oppstartslasteren, oppstartshåndterere, UEFI-skall, osv., er å finne, og starter ønsket oppstartsletter. Hvis Secure Boot er påskrudd vil prosessen bekrefte at EFI-binærfilene er sannferdige og samsvarer med sin signatur, altså er <emphasis role=\"pkg\">grub-efi-<replaceable>arch</replaceable>-signed</emphasis> påkrevd for dette). UEFI-spesifikasjonen definerer også støtte for start i gammeldags BIOS-modus. Dette heter <emphasis>kompabilitetsstøttemodul</emphasis> (<acronym>CSM</acronym>). Hvis CSM er påskrudd vil den prøve å starte opp fra en enhets MBR. Dog er det mange nye systemer som ikke støtter CSM-modus."

msgid "In both cases then the actual bootloader takes over, finds either a chained bootloader or the kernel on the disk, loads, and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <command>init</command>. Frequently, this “root partition” and this <command>init</command> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process."
msgstr "I begge fall tar den egentlige oppstartslasteren over, finner enten den stafettbaserte oppstartslasteren eller kjernen på disken, laster og kjører den. Kjernen blir så initialisert, og begynner å søke etter, og montere partisjonen som inneholder rotfilsystemet, og kjører slutt det første programmet — <command>init</command>. Ofte er, faktisk, denne «rotpartisjonen» og denne <command>init</command> plassert i et virtuelt filsystem som bare finnes i RAM (derav navnet, «initramfs», tidligere kalt «initrd» for «initialisering RAM disk»). Dette filsystemet er lastet inn i minnet av oppstartslasteren, ofte fra en fil på en harddisk, eller fra nettverket. Den inneholder bare et minimum av det som kreves av kjernen for å laste det «sanne» rotfilsystemet: Dette kan være drivermoduler for harddisken, eller andre enheter uten noe systemet ikke kan starte opp, eller oftere, initialiseringsskript og moduler for montering av RAID-matriser, åpne krypterte partisjoner, for å aktivering av LVM, osv. Når rotpartisjonen er montert, overlater initramfs kontrollen til den virkelige init-en, og maskinen går tilbake til forvalgt oppstartsprosess."

msgid "The systemd init system"
msgstr "Systemd init system"

msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">systemd</emphasis></secondary>"
msgstr "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">systemd</emphasis></secondary>"

msgid "The “real init” is currently provided by <emphasis role=\"pkg\">systemd</emphasis> and this section documents this init system."
msgstr "Den «ekte init-en» blir nå levert av <emphasis role=\"pkg\">systemd</emphasis>, og dette avsnitter dokumenterer dette init-systemet."

msgid "<emphasis>CULTURE</emphasis> Before <command>systemd</command>"
msgstr "<emphasis>KULTUR</emphasis> før <command>systemd</command>"

msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">sysv-rc</emphasis></secondary><seealso>System V init</seealso>"
msgstr "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">sysv-rc</emphasis></secondary><seealso>System V init</seealso>"

msgid "<primary>System V init</primary>"
msgstr "<primary>System V init</primary>"

msgid "<command>systemd</command> is a relatively recent “init system”, and although it was already available, to a certain extent, in <emphasis role=\"distribution\">Wheezy</emphasis>, it has only become the default in Debian <emphasis role=\"distribution\">Jessie</emphasis>. Previous releases relied, by default, on the “System V init” (in the <emphasis role=\"pkg\">sysv-rc</emphasis> package), a much more traditional system. We describe the System V init later on."
msgstr "<command>systemd</command> er et relativt nytt «init-system», og selv om det allerede er tilgjengelig, til en viss grad, i <emphasis role=\"distribution\">Wheezy</emphasis>, er det bare først blitt forvalg i Debian <emphasis role=\"distribution\">Jessie</emphasis>. Tidligere versjoner bygger, som forvalg, på «System V-init» (i <emphasis role=\"pkg\">sysv-rc</emphasis>-pakken), et mye mer tradisjonelt system. Vi beskriver System V-init senere."

msgid "<emphasis>ALTERNATIVE</emphasis> Other boot systems"
msgstr "<emphasis>ALTERNATIV</emphasis> Andre systemer for oppstart"

msgid "<primary>boot systems</primary><seealso><command>init</command></seealso>"
msgstr "<primary>oppstartsystemer</primary><seealso><command>init</command></seealso>"

msgid "This book describes the boot system used by default in Debian since <emphasis role=\"distribution\">Buster</emphasis> (as implemented by the <emphasis role=\"pkg\">systemd</emphasis> package), as well as the previous default, <emphasis role=\"pkg\">sysvinit</emphasis>, which is derived and inherited from <emphasis>System V</emphasis> Unix systems; there are others."
msgstr "Denne boken beskriver oppstartssystemet brukt som forvalg i Debian siden <emphasis role=\"distribution\">Buster</emphasis> (som implementert av <emphasis role=\"pkg\">systemd</emphasis>-pakken), så vel som det tidligere forvalget, <emphasis role=\"pkg\">sysvinit</emphasis>, som er avledet og nedarvet fra <emphasis>System V</emphasis> Unix-systemer; det finnes også andre."

msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">upstart</emphasis></secondary>"
msgstr "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">upstart</emphasis></secondary>"

msgid "The <command>upstart</command> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, was present in Debian <emphasis role=\"distribution\">Jessie</emphasis>, but was not the default; it came, in fact, as a replacement for <emphasis role=\"pkg\">sysvinit</emphasis>, and one of the tasks launched by <command>upstart</command> was to launch the scripts written for traditional systems, especially those from the <emphasis role=\"pkg\">sysv-rc</emphasis> package."
msgstr "<command>upstart</command>-systemet er fortsatt ikke testet helt ut på Debian. Det er hendelsesbasert: init-skript utføres ikke lenger i sekvensiell rekkefølge, men som respons til hendelser som for eksempel fullføring av et annet skript de er avhengige av. Dette systemet, startet av Ubuntu, var med i Debian <emphasis role=\"distribution\">Jessie</emphasis>, men ikke forvalget. Det kom faktisk som en erstatning for <emphasis role=\"pkg\">sysvinit</emphasis>, og en av oppgavene til <command>upstart</command> var å kjøre de prosedyrene som er skrevet for tradisjonelle systemer, spesielt de fra <emphasis role=\"pkg\">sysv-rc</emphasis>-pakken."

msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">openrc</emphasis></secondary>"
msgstr "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">openrc</emphasis></secondary>"

#, fuzzy
msgid "<command>openrc</command> is a dependency based service manager. It was originally written for the Gentoo project, but it aims at being platform agnostic. It maintains compatibility with the System V init system and provides support for booting, changing runlevels, starting and stopping services (in parallel), and shutting down."
msgstr "<command>openrc</command> er en avhengighetsbasert tjenestehåndterer. Den ble opprinnelig skrevet for Gentoo-prosjektet, men den tar sikte på å ikke være spesifikk for noen systemer. Den beholder kompabiliteten med System V-initsystemet, og har støtte for oppstart, endring av kjøringsnivåer, starting og stopping av tjenester (i parallell), og å slå av maskinen."

msgid "There are also other systems and other operating modes, such as <command>file-rc</command>, <command>runit</command>, or <command>minit</command>, but some of them are relatively specialized and not widespread."
msgstr "Det er også andre systemer og andre driftsmodi, f.eks. <command>runit</command>, <command>file-rc</command>, eller <command>minit</command>, men noen av dem er relativt spesialiserte, foreldet, og ikke utbredt."

msgid "Boot sequence of a computer running Linux with systemd"
msgstr "Oppstartssekvens med en datamaskin som kjører Linux med systemd"

msgid "<emphasis>SPECIFIC CASE</emphasis> Booting from the network"
msgstr "<emphasis>KONKRET SAK</emphasis> Oppstart fra nettverket"

msgid "In some configurations, the system may be configured not to execute code from the physical hardware, but to seek its equivalent on the network, making it possible to build computers without a hard drive, or which are completely reinstalled on each boot. This option is not available on all hardware and it generally requires an appropriate combination of firmware and network card."
msgstr "I noen oppsett kan systemet settes opp til ikke å kjøre kode fra den fysiske maskinvaren men isteden hente tilsvarende blokk fra nettverket, noe som gjør det mulig å lage datamaskiner uten en harddisk, eller som blir installert helt på nytt ved hver oppstart. Dette alternativet er ikke tilgjengelig for alle maskintyper, og det krever vanligvis en egnet kombinasjon av fastvare og nettverkskort."

msgid "Booting from the network can be used to launch the <command>debian-installer</command> or FAI (see <xref linkend=\"sect.installation-methods\" />)."
msgstr "Oppstart fra nettverket kan bli brukt til å kjøre <command>debian-installer</command> eller FAI (se <xref linkend=\"sect.installation-methods\" />)."

msgid "<emphasis>BACK TO BASICS</emphasis> The process, a program instance"
msgstr "<emphasis>DET GRUNNLEGGENDE</emphasis> Prosessen, et programeksempel"

msgid "<primary>process</primary>"
msgstr "<primary>prosess</primary>"

msgid "A process is the representation of a running program in memory. It includes all of the information necessary for the proper execution of the software (the code itself, but also the data that it has in memory, the list of files that it has opened, the network connections it has established, etc.). A single program may be instantiated into several processes, not necessarily running under different user IDs."
msgstr "En prosess er representasjonen av et kjørende program innlastet i minnet. Det inkluderer all informasjon nødvendig for forsvarlig kjøring av programvaren (selve koden, men også dataene den har i minnet, en liste over filer den har åpnet, nettverksforbindelsene den har etablert, osv.). Et enkelt program kan startes opp i flere prosesser, som ikke nødvendigvis kjører under forskjellige bruker-ID-er."

msgid "<emphasis>SECURITY</emphasis> Using a shell as <command>init</command> to gain root rights"
msgstr "<emphasis>SIKKERHET</emphasis> Bruk av skall som <command>init</command> for å få root-rettigheter"

msgid "By convention, the first process that is booted is the <command>init</command> program (which is a symbolic link to <filename>/lib/systemd/systemd</filename> by default). However, it is possible to pass an <literal>init</literal> option to the kernel indicating a different program."
msgstr "Tradisjonelt er den første prosessen som starter <command>init</command>-programmet (som normalt er en symbolsk lenke til <filename>/lib/systemd/systemd</filename>). Imidlertid er det mulig å sende et <literal>init</literal>-valg til kjernen for å indikere et annet program."

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "Any person who is able to access the computer can press the <keycap>Reset</keycap> button, and thus reboot it. Then, at the bootloader's prompt, it is possible to pass the <literal>init=/bin/sh</literal> option to the kernel to gain root access without knowing the administrator's password."
msgstr "Alle som er i stand til å få tilgang til datamaskinen kan trykke på <keycap>Reset</keycap>-knappen og starte den på nytt. Så, på oppstartslasterens ledetekst, er det mulig å sende <literal>init=/bin/sh</literal>-valget til kjernen for å få rottilgang uten å kjenne administratorens passord."

msgid "To prevent this, you can protect the bootloader itself with a password. You might also think about protecting access to the BIOS (a password protection mechanism is almost always available), without which a malicious intruder could still boot the machine on a removable media containing its own Linux system, which they could then use to access data on the computer's hard drives."
msgstr "For å unngå dette kan du beskytte oppstartslasteren med et passord. Du kan også tenke på å beskytte tilgang til BIOS (en mekanisme for passordbeskyttelse er nesten alltid tilgjengelig). Uten den kan en ondsinnet inntrenger fortsatt starte maskinen med et flyttbart medium som har sitt eget Linux-system, som de deretter kan bruke til å få tilgang til data på datamaskinens harddisker."

msgid "Finally, be aware that most BIOS/EFI implementations have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…"
msgstr "Til slutt, være klar over at de fleste BIOS/EFI-implementasjon -er har et generisk passord tilgjengelig. I utgangspunktet er de tenkt for feilsøking for dem som har glemt passordet sitt. Disse passordene er nå offentlige og tilgjengelig på Internett (se selv ved å søke etter «generiske BIOS-passord» i en søkemotor). Alle disse beskyttelsene vil dermed hindre uautorisert tilgang til maskinen, men uten å være i stand til å fullstendig hindre det. Det er ingen pålitelig måte å beskytte en datamaskin på hvis angriperen kan få fysisk tilgang til den; de kan uansett demontere harddisker for å koble dem til en datamaskin under egen kontroll, eller stjele hele maskinen, eller slette BIOS-minnet for å tilbakestille passordet …"

msgid "Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> pairs grouped between <literal>[<replaceable>section</replaceable>]</literal> headers. Unit files are stored under <filename>/lib/systemd/system/</filename> and <filename>/etc/systemd/system/</filename>; they come in several flavors, but we will focus on “services” and “targets” here."
msgstr "Systemd utfører flere prosesser, som har ansvaret for å sette opp systemet: tastatur, drivere, filsystemer, nettverk, tjenester. Den gjør dette mens du holder et overordnet oppsyn på systemet som helhet, og kravene til komponentene. Hver komponent er beskrevet av en «enhetsfil» («unit file») (noen ganger mer); den generelle syntaksen er avledet fra den ofte brukte «* INI-filer» syntaksen, med <literal><replaceable>nøkkel</replaceable> = <replaceable>verdi</replaceable></literal>-par gruppert mellom <literal>[<replaceable>seksjon</replaceable>]</literal>-topptekster. «Unit filer» er lagret i <filename>/lib/systemd/system/</filename>, og <filename>/etc/systemd/system/</filename>. De kommer i flere varianter, men her vil vi fokusere på «tjenester» og «mål»."

msgid "<primary><command>systemd</command></primary><secondary><filename>.service</filename> file</secondary>"
msgstr "<primary><command>systemd</command></primary><secondary><filename>.service</filename>-fil</secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/systemd/system/</filename></secondary><see><command>systemd</command></see>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/systemd/system/</filename></secondary><see><command>systemd</command></see>"

msgid "<primary>service</primary><secondary><filename>ssh.service</filename></secondary>"
msgstr "<primary>tjeneste</primary><secondary><filename>ssh.service</filename></secondary>"

msgid "A systemd “<filename>.service</filename> file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:"
msgstr "En systemd «<filename>.service</filename>-fil» beskriver en prosess styrt av systemd. Den inneholder omtrent den samme informasjonen som i et gammelt stil init-skript, men uttrykt på en deklaratorisk (og mye mer konsis) måte. Systemd håndterer mesteparten av de repeterende oppgavene (som starter og stopper prosessen, sjekker statusen, loggingen, dropper privilegier, og så videre), og tjenestefilen trenger bare å fylle ut detaljene i prosessen. For eksempel, her er tjenestefilen for SSH:"

msgid ""
"[Unit]\n"
"Description=OpenBSD Secure Shell server\n"
"Documentation=man:sshd(8) man:sshd_config(5)\n"
"After=network.target auditd.service\n"
"ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
"\n"
"[Service]\n"
"EnvironmentFile=-/etc/default/ssh\n"
"ExecStartPre=/usr/sbin/sshd -t\n"
"ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
"ExecReload=/usr/sbin/sshd -t\n"
"ExecReload=/bin/kill -HUP $MAINPID\n"
"KillMode=process\n"
"Restart=on-failure\n"
"RestartPreventExitStatus=255\n"
"Type=notify\n"
"RuntimeDirectory=sshd\n"
"RuntimeDirectoryMode=0755\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target\n"
"Alias=sshd.service"
msgstr "[Unit]\nDescription=OpenBSD Secure Shell server\nDocumentation=man:sshd(8) man:sshd_config(5)\nAfter=network.target auditd.service\nConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n\n[Service]\nEnvironmentFile=-/etc/default/ssh\nExecStartPre=/usr/sbin/sshd -t\nExecStart=/usr/sbin/sshd -D $SSHD_OPTS\nExecReload=/usr/sbin/sshd -t\nExecReload=/bin/kill -HUP $MAINPID\nKillMode=process\nRestart=on-failure\nRestartPreventExitStatus=255\nType=notify\nRuntimeDirectory=sshd\nRuntimeDirectoryMode=0755\n\n[Install]\nWantedBy=multi-user.target\nAlias=sshd.service"

msgid "The <literal>[Unit]</literal> section contains generic information about the service, like its description and manual page resources, as well as relations (dependency and order) to other services. The <literal>[Service]</literal> part contains the declarations related to the service execution (starting, stopping, killing, restarting), directories and configuration file(s) used. The last section, <literal>[Install]</literal>, again carries generic information into which targets to install the service and, in this case, the alias that can be used instead of the service name. As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed. The syntax of these files is fully described in several manual pages (e.g. <citerefentry><refentrytitle>systemd.service</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>systemd.unit</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>systemd.exec</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, etc.)."
msgstr "<literal>[Unit]</literal>-delen inneholder generisk info om tjenesten, som f.eks. dens beskrivelse og manualsideressurser, og dens relasjoner (avhengigheter og rekkefølge) til andre tjenester. <literal>[Service]</literal>-delen inneholder deklarasjoner som har med tjenestekjøring å gjøre (starting, stopping, dreping, omstart), mapper og oppsettsfil(er) brukt. Siste del <literal>[Install]</literal>, har også generisk info om hvilke mål som skal installere tjenesten og i dette tilfellet alias som kan brukes istedenfor tjenestenavnet. Demonstrativt er det veldig lite kode der, kun deklarasjoner. Systemd tar hånd om visning av framdriftsrapporter, visning av prosesser, og faktisk også omstart av dem når det trengs. Syntaksen for disse filene er beskrevet i sin helhet fordelt på flere manualsider <citerefentry><refentrytitle>systemd.service</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>systemd.unit</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>systemd.exec</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, osv.)."

msgid "<primary><command>systemd</command></primary><secondary><filename>.target</filename> file</secondary>"
msgstr "<primary><command>systemd</command></primary><secondary><filename>.target</filename>-fil</secondary>"

msgid "A systemd “<filename>.target</filename> file” describes a state of the system where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the pre-defined targets is <literal>local-fs.target</literal>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <literal>network-online.target</literal> and <literal>sound.target</literal> (for a full list of special targets see <citerefentry><refentrytitle>systemd.special</refentrytitle> <manvolnum>7</manvolnum></citerefentry>). The dependencies of a target can be listed either within the target file (in the <literal>Requires=</literal> line), or using a symbolic link to a service file in the <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> directory. For instance, <filename>/etc/systemd/system/printer.target.wants/</filename> contains a link to <filename>/lib/systemd/system/cups.service</filename>; systemd will therefore ensure CUPS is running in order to reach <literal>printer.target</literal>."
msgstr "En systemd «<filename>.taget</filename>-fil» beskriver et systems tilstand, hvor et sett av tjenester som kjører. Det kan sees på som å tilsvare det gammeldagse kjørenivået. Ett av målene er <literal>local-fs.target</literal>; Når det er nådd, kan resten av systemet gå ut fra at alle de lokale filsystemer er montert og tilgjengelige. Andre mål inkluderer <literal>network-online.target</literal> og <literal>sound.target</literal> (en full liste over mål er å finne i <citerefentry><refentrytitle>systemd.special</refentrytitle> <manvolnum>7</manvolnum></citerefentry>. Avhengigheter for et mål kan enten være oppført i målfilen (i <literal>Requires=</literal>-linjen), eller man kan bruke en symbolsk fil i <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal>-mappen. For eksempel inneholder <filename>/etc/systemd/system/printer.target.wants/</filename> en link til <filename>/lib/systemd/system/cups.service</filename>; systemd vil derfor sikre at CUPS kjører, for å nå <literal>printer.target</literal>."

msgid "Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component."
msgstr "Siden enhetsfiler er deklarative heller enn skripter eller programmer, kan de ikke kjøres direkte, og de blir bare tolket av systemd. Flere verktøy tillater derfor administratoren å samhandle med systemd for å kontrollere tilstanden til systemet, og for hver komponent."

msgid "<primary><command>systemd</command></primary><secondary><command>systemctl</command></secondary><see><command>systemctl</command></see>"
msgstr "<primary><command>systemd</command></primary><secondary><command>systemctl</command></secondary><see><command>systemctl</command></see>"

msgid "<primary><command>systemctl</command></primary><secondary><literal>status</literal></secondary>"
msgstr "<primary><command>systemctl</command></primary><secondary><literal>status</literal></secondary>"

msgid "The first such utility is <command>systemctl</command>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <command>systemctl status</command> gives a better view of the services, as well as the related processes. If given the name of a service (as in <command>systemctl status ntp.service</command>), it returns even more details, as well as the last few log lines related to the service (more on that later)."
msgstr "Det første slikt verktøy er <command>systemctl</command>. Kjørt uten argumenter, viser den alle enhetsfiler som er kjent for systemd (bortsett fra de som er blitt deaktivert), samt deres status. <command>systemctl status</command> gir en bedre oversikt over tjenestene, samt relaterte prosesser. Hvis navnet på en tjeneste er gitt (som i <command>systemctl status ntp.service</command>), returnerer den enda flere detaljer, så vel som de få siste logglinjer knyttet til denne tjenesten (mer om det senere)."

msgid "<primary><command>systemctl</command></primary><secondary><literal>start</literal></secondary>"
msgstr "<primary><command>systemctl</command></primary><secondary><literal>start</literal></secondary>"

msgid "<primary><command>systemctl</command></primary><secondary><literal>stop</literal></secondary>"
msgstr "<primary><command>systemctl</command></primary><secondary><literal>stop</literal></secondary>"

msgid "<primary><command>systemctl</command></primary><secondary><literal>reload</literal></secondary>"
msgstr "<primary><command>systemctl</command></primary><secondary><literal>reload</literal></secondary>"

msgid "<primary><command>systemctl</command></primary><secondary><literal>restart</literal></secondary>"
msgstr "<primary><command>systemctl</command></primary><secondary><literal>restart</literal></secondary>"

msgid "Starting a service by hand is a simple matter of running <command>systemctl start <replaceable>servicename</replaceable>.service</command>. As one can guess, stopping the service is done with <command>systemctl stop <replaceable>servicename</replaceable>.service</command>; other subcommands include <command>reload</command> and <command>restart</command>."
msgstr "Å starte en tjeneste for hånd er en enkel sak, kjør <command>systemctl start <replaceable>tjenestenavn</replaceable>.service</command>. Som man kan gjette seg til, å stoppe tjenesten gjøres med <command>systemctl stop <replaceable>tjenestenavn</replaceable>.service</command>. Andre underkommandoer inkluderer <command>reload</command> og <command>restart</command>."

msgid "<primary><command>systemctl</command></primary><secondary><literal>enable</literal></secondary>"
msgstr "<primary><command>systemctl</command></primary><secondary><literal>enable</literal></secondary>"

msgid "<primary><command>systemctl</command></primary><secondary><literal>disable</literal></secondary>"
msgstr "<primary><command>systemctl</command></primary><secondary><literal>disable</literal></secondary>"

msgid "<primary><command>systemctl</command></primary><secondary><literal>is-enabled</literal></secondary>"
msgstr "<primary><command>systemctl</command></primary><secondary><literal>is-enabled</literal></secondary>"

msgid "To control whether a service is active (i.e. whether it will get started automatically on boot), use <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (or <command>disable</command>). <command>is-enabled</command> allows checking the status of the service."
msgstr "For å kontrollere om en tjeneste er aktiv (dvs. om den vil komme i gang automatisk ved oppstart), bruk <command>systemctl enable <replaceable>tjenestnavn</replaceable>.service</command> (eller <command>disable</command>). <command>is-enabled</command> åpner for å sjekke tjenestens status."

msgid "<primary><command>systemd</command></primary><secondary><command>journald</command></secondary><see><command>journald</command></see>"
msgstr "<primary><command>systemd</command></primary><secondary><command>journald</command></secondary><see><command>journald</command></see>"

msgid "<primary><command>systemd</command></primary><secondary><command>journalctl</command></secondary><see><command>journalctl</command></see>"
msgstr "<primary><command>systemd</command></primary><secondary><command>journalctl</command></secondary><see><command>journalctl</command></see>"

msgid "<primary><command>journald</command></primary>"
msgstr "<primary><command>journald</command></primary>"

msgid "<primary><command>syslogd</command></primary>"
msgstr "<primary><command>syslogd</command></primary>"

msgid "<primary><command>journalctl</command></primary>"
msgstr "<primary><command>journalctl</command></primary>"

msgid "An interesting feature of systemd is that it includes a logging component named <command>journald</command>. It comes as a complement to more traditional logging systems such as <command>syslogd</command>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialization sequence. The messages can be displayed later on, with a little help from the <command>journalctl</command> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:"
msgstr "Et interessant trekk ved systemd er at den inneholder en loggingskomponent som heter <command>journald</command>. Den kommer som et supplement til mer tradisjonelle loggingssystemer, for eksempel <command>syslogd</command>, men den legger til interessante funksjoner som en formell kobling mellom en tjeneste og meldingene den genererer, og evnen til å fange opp feilmeldinger generert fra sin initialiseringssekvens. Meldingene kan vises senere, med litt hjelp fra <command>journalctl</command>-kommandoen. Uten noen argumenter, avgir den bare alle loggmeldinger som har oppstått etter oppstart av systemet. Det vil sjelden bli brukt på den måten. Mesteparten av tiden vil den bli brukt med en tjenesteidentifikator:"

msgid ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"

msgid "Another useful command-line flag is <command>-f</command>, which instructs <command>journalctl</command> to keep displaying new messages as they are emitted (much in the manner of <command>tail -f <replaceable>file</replaceable></command>)."
msgstr "En annen nyttig kommandolinjemarkør er <command>-f</command>, som instruerer <command>journalctl</command> til å fortsette å vise nye meldinger etter hvert som de er sendt ut (mye på samme måte som <command>tail -f <replaceable>file</replaceable></command>)."

msgid "If a service doesn't seem to be working as expected, the first step to solve the problem is to check that the service is actually running with <command>systemctl status</command>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:"
msgstr "Hvis en tjeneste ikke ser ut til å virke som forventet, er første skritt for å løse problemet å kontrollere at tjenesten faktisk kjører, med <command>systemctl status</command>. Hvis den ikke kjører, og meldingene er gitt av den første kommandoen ikke er nok til å diagnostisere problemet, sjekk loggene samlet av journald om denne tjenesten. For eksempel, anta at SSH-tjeneren ikke virker:"

msgid ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"

msgid "After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running."
msgstr "Etter å ha sjekket status på tjenesten (feilet), gikk vi videre til å sjekke loggene. De indikerer en feil i oppsettsfilen. Etter å ha endret på oppsettsfilen og fikset feilen, starter vi tjenesten, og kontroller så at den faktisk kjører."

msgid "<emphasis>GOING FURTHER</emphasis> Other types of unit files"
msgstr "<emphasis>FOR VIDEREKOMMENDE</emphasis> Andre typer enhetsfiler"

msgid "We have only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we will only list a few here:"
msgstr "Vi har bare beskrevet det mest grunnleggende av systemd sine muligheter i denne seksjonen. Den tilbyr mange andre interessante funksjoner, og vi vil bare liste noen her:"

msgid "<primary><command>systemd</command></primary><secondary><filename>.socket</filename> file</secondary>"
msgstr "<primary><command>systemd</command></primary><secondary><filename>.socket</filename>-fil</secondary>"

msgid "socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <command>inetd</command>. See <citerefentry><refentrytitle>systemd.socket</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."
msgstr "socket aktivering: en «socket» enhetsfil kan brukes til å beskrive et nettverk eller en Unix socket administrert av systemd. Dette betyr at socket-en vil bli opprettet av systemd, og selve tjenesten kan startes etter behov ved et faktisk tilkoblingsforsøk. Dette replikerer omtrent funksjonssettet til <command>inetd</command>. Se <citerefentry><refentrytitle>systemd.socket</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."

msgid "<primary><command>systemd</command></primary><secondary><filename>.timer</filename> file</secondary>"
msgstr "<primary><command>systemd</command></primary><secondary><filename>.timer</filename>-fil</secondary>"

#, fuzzy
#| msgid "timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <command>cron</command> features. See <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgid "timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <command>cron</command> features. See <citerefentry><refentrytitle>systemd.timer</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."
msgstr "timere: en «timer»-enhetsfil beskriver hendelser som inntreffer med en fast frekvens eller på bestemte tider. Når en tjeneste er knyttet til en slik timer, vil den tilsvarende oppgaven bli utført når tiden er inne. Dette gjør det mulig å kopiere en del av <command>cron</command>s egenskaper. Se <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>."

msgid "<primary><command>systemd</command></primary><secondary><filename>.network</filename> file</secondary>"
msgstr "<primary><command>systemd</command></primary><secondary><filename>.network</filename>-fil</secondary>"

msgid "network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up. See <citerefentry><refentrytitle>systemd.network</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."
msgstr "nettverk: enhetsfil av type «network» beskriver et nettverksgrensesnitt som gjør det mulig å sette opp slike grensesnitt, samt uttrykke at en tjeneste er avhengig av at et bestemt grensesnitt er oppe. Sjekk <citerefentry><refentrytitle>systemd.network</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."

msgid "The System V init system"
msgstr "System V init system"

msgid "The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <filename>/etc/inittab</filename> file. The first program that is executed (which corresponds to the <emphasis>sysinit</emphasis> step) is <command>/etc/init.d/rcS</command>, a script that executes all of the programs in the <filename>/etc/rcS.d/</filename> directory."
msgstr "System V init system (som vi kaller init for korthets skyld) utfører flere prosesser, etter anvisning fra <filename>/etc/inittab</filename>-filen. Det første program som kjøres (som tilsvarer <emphasis>sysinit</emphasis> trinnet) er <command>/etc/init.d/rcS</command>, et skript som kjører alle programene i <filename>/etc/rcS.d/</filename>-mappen."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/init.d/rcS</filename></secondary><seealso><emphasis role=\"pkg\">sysv-rc</emphasis></seealso>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/init.d/rcS</filename></secondary><seealso><emphasis role=\"pkg\">sysv-rc</emphasis></seealso>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rcS.d/</filename></secondary><seealso><emphasis role=\"pkg\">sysv-rc</emphasis></seealso>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rcS.d/</filename></secondary><seealso><emphasis role=\"pkg\">sysv-rc</emphasis></seealso>"

msgid "<primary><filename>rcS</filename></primary>"
msgstr "<primary><filename>rcS</filename></primary>"

msgid "<primary><filename>rcS.d</filename></primary>"
msgstr "<primary><filename>rcS.d</filename></primary>"

msgid "Among these, you will find successively programs in charge of:"
msgstr "Blant disse finner du suksessivt programmer med ansvar for:"

msgid "configuring the console's keyboard;"
msgstr "oppsettet av konsollets tastatur;"

msgid "loading drivers: most of the kernel modules are loaded by the kernel itself as the hardware is detected; extra drivers are then loaded automatically when the corresponding modules are listed in <filename>/etc/modules</filename>;"
msgstr "laste drivere: de fleste av kjernemodulene er lastet av kjernen selv i takt med at maskinvaren blir oppdaget; ekstra drivere blir deretter lastet inn automatisk når de korresponderende modulene er oppført i <filename>/etc/modules</filename>;"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modules</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modules</filename></secondary>"

msgid "checking the integrity of filesystems;"
msgstr "sjekke integriteten til filsystemene;"

msgid "mounting local partitions;"
msgstr "montere lokale partisjoner;"

msgid "configuring the network;"
msgstr "sette opp nettverket;"

msgid "mounting network filesystems (NFS)."
msgstr "montere nettverk filsystemer (NFS)."

msgid "<emphasis>BACK TO BASICS</emphasis> Kernel modules and options"
msgstr "<emphasis>DET GRUNNLEGGENDE</emphasis> Kildemoduler og valgmuligheter"

msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgstr "<primary>moduler</primary><secondary>kjernemoduler</secondary>"

msgid "<primary>kernel</primary><secondary>modules</secondary>"
msgstr "<primary>kjerne</primary><secondary>moduler</secondary>"

msgid "<primary>kernel</primary><secondary>modules</secondary><tertiary>load</tertiary><seealso><command>modprobe</command></seealso>"
msgstr "<primary>kjerne</primary><secondary>moduler</secondary><tertiary>innlasting</tertiary><seealso><command>modprobe</command></seealso>"

#, fuzzy
msgid "<primary>kernel</primary><secondary>modules</secondary><tertiary>options</tertiary><seealso><command>modinfo</command></seealso>"
msgstr "<primary>kjerne</primary><secondary>moduler</secondary><tertiary>alternativer</tertiary><seealso><command>modinfo</command></seealso>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modprobe.d</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modprobe.d</filename></secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modules-load.d/</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modules-load.d/</filename></secondary>"

msgid "You have already learned that kernel modules can be loaded during the start of the system by adding them to <filename>/etc/modules</filename> or a file below <filename>/etc/modules-load.d/</filename>. But modules can also have options that can be configured by putting some files in <filename>/etc/modprobe.d/</filename>. These options are defined with directives like this: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. Several options can be specified with a single directive if necessary."
msgstr "Du har allerede lært at kjernemoduler kan innlastes under oppstart av systemet ved å legge dem til i <filename>/etc/modules</filename> eller en fil i <filename>/etc/modules-load.d/</filename>. Modules kan dog også ha valgmuligheter som kan settes opp ved å sette noen filer i <filename>/etc/modprobe.d/</filename>. Disse alternativene er definert med direktiver som dette: <literal>options <replaceable>modulnavn</replaceable> <replaceable>opsjonsnavn</replaceable>=<replaceable>opsjonsverdi</replaceable></literal>. Flere alternativer kan spesifiseres med ett eneste direktiv om nødvendig."

#, fuzzy
#| msgid "These configuration files are intended for <command>modprobe</command> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). This program is provided by the <emphasis role=\"pkg\">kmod</emphasis> package."
msgid "These configuration files are intended for <command>modprobe</command> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). To list all options of a module use the <command>modinfo -p <replaceable>module</replaceable></command> command. Both programs are provided by the <emphasis role=\"pkg\">kmod</emphasis> package together with other tools to handle modules."
msgstr "Disse oppsettsfilene er beregnet for <command>modprobe</command> — programmet som laster en kjernemodul med dets avhengigheter (moduler kan faktisk påkalle andre moduler). Dette programmet blir levert av <emphasis role=\"pkg\">kmod</emphasis>-pakken."

msgid "<primary><command>modprobe</command></primary>"
msgstr "<primary><command>modprobe</command></primary>"

msgid "<primary><command>modinfo</command></primary>"
msgstr "<primary><command>modinfo</command></primary>"

msgid "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"

msgid "Having learned about systemd, services and targets can use the <filename>modprobe@<replaceable>module</replaceable>.service</filename> to load kernel modules they depend on."
msgstr "Når du har lært om systemd, tjenester og mål kan du bruke <filename>modprobe@<replaceable>modul</replaceable>.service</filename> for å laste inn kjernemodulene de avhenger av."

msgid "<primary>service</primary><secondary><filename>modprobe@<replaceable>module</replaceable>.service</filename></secondary>"
msgstr "<primary>tjeneste</primary><secondary><filename>modprobe@<replaceable>modul</replaceable>.service</filename></secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/init.d/rc</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/init.d/rc</filename></secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rcX.d/</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rcX.d/</filename></secondary>"

msgid "<primary><command>insserv</command></primary>"
msgstr "<primary><command>insserv</command></primary>"

msgid "After this stage, <command>init</command> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <command>/etc/init.d/rc 2</command>, a script that starts all services which are listed in <filename>/etc/rc2.d/</filename> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <command>insserv</command>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <command>init</command> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <command>rsyslog</command>, or port assignment with <command>portmap</command>) are started first, followed by standard services and the graphical interface (<command>gdm3</command>)."
msgstr "Etter dette trinnet tar <command>init</command> over, og starter programmene aktivert i standard kjørenivå (som vanligvis er driftsnivå 2). Den utfører <command>/etc/init.d/rc 2</command>, et skript som starter alle tjenestene som er oppført i <filename>/etc/rc2.d/</filename>, og der navnet begynner med bokstaven «S». Det tosifrede nummer som følger, har historisk blitt brukt til å definere i hvilken rekkefølge tjenestene måtte startes, men i dag brukes det standard oppstartssystemet <command>insserv</command>, som berammer alt automatisk basert på skriptenes avhengigheter. Hvert oppstartsskript melder om betingelsene som må være oppfylt for å starte eller stoppe tjenesten (for eksempel hvis det må starte før eller etter en annen tjeneste); så starter <command>init</command> dem i den rekkefølgen som oppfyller disse betingelsene. Skriptenes statiske nummerering tas derfor ikke lenger i betraktning (men de må alltid ha et navn som begynner med «S» etterfulgt av to sifre, og selve navnet på skriptet som brukes for avhengighetene. Vanligvis startes basistjenester (for eksempel logger med <command>rsyslog</command>, eller tildeling av port med <command>portmap</command>) først, fulgt av standardtjenestene og det grafiske brukergrensesnittet (<command>gdm3</command>)."

msgid "This dependency-based boot system makes it possible to automate re-numbering, which could be rather tedious if it had to be done manually, and it limits the risks of human error, since scheduling is conducted according to the parameters that are indicated. Another benefit is that services can be started in parallel when they are independent from one another, which can accelerate the boot process."
msgstr "Dette avhengighetsbaserte oppstartssystemet gjør det mulig å automatisere renummerering, som kan være ganske kjedelig hvis det må gjøres manuelt. Det begrenser risikoen for menneskelige feil, ettersom tidsrekkefølgen blir gjennomført i henhold til de parameterne som er angitt. En annen fordel er at tjenester kan startes parallelt når de er uavhengige av hverandre, noe som kan akselerere oppstartsprosessen."

msgid "<primary>runlevel</primary>"
msgstr "<primary>driftsnivå (runlevel)</primary>"

msgid "<primary>level, runlevel</primary>"
msgstr "<primary>nivå, driftsnivå (runlevel)</primary>"

msgid "<primary><command>telinit</command></primary>"
msgstr "<primary><command>telinit</command></primary>"

msgid "<command>init</command> distinguishes several runlevels, so it can switch from one to another with the <command>telinit <replaceable>new-level</replaceable></command> command. Immediately, <command>init</command> executes <command>/etc/init.d/rc</command> again with the new runlevel. This script will then start the missing services and stop those that are no longer desired. To do this, it refers to the content of the <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (where <replaceable>X</replaceable> represents the new runlevel). Scripts starting with “S” (as in “Start”) are services to be started; those starting with “K” (as in “Kill”) are the services to be stopped. The script does not start any service that was already active in the previous runlevel."
msgstr "<command>init</command> skiller mellom ulike kjørenivåer, så det kan bytte fra ett til et annet med <command>telinit <replaceable>new-level</replaceable></command>-kommandoen. Umiddelbart vil <command>init</command> kjøre <command>/etc/init.d/rc</command> igjen med det nye kjørenivået. Dette skriptet vil da starte de manglende tjenestene, og stoppe de som ikke lenger er ønsket. For å gjøre dette viser det til innholdet i <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (der <replaceable>X</replaceable> representerer det nye kjørenivået). Skript som begynner med «S» (som i «Start») er tjenester som skal i gang; de som starter med «K» (som i «Kill») er de tjenestene som skal stoppes. Skriptet starter ikke noen tjenester som allerede var aktive med det forrige driftsnivået."

msgid "<primary>System V init</primary><secondary>runlevels</secondary>"
msgstr "<primary>System V init</primary><secondary>kjørenivå</secondary>"

msgid "By default, System V init in Debian uses four different runlevels:"
msgstr "Som standard bruker System V init i Debian fire forskjellige driftsnivåer:"

msgid "Level 0 is only used temporarily, while the computer is powering down. As such, it only contains many “K” scripts."
msgstr "Nivå 0 brukes bare midlertidig, mens maskinen slår seg av. Dermed inneholder den bare mange «K»-skripter."

msgid "Level 1, also known as single-user mode, corresponds to the system in degraded mode; it includes only basic services, and is intended for maintenance operations where interactions with ordinary users are not desired."
msgstr "Nivå 1, også kjent som enkeltbrukermodus, tilsvarer systemet i nedgradert modus; det inneholder bare basistjenester, og er beregnet for vedlikeholdsoperasjoner hvor samhandling med vanlige brukere ikke er ønsket."

msgid "Level 2 is the level for normal operation, which includes networking services, a graphical interface, user logins, etc."
msgstr "Nivå 2 er nivået for normal drift, som omfatter nettverkstjenester, et grafisk grensesnitt, brukerpålogging, etc."

msgid "Level 6 is similar to level 0, except that it is used during the shutdown phase that precedes a reboot."
msgstr "Nivå 6 er lik nivå 0, bortsett fra at det brukes under nedkoblingsfasen før en omstart."

msgid "Other levels exist, especially 3 to 5. By default they are configured to operate the same way as level 2, but the administrator can modify them (by adding or deleting scripts in the corresponding <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories) to adapt them to particular needs."
msgstr "Andre nivåer finnes, spesielt 3 til 5. Som standard er de satt opp til å operere på samme måte som nivå 2, men administratoren kan endre dem (ved å legge til eller slette skript i de tilsvarende <filename>/etc/rc<replaceable>X</replaceable>.d</filename> kataloger) for å tilpasse dem til spesielle behov."

msgid "Boot sequence of a computer running Linux with System V init"
msgstr "Oppstartssekvens for en datamaskin som kjører Linux med System V init"

msgid "<primary>initialization script</primary>"
msgstr "<primary>initialiseringsskript</primary>"

msgid "<primary><command>update-rc.d</command></primary>"
msgstr "<primary><command>update-rc.d</command></primary>"

msgid "<primary><command>rcconf</command></primary>"
msgstr "<primary><command>rcconf</command></primary>"

#, fuzzy
#| msgid "All the scripts contained in the various <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories are really only symbolic links — created upon package installation by the <command>update-rc.d</command> program — pointing to the actual scripts which are stored in <filename>/etc/init.d/</filename>. The administrator can fine tune the services available in each runlevel by re-running <command>update-rc.d</command> with adjusted parameters. The <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <literal>remove</literal> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <command>update-rc.d</command> has a somewhat convoluted interface, you may prefer using <command>rcconf</command> (from the <emphasis role=\"pkg\">rcconf</emphasis> package) which provides a more user-friendly interface."
msgid "All the scripts contained in the various <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories are really only symbolic links — created upon package installation by the <command>update-rc.d</command> program — pointing to the actual scripts which are stored in <filename>/etc/init.d/</filename>. The administrator can fine tune the services available in each runlevel by re-running <command>update-rc.d</command> with adjusted parameters. The <citerefentry><refentrytitle>update-rc.d</refentrytitle> <manvolnum>1</manvolnum></citerefentry> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <literal>remove</literal> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <command>update-rc.d</command> has a somewhat convoluted interface, you may prefer using <command>rcconf</command> (from the <emphasis role=\"pkg\">rcconf</emphasis> package) which provides a more user-friendly interface."
msgstr "Alle skriptene som inngår i de ulike <filename>/etc/rc<replaceable>X</replaceable>.d</filename>-kataloger er egentlig bare symbolske lenker - opprettet ved pakkeinstallasjon av <command>update-rc.d</command>-programmet - som peker til selve skriptet som er lagret i<filename>/etc/init.d/</filename>. Administratoren kan finjustere tjenestene som er tilgjengelige i hvert kjørenivå ved å kjøre <command>update-rc.d</command> igjen med justerte parametre. Manualsiden <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> beskriver syntaksen i detalj. Vær oppmerksom på at å fjerne alle symbolske lenker (med <literal>remove</literal>-parameteret) ikke er noen god metode for å deaktivere en tjeneste. I stedet bør du bare sette den opp til ikke å starte i det ønskede kjørenivået (mens man skjermer de samsvarende påkallinger for å stoppe den i det tilfelle tjenesten bruker det forrige kjørenivået. Siden <command>update-rc.d</command> har et noe innfløkt grensesnitt, kan du foretrekke å bruke <command>rcconf</command> (fra <emphasis role=\"pkg\">rcconf</emphasis>-pakken som gir et mer brukervennlig grensesnitt."

msgid "<emphasis>DEBIAN POLICY</emphasis> Restarting services"
msgstr "<emphasis>DEBIAN-RETNINGSLINJER</emphasis> Omstart av tjenester"

msgid "<primary><command>invoke-rc.d</command></primary>"
msgstr "<primary><command>invoke-rc.d</command></primary>"

msgid "<primary>service</primary><secondary>restart</secondary>"
msgstr "<primary>tjenesten</primary><secondary>restart</secondary>"

msgid "<primary>restarting services</primary>"
msgstr "<primary>omstart av tjenester</primary>"

msgid "The maintainer scripts for Debian packages will sometimes restart certain services to ensure their availability or get them to take certain options into account. The command that controls a service — <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> — doesn't take runlevel into consideration, assumes (wrongly) that the service is currently being used, and may thus initiate incorrect operations (starting a service that was deliberately stopped, or stopping a service that is already stopped, etc.). Debian therefore introduced the <command>invoke-rc.d</command> program: this program must be used by maintainer scripts to run services initialization scripts and it will only execute the necessary commands. Note that, contrary to common usage, the <filename>.d</filename> suffix is used here in a program name, and not in a directory."
msgstr "Vedlikeholdsskripter for Debian-pakker vil noen ganger gi visse tjenester en omstart for å sikre at de er tilgjengelige, eller få dem til å ta hensyn til visse valgmuligheter. Kommandoen som styrer en tjeneste - <command>tjeneste <replaceable>tjeneste</replaceable> <replaceable>operasjon</replaceable></command> - tar ikke driftsnivå i betraktning, forutsetter (feilaktig) at tjenesten brukes for øyeblikket, og kan dermed iverksette uriktige operasjoner (starter en tjeneste som bevisst var bevisst, eller stoppe en tjeneste som allerede er stanset, etc.). Debian introduserte derfor <command>invoke-rc.d</command>-programmet: Dette programmet må benyttes av vedlikeholdsskripter til å kjøre skripter for å ta initiativet til tjenester, og det vil bare utføre de nødvendige kommandoer. Legg merke til at, i motsetning til vanlig bruk, er <filename>.d</filename>-suffikset her brukt i et programnavn, og ikke i en katalog."

msgid "Finally, <command>init</command> starts control programs for various virtual consoles (<command>getty</command>). It displays a prompt, waiting for a username, then executes <command>login <replaceable>user</replaceable></command> to initiate a session."
msgstr "Til slutt, <command>init</command> starter kontrollprogrammer for ulike virtuelle konsoller (<command>getty</command>). Den viser en ledetekst, venter på et brukernavn, og så kjører <command>login <replaceable>bruker</replaceable></command> for å starte en økt."

msgid "<primary><command>getty</command></primary>"
msgstr "<primary><command>getty</command></primary>"

msgid "<primary>service</primary><secondary><filename>getty@.service</filename></secondary>"
msgstr "<primary>tjeneste</primary><secondary><filename>getty@.service</filename></secondary>"

msgid "<emphasis>VOCABULARY</emphasis> Console and terminal"
msgstr "<emphasis>ORDFORRÅD</emphasis> Konsoll og terminal"

msgid "<primary>console</primary>"
msgstr "<primary>konsoll</primary>"

msgid "<primary>terminal</primary>"
msgstr "<primary>terminal</primary>"

msgid "The first computers were usually separated into several, very large parts: the storage enclosure and the central processing unit were separate from the peripheral devices used by the operators to control them. These were part of a separate furniture, the “console”. This term was retained, but its meaning has changed. It has become more or less synonymous with “terminal”, being a keyboard and a screen."
msgstr "De første datamaskinene besto vanligvis av flere, svært store deler: Lagringskabinett og den sentrale prosessenheten var atskilt fra eksterne enheter som ble brukt av operatørene til å kontrollere maskinene. Dette var deler i et eget møbel, «konsollet». Dette begrepet ble beholdt, men betydningen har endret seg. Det har blitt mer eller mindre synonymt med «terminal», som er et tastatur og en skjerm."

msgid "With the development of computers, operating systems have offered several virtual consoles to allow for several independent sessions at the same time, even if there is only one keyboard and screen. Most GNU/Linux systems offer six virtual consoles (in text mode), accessible by typing the key combinations <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> through <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>."
msgstr "Med utviklingen av datamaskiner, tilbyr operativsystemer flere virtuelle konsoller for å muliggjøre flere uavhengige økter på samme tid, selv om det er bare ett tastatur og en skjerm. De fleste GNU/Linux-systemer tilbyr seks virtuelle konsoller (i tekstmodus), som er tilgjengelige ved å skrive inn tastekombinasjonene <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> til <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>."

msgid "By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical session (such as <command>xterm</command>, <command>gnome-terminal</command> or <command>konsole</command>)."
msgstr "I forlengelsen av dette, kan begrepene «konsoll» og «terminal» også referere til en terminalemulator i en grafisk økt (for eksempel <command>xterm</command>, <command>gnome-terminal</command>, eller <command>konsole</command>)."

msgid "Remote Login"
msgstr "Ekstern innlogging"

msgid "It is essential for an administrator to be able to connect to a computer remotely. Servers, confined in their own room, are rarely equipped with permanent keyboards and monitors — but they are connected to the network."
msgstr "Det er viktig for en administrator å kunne koble seg til en datamaskin utenfra. Tjenere, innesperret i sitt eget rom, er sjelden utstyrt med permanente tastaturer og skjermer - men de er koblet til nettverket."

msgid "<emphasis>BACK TO BASICS</emphasis> Client, server"
msgstr "<emphasis>DET GRUNNLEGGENDE</emphasis> Klient, tjener"

msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>klient</primary><secondary>klient-/tjener -arkitektur</secondary>"

msgid "<primary>server</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>tjener</primary><secondary>klient-/tjener -arkitektur</secondary>"

msgid "A system where several processes communicate with each other is often described with the “client/server” metaphor. The server is the program that takes requests coming from a client and executes them. It is the client that controls operations, the server doesn't take any initiative of its own."
msgstr "Et system hvor flere prosesser kommuniserer med hverandre, blir ofte beskrevet med «klient/tjener» metaforer. Tjeneren er programmet som tar forespørsler som kommer fra en klient, og utfører dem. Det er klienten som styrer operasjonene, tjeneren tar ikke noen egne initiativ."

msgid "<primary>login</primary><secondary>remote login</secondary>"
msgstr "<primary>logg inn</primary><secondary>logge inn eksternt </secondary>"

msgid "<primary>remote login</primary>"
msgstr "<primary>logge inn eksternt</primary>"

msgid "Secure Remote Login: SSH"
msgstr "Sikker ekstern innlogging: SSH"

msgid "<primary>SSH</primary>"
msgstr "<primary>SSH</primary>"

msgid "<primary>server</primary><secondary>SSH</secondary>"
msgstr "<primary>tjener</primary><secondary>SSH</secondary>"

msgid "<primary><command>ssh</command></primary>"
msgstr "<primary><command>ssh</command></primary>"

msgid "<primary>Secure Shell</primary><seealso>SSH</seealso>"
msgstr "<primary>Secure Shell</primary><seealso>SSH</seealso>"

msgid "The <emphasis>SSH</emphasis> (Secure SHell) protocol was designed with security and reliability in mind. Connections using SSH are secure: the partner is authenticated and all data exchanges are encrypted."
msgstr "<emphasis>SSH</emphasis> (Secure SHell)-protokollen ble utformet med tanke på sikkerhet og pålitelighet. Tilkoblinger som bruker SSH er sikre: Partneren er godkjent, og all datautveksling er kryptert."

msgid "<emphasis>CULTURE</emphasis> Telnet and RSH are obsolete"
msgstr "<emphasis>KULTUR</emphasis> Telnet og RSH er foreldet"

msgid "<primary><command>telnet</command></primary>"
msgstr "<primary><command>telnet</command></primary>"

msgid "<primary><command>rsh</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

msgid "Before SSH, <emphasis>Telnet</emphasis> and <emphasis>RSH</emphasis> were the main tools used to login remotely. They are now largely obsolete and should no longer be used even if Debian still provides them."
msgstr "Før SSH var <emphasis>Telnet</emphasis> og <emphasis>RSH</emphasis> de viktigste verktøyene for ekstern innlogging. Nå er de i stor grad foreldet, og skal ikke lenger brukes selv om Debian fortsatt har dem med."

msgid "<emphasis>VOCABULARY</emphasis> Authentication, encryption"
msgstr "<emphasis>ORDFORRÅD</emphasis> Autentisering, kryptering"

#, fuzzy
#| msgid "When you need to give a client the ability to conduct or trigger actions on a server, security is important. You must ensure the identity of the client; this is authentication. This identity usually consists of a password that must be kept secret, or any other client could get the password. This is the purpose of encryption, which is a form of encoding that allows two systems to communicate confidential information on a public channel while protecting it from being readable to others."
msgid "When you need to give a client the ability to conduct or trigger actions on a server, security is important. You must ensure the identity of the client; this is <emphasis>authentication</emphasis>. This identity usually consists of a password or passphrase that must be kept secret, or any other client could it. This is the purpose of <emphasis>encryption</emphasis>, which is a form of encoding that allows two systems to communicate confidential information on a public channel while protecting it from being readable to others."
msgstr "Når du trenger å gi en klient evnen til å utføre eller utløse handlinger på en tjener, er sikkerhet viktig. Du må sikre identiteten til klienten; dette er autentisering. Denne identiteten består vanligvis av et passord som må holdes hemmelig, ellers kan hvilken som helst skaffe seg passordet. Dette er hensikten med kryptering, som er en form for koding som tillater to systemer å kommunisere konfidensiell informasjon på en offentlig kanal, samtidig som den er beskyttet mot å være lesbar for andre."

msgid "Authentication and encryption are often mentioned together, both because they are frequently used together, and because they are usually implemented with similar mathematical concepts."
msgstr "Autentisering og kryptering er ofte nevnt sammen, både fordi de ofte er brukt sammen, og fordi de vanligvis gjennomføres med matematiske begreper som ligner hverandre."

msgid "<primary><command>scp</command></primary>"
msgstr "<primary><command>scp</command></primary>"

msgid "SSH also offers two file transfer services. <command>scp</command> is a command line tool that can be used like <command>cp</command>, except that any path to another machine is prefixed with the machine's name, followed by a colon."
msgstr "SSH tilbyr også to filoverføringstjenester. <command>scp</command> er et kommandolinjeverktøy som kan brukes som <command>cp</command>, bortsett fra at hvilken som helst sti til en annen maskin har et prefiks med maskinens navn, etterfulgt av et kolon."

msgid "<computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput>"
msgstr "<computeroutput>$ </computeroutput><userinput>scp fil maskin:/tmp/</userinput>"

msgid "<primary><command>sftp</command></primary>"
msgstr "<primary><command>sftp</command></primary>"

msgid "<command>sftp</command> is an interactive command, similar to <command>ftp</command>. In a single session, <command>sftp</command> can transfer several files, and it is possible to manipulate remote files with it (delete, rename, change permissions, etc.)."
msgstr "<command>sftp</command> er en interaktiv kommando, som svarer til <command>ftp</command>. I en enkelt økt kan <command>sftp</command> overføre flere filer, og med den er det mulig å manipulere eksterne filer (slette, endre navn, endre tillatelser, etc.)."

msgid "<primary>OpenSSH</primary><seealso>SSH</seealso>"
msgstr "<primary>OpenSSH</primary><seealso>SSH</seealso>"

msgid "<primary>SSH</primary><secondary>OpenSSH</secondary>"
msgstr "<primary>SSH</primary><secondary>OpenSSH</secondary>"

msgid "Debian uses OpenSSH, a free version of SSH maintained by the <command>OpenBSD</command> project (a free operating system based on the BSD kernel, focused on security) and fork of the original SSH software developed by the SSH Communications Security Corp company, of Finland. This company initially developed SSH as free software, but eventually decided to continue its development under a proprietary license. The OpenBSD project then created OpenSSH to maintain a free version of SSH."
msgstr "Debian bruker OpenSSH, som er en fri versjon av SSH, som vedlikeholdes av <command>OpenBSD</command>-prosjektet (et fritt operativsystem basert på BSD-kjernen, med fokus på sikkerhet), og er en forgrening av den opprinnelige SSH-programvaren utviklet av selskapet SSH Communications Security Corp i Finland. Dette selskapet utviklet opprinnelig SSH som fri programvare, men som til slutt bestemte seg for å fortsette utviklingen under en proprietær lisens. OpenBSD-prosjektet opprettet deretter OpenSSH for å opprettholde en fri versjon av SSH."

msgid "<emphasis>BACK TO BASICS</emphasis> <foreignphrase>Fork</foreignphrase>"
msgstr "<emphasis>DET GRUNNLEGGENDE</emphasis> <foreignphrase>forgrening</foreignphrase>"

msgid "<primary>fork</primary>"
msgstr "<primary>forgrening</primary>"

msgid "A “fork”, in the software field, means a new project that starts as a clone of an existing project, and that will compete with it. From there on, both software will usually quickly diverge in terms of new developments. A fork is often the result of disagreements within the development team."
msgstr "På programvarefeltet betyr en «forgrening et nytt prosjekt som starter som en klone av et eksisterende prosjekt, og som vil konkurrere med det. Fra da av vil begge programvarer raskt avvike fra hverandre i nyutvikling. En forgrening er ofte et resultat av uenighet innenfor utviklingsteamet."

msgid "The option to fork a project is a direct result of the very nature of free software; a fork is a healthy event when it enables the continuation of a project as free software (for example in case of license changes). A fork arising from technical or personal disagreements is often a waste of human resources; another resolution would be preferable. Mergers of two projects that previously went through a prior fork are not unheard of."
msgstr "Alternativet til å «forgrene» et prosjekt, er et direkte resultat av selve naturen til fri programvare; en forgrening er en sunn hendelse når det muliggjør en videreføring av et prosjekt som fri programvare (for eksempel i tilfelle av lisensendringer). En forgrening, som følge av tekniske eller personlige uoverensstemmelser, er ofte en sløsing med menneskelige ressurser; en annen løsning ville være å foretrekke. Det har skjedd at to prosjekter som tidligere har delt seg, senere har slått seg sammen igjen."

msgid "<primary><emphasis role=\"pkg\">openssh-client</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">openssh-client</emphasis></primary>"

msgid "<primary><emphasis role=\"pkg\">openssh-server</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">openssh-server</emphasis></primary>"

msgid "OpenSSH is split into two packages: the client part is in the <emphasis role=\"pkg\">openssh-client</emphasis> package, and the server is in the <emphasis role=\"pkg\">openssh-server</emphasis> package. The <emphasis role=\"pkg\">ssh</emphasis> meta-package depends on both parts and facilitates installation of both (<command>apt install ssh</command>), while the <emphasis role=\"pkg\">task-ssh-server</emphasis>, often chosen during the initial installation, depends on the server package only."
msgstr "OpenSSL er delt i to pakker: Klientdelen er i <emphasis role=\"pkg\">openssh-client</emphasis>-pakken, og tjeneren er i <emphasis role=\"pkg\">openssh-server</emphasis>-pakken. <emphasis role=\"pkg\">ssh</emphasis>-meta-pakken er avhengig av begge, og forenkler installeringen av begge (<command>apt install ssh</command>), selv om <emphasis role=\"pkg\">task-ssh-server</emphasis> (ofte valgt under innledende installasjon) avhenger kun av tjenerpakken."

msgid "Key-Based Authentication"
msgstr "Nøkkel-basert autentisering"

msgid "<primary>SSH</primary><secondary>key creation</secondary>"
msgstr "<primary>SSH</primary><secondary>nøkkeloppretting</secondary>"

msgid "Each time someone logs in over SSH, the remote server asks for a password to authenticate the user. This can be problematic if you want to automate a connection, or if you use a tool that requires frequent connections over SSH. This is why SSH offers a key-based authentication system."
msgstr "Hver gang noen logger inn over SSH, spør en ekstern tjener om et passord for å autentisere brukeren. Dette kan være problematisk hvis du ønsker å automatisere en tilkobling, eller hvis du bruker et verktøy som krever hyppige forbindelser over SSH. Dette er grunnen til at SSH tilbyr et nøkkelbasert autentiseringssystem."

msgid "<primary><command>ssh-keygen</command></primary>"
msgstr "<primary><command>ssh-keygen</command></primary>"

msgid "<primary><command>ssh-copy-id</command></primary>"
msgstr "<primary><command>ssh-copy-id</command></primary>"

msgid "The user generates a key pair on the client machine with <command>ssh-keygen -t rsa</command>; the so generated public key is stored in <filename>~/.ssh/id_rsa.pub</filename>, while the corresponding private key is stored in <filename>~/.ssh/id_rsa</filename>. The user can then use <command>ssh-copy-id <replaceable>server</replaceable></command> to add their public key to the <filename>~/.ssh/authorized_keys</filename> file on the server, or, if SSH access hasn't been enabled yet, they have to ask the administrator to add their key manually."
msgstr "Brukeren genererer et nøkkelpar på klientmaskinen med <command>ssh-keygen -t rsa</command>; den deretter genererte offentlige nøkkelen lagres i <filename>~/.ssh/id_rsa.pub</filename>, mens den private motsatsen lagres i <filename>~/.ssh/id_rsa</filename>. Brukeren kan deretter bruke <command>ssh-copy-id <replaceable>tjener</replaceable></command> for å legge til sin offentlige nøkkel til i <filename>~/.ssh/authorized_keys</filename>-filen på tjeneren, eller, (hvis SSH-tilgang ikke har blitt påskrudd enda) spørre administrator om å legge til brukerens nøkkel manuelt."

msgid "<primary>SSH</primary><secondary>passphrase cache</secondary>"
msgstr "<primary>SSH</primary><secondary>passordfrase-mellomlager</secondary>"

msgid "<primary>SSH</primary><secondary>passwordless</secondary>"
msgstr "<primary>SSH</primary><secondary>passordløst</secondary>"

#, fuzzy
#| msgid "<primary>logs</primary><secondary>dispatching</secondary>"
msgid "<primary>SSH</primary><secondary>authentication agent</secondary>"
msgstr "<primary>logger</primary><secondary>utsending</secondary>"

msgid "<primary><command>ssh-agent</command></primary>"
msgstr "<primary><command>ssh-agent</command></primary>"

msgid "<primary>X.org</primary><secondary><filename>/etc/X11/Xsession.options</filename></secondary>"
msgstr "<primary>X.org</primary><secondary><filename>/etc/X11/Xsession.options</filename></secondary>"

msgid "If the private key was not protected with a “passphrase” at the time of its creation, all subsequent logins on the server will work without a password. Otherwise, the private key must be decrypted each time by entering the passphrase. Fortunately, <command>ssh-agent</command> allows us to keep private keys in memory to not have to regularly re-enter the password. For this, you simply use <command>ssh-add</command> (once per work session) provided that the session is already associated with a functional instance of <command>ssh-agent</command>. Debian activates it by default in graphical sessions, but this can be deactivated by changing <filename>/etc/X11/Xsession.options</filename> and commenting out <literal>use-ssh-agent</literal>. For a console session, you can manually start the agent with <command>eval $(ssh-agent)</command>."
msgstr "Dersom den private nøkkelen ikke var beskyttet med en «adgangsfrase» p å tidspunktet for etableringen, vil alle etterfølgende innlogginger på serveren fungere uten et passord. Ellers må den private nøkkelen dekrypteres hver gang ved å skrive inn passordet. Heldigvis tillater <command>ssh-agent</command> oss å holde private nøkler i minnet for å ikke regelmessig måtte taste inn igjen passord. For dette bruker du bare <command>ssh-add</command> (én gang per økt), forutsatt at økten allerede er knyttet til en funksjonell forekomst med <command>ssh-agent</command>. Debian aktiverer den som standard i grafiske økter, men dette kan deaktiveres ved å endre <filename>/etc/X11/Xsession.options</filename> og kommentere ut <literal>use-ssh-agent</literal>. Du kan manuelt starte agenten for en konsolløkt med <command>eval $(ssh-agent)</command>."

msgid "<emphasis>SECURITY</emphasis> Protection of the private key"
msgstr "<emphasis>SIKKERHET</emphasis> Beskyttelse av den private nøkkelen"

msgid "<primary>SSH</primary><secondary>private key</secondary>"
msgstr "<primary>SSH</primary><secondary>privat nøkkel</secondary>"

msgid "Whoever has the private key can login on the account thus configured. This is why access to the private key is protected by a “passphrase”. Someone who acquires a copy of a private key file (for example, <filename>~/.ssh/id_rsa</filename>) still has to know this phrase in order to be able to use it. This additional protection is not, however, impregnable, and if you think that this file has been compromised, it is best to disable that key on the computers in which it has been installed (by removing it from the <filename>authorized_keys</filename> files) and replacing it with a newly generated key."
msgstr "Den som har den private nøkkelen, kan logge seg på den kontoen som er satt opp for det. Dette er grunnen til at tilgang til den private nøkkelen er beskyttet av en «adgangsfrase» («passphrase»). Noen som får en kopi av en privat nøkkelfil (for eksempel <filename>~/.ssh/id_rsa</filename>), må fremdeles kjenne denne frasen for å kunne bruke den. Denne ekstra beskyttelse er imidlertid ikke uangripelig, og hvis du tror at denne filen har blitt kompromittert, er det best å deaktivere den nøkkelen på datamaskinene der den har blitt installert (ved å fjerne den fra <filename>authorized_keys</filename> filer), og erstatte den med en nylig generert nøkkel."

msgid "<emphasis>CULTURE</emphasis> OpenSSL flaw in Debian <emphasis role=\"distribution\">Etch</emphasis>"
msgstr "<emphasis>KULTUR</emphasis> OpenSSL feil i Debian <emphasis role=\"distribution\">Etch</emphasis>"

msgid "The OpenSSL library, as initially provided in Debian <emphasis role=\"distribution\">Etch</emphasis>, had a serious problem in its random number generator (RNG). Indeed, the Debian maintainer had made a change so that applications using it would no longer generate warnings when analyzed by memory testing tools like <command>valgrind</command>. Unfortunately, this change also meant that the RNG was employing only one source of entropy corresponding to the process number (PID) whose 32,000 possible values do not offer enough randomness. <ulink type=\"block\" url=\"https://www.debian.org/security/2008/dsa-1571\" />"
msgstr "OpenSSL-biblioteket, som i utgangspunktet er tilgjengelig i Debian <emphasis role=\"distribution\">Etch</emphasis>, hadde et alvorlig problem i sin generator for tilfeldige tall (RNG). Faktisk hadde Debians vedlikeholder gjort en endring slik at programmer som bruker den, ikke lenger ville generere advarsler når den ble analysert av et testverktøy for minnet som <command>valgrind</command>. Dessverre, denne endringen betydde også at RNG-en bare anvender en entropi-kilde som korresponderer med prosessantallet (PID), der 32 000 mulige verdier ikke gir tilstrekkelig tilfeldighet. <ulink type=\"block\" url=\"https://www.debian.org/security/2008/dsa-1571\" />"

msgid "<primary><command>ssh-vulnkey</command></primary>"
msgstr "<primary><command>ssh-vulnkey</command></primary>"

msgid "<primary><emphasis role=\"pkg\">openssh-blacklist</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">openssh-blacklist</emphasis></primary>"

msgid "Specifically, whenever OpenSSL was used to generate a key, it always produced a key within a known set of hundreds of thousands of keys (32,000 multiplied by a small number of key lengths). This affected SSH keys, SSL keys, and X.509 certificates used by numerous applications, such as OpenVPN. A cracker had only to try all of the keys to gain unauthorized access. To reduce the impact of the problem, the SSH daemon was modified to refuse problematic keys that are listed in the <emphasis role=\"pkg\">openssh-blacklist</emphasis> and <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis> packages. Additionally, the <command>ssh-vulnkey</command> command allows identification of possibly compromised keys in the system."
msgstr "Spesielt når OpenSSL ble brukt til å generere en nøkkel, produserte den alltid en nøkkel i løpet av et visst sett av hundretusener av nøkler (32 000 multiplisert med et lite antall nøkkellengder). Dette påvirket SSH-nøkler, SSL-nøkler og X.509-sertifikater som brukes av mange programmer, som OpenVPN. En inntrenger trengte bare å prøve alle nøklene for å få uautorisert tilgang. For å redusere virkningen av problemet ble SSH-bakgrunnsprosessen modifisert til å nekte problematiske nøkler som er oppført i <emphasis role=\"pkg\">openssh-blacklist</emphasis>- og <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis>-pakkene. I tillegg tillater <command>ssh-vulnkey</command>-kommandoen identifisering av mulige kompromitterte nøkler i systemet."

msgid "A more thorough analysis of this incident brings to light that it is the result of multiple (small) problems, both within the OpenSSL project and with the Debian package maintainer. A widely used library like OpenSSL should — without modifications — not generate warnings when tested by <command>valgrind</command>. Furthermore, the code (especially the parts as sensitive as the RNG) should be better commented to prevent such errors. On Debian's side, the maintainer wanted to validate the modifications with the OpenSSL developers, but simply explained the modifications without providing the corresponding patch to review and failed to mention his role within Debian. Finally, the maintenance choices were sub-optimal: the changes made to the original code were not clearly documented; all the modifications were effectively stored in a Subversion repository, but they ended up all lumped into one single patch during creation of the source package."
msgstr "En grundigere analyse av denne hendelsen bringer frem i lyset at det er et resultat av flere (små) problemer, både i OpenSSL-prosjektet og med Debian-pakkevedlikeholderen. Et mye brukt bibliotek som OpenSSL skal - uten endringer - ikke generere advarsler under testing av <command>valgrind</command>. Videre bør koden (spesielt de delene som er så følsomme som RNG) bli bedre kommentert for å forhindre slike feil. På Debians side, ønsket vedlikeholderen å validere modifikasjonene med OpenSSLs utviklere, men forklarte ganske enkelt endringene, uten å legge ut den korresponderende programfiksen til gjennomgang, og unnlot å nevne sin rolle i Debian. Endelig, vedlikeholdsvalgene var sub-optimale: Endringene i den opprinnelige koden ble ikke klart dokumentert; alle modifikasjoner ble effektivt lagret i et Subversjon-depot, men de endte opp med alt samlet i en enkelt programfiks under oppretting av kildepakken."

msgid "It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type=\"block\" url=\"https://sources.debian.org\" />"
msgstr "Det er vanskelig under slike forhold å finne de korrigerende tiltak for å hindre gjentakelse av slike hendelser. Denne leksen ga her den lærdommen at alle divergenser Debian introduserer i oppstrøms programvare, må begrunnes, dokumenteres, sendes til oppstrømsprosjektetet når det er mulig, og publiseres vidt. Det er ut fra dette perspektivet at det nye kildepakkeformatet («3.0 (quilt)») og webtjenesten for Debian-kilder ble utviklet. <ulink type=\"block\" url=\"https://sources.debian.netorg\" />"

msgid "Cert-Based Authentication"
msgstr "Sertifikatsbasert autentisering"

msgid "<primary>SSH</primary><secondary>signed key</secondary>"
msgstr "<primary>SSH</primary><secondary>signert nøkkel</secondary>"

msgid "<primary>SSH</primary><secondary><literal>TrustedUserCAKeys</literal></secondary>"
msgstr "<primary>SSH</primary><secondary><literal>TrustedUserCAKeys</literal></secondary>"

msgid "<primary>SSH</primary><secondary><literal>HostCertificate</literal></secondary>"
msgstr "<primary>SSH</primary><secondary><literal>HostCertificate</literal></secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/ssh/sshd_config</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/ssh/sshd_config</filename></secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/ssh/known_hosts</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/ssh/known_hosts</filename></secondary>"

#, fuzzy
msgid "SSH keys cannot just be protected by a password (or not). An often unknown feature is that they can also be signed via certificate, both the host as well as the client keys. This approach comes with several advantages. Instead of maintaining an <filename>authorized_keys</filename> file per user as described in the previous section, the SSH server can be configured to trust all client keys signed by the same certificate (see also <xref linkend=\"sect.easy-rsa\" />) by using the <literal>TrustedUserCAKeys</literal> and <literal>HostCertificate</literal> directives in <filename>/etc/ssh/sshd_config</filename>."
msgstr "SSH-nøkler kan ikke bare beskyttes med et passord (eller ei). En funksjon som ofte går upåaktet hen er at de kan signeres via sertifikat, både for verts- og klientnøklene. Denne tilnærmingen har flere fordeler. Istedenfor å håndtere en <filename>authorized_keys</filename>-fil per bruker som beskrevet i forrige del, kan SSH-tjeneren settes opp til å stole på alle klientnøkler signert av samme sertifikat (mer om dette i <xref linkend=\"sect.easy-rsa\" />) ved bruk av <literal>TrustedUserCAKeys</literal> og <literal>HostCertificate</literal> mappene i <filename>/etc/ssh/sshd_config</filename>."

#, fuzzy
msgid ""
"\n"
"TrustedUserCAKeys /etc/ssh/ssh_users_ca.pub\n"
"\n"
"HostKey /etc/ssh/ssh_host_ecdsa_key\n"
"HostCertificate /etc/ssh/ssh_host_ecdsa_key-cert.pub"
msgstr "\nBetroddeBrukerSertifikatmyndighetsNøkler /etc/ssh/ssh_users_ca.pub\n\nVertsNøkkel /etc/ssh/ssh_host_ecdsa_key\nVertsSertifikat /etc/ssh/ssh_host_ecdsa_key-cert.pub"

msgid "Vice-versa the clients can also be configured to trust the host key signed by the same authority, making it easier to maintain the <filename>known_hosts</filename> file (even system wide via <filename>/etc/ssh/known_hosts</filename>)."
msgstr "Vice versa kan klientene også settes opp til å stole på vertsnøkkelen signert av samme myndighet, noe som gjør det enklere å håndtere <filename>known_hosts</filename>-filen (selv for hele systemet via <filename>/etc/ssh/known_hosts</filename>)."

msgid "@cert-authority *.falcot.com ssh-rsa AAAA[..]"
msgstr "@cert-authority *.falcot.com ssh-rsa AAAA[..]"

msgid "Both, public key and certificate authentication, can be used alongside each other."
msgstr "Både identitetsbekreftelse med offentlig nøkkel og sertifikat kan brukes samtidig."

msgid "Using Remote X11 Applications"
msgstr "Ved hjelp av Remote X11-programmer"

msgid "<primary>SSH</primary><secondary><literal>X11Forwarding</literal></secondary>"
msgstr "<primary>SSH</primary><secondary><literal>X11Forwarding</literal></secondary>"

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary>SSH</primary><secondary><literal>remote graphical applications</literal></secondary>"
msgstr "<primary>logg inn</primary><secondary>logge inn eksternt </secondary>"

msgid "<primary>remote graphical application</primary>"
msgstr "<primary>eksternt grafisk program</primary>"

#, fuzzy
#| msgid "<primary>desktop, remote graphical desktop</primary>"
msgid "<primary>application, remote graphical application</primary>"
msgstr "<primary>skrivebord, ekstern grafisk skrivebord</primary>"

msgid "The SSH protocol allows forwarding of graphical data (“X11” session, from the name of the most widespread graphical system in Unix); the server then keeps a dedicated channel for those data. Specifically, a graphical program executed remotely can be displayed on the X.org server of the local screen, and the whole session (input and display) will be secure. Since this feature allows remote applications to interfere with the local system, it is disabled by default. You can enable it by specifying <literal>X11Forwarding yes</literal> in the server configuration file (<filename>/etc/ssh/sshd_config</filename>). Finally, the user must also request it by adding the <literal>-X</literal> option to the <command>ssh</command> command-line."
msgstr "SSH-protokollen tillater videresending av grafiske data («X11»-økt, fra navnet på det mest utbredte grafiske systemet i Unix); tjeneren holder da en egen kanal for disse dataene. Spesielt kan et grafisk program, kjørt eksternt, vises på X.org-tjeneren til den lokale skjermen, og hele økten (inndata og visning) vil være sikker. Ettersom denne funksjonen tillater at eksterne programmer forstyrrer det lokale systemet, er det deaktivert som standard. Du kan aktivere det ved å angi <literal>X11Forwarding yes</literal> i tjeneroppsettsfilen (<filename>/etc/ssh/sshd_config</filename>). Avslutningsvis må brukeren også be om det ved å legge <literal>-X</literal>-valget til <command>ssh</command>-kommandolinjen."

msgid "<emphasis>GOING FURTHER</emphasis> Magic cookies in .Xauthority"
msgstr "<emphasis>FOR VIDEREKOMMENDE</emphasis> Magiske informasjonskapsler i .Xauthority"

msgid "<primary><filename>.Xauthority</filename></primary>"
msgstr "<primary><filename>.Xauthority</filename></primary>"

msgid "<primary><command>xauth</command></primary>"
msgstr "<primary><command>xauth</command></primary>"

msgid "<primary>magic cookie</primary>"
msgstr "<primary>magisk informasjonskapsel</primary>"

msgid "When a user connects via SSH and starts a remote X11 session, a so-called <emphasis>magic cookie</emphasis> is created and stored in the <filename>.Xauthority</filename> file in the user's home directory that initiated the connection. This cookie is used by <command>xauth</command> to authenticate the user during the X session. If the user impersonates another user on the system, e.g. using <command>su</command> or <command>sudo</command>, then the cookie is not copied automatically to the target user and the X server will refuse to start graphical applications under the target user's context. You will have to copy the magic cookie into the target user's home directory (by exporting and re-importing the cookie via <command>xauth</command>) to allow another user to start graphical programs as well during the X session."
msgstr "Når en bruker kobler til via SSH og starter en X11-økt annensteds fra, vil en såkalt <emphasis>magisk kake</emphasis> opprettes og lagres i <filename>.Xauthority</filename>-fil i brukermappen til den som igangsatte tilkoblingen. Denne kaken brukes av <command>xauth</command> til å identitetsbekrefte brukeren i løpet av X-økten. Hvis brukeren later som om den er noen andre på systemet, f.eks. ved bruk av <command>su</command> eller <command>sudo</command>, blir kaken ikke kopiert automatisk til målbrukeren, og X-tjeneren vil nekte å starte grafiske programmer i målbrukerens kontekst. Du vil måtte kopiere den magiske kaken inn i målbrukerens hjemmemappe (før du eksporterer og reimporterer kaken via <command>xauth</command>) for å tillate en annen bruker å også starte grafiske programmer i løpet av X-økten."

msgid "Creating Encrypted Tunnels with Port Forwarding"
msgstr "Å lage krypterte tunneler med portvideresending (Port Forwarding)"

msgid "<primary>port forwarding</primary>"
msgstr "<primary>port-videresending (port forwarding)</primary>"

msgid "<primary>SSH</primary><secondary>port forwarding</secondary>"
msgstr "<primary>SSH</primary><secondary>portvideresending</secondary>"

msgid "<primary>SSH</primary><secondary>tunnel</secondary>"
msgstr "<primary>SSH</primary><secondary>tunnell</secondary>"

msgid "Its <literal>-R</literal> and <literal>-L</literal> options allow <command>ssh</command> to create “encrypted tunnels” between two machines, securely forwarding a local TCP port (see sidebar <xref linkend=\"sidebar.tcp-udp\" />) to a remote machine or vice versa."
msgstr "Dets <literal>-R</literal> og <literal>-L</literal>-valg tillater <command>ssh</command> å lage «krypterte tunneler» mellom to maskiner, sikker videresending til en lokal TCP-port (se sidestolpe <xref linkend=\"sidebar.tcp-udp\" />) til en ekstern maskin og omvendt."

msgid "<emphasis>VOCABULARY</emphasis> Tunnel"
msgstr "<emphasis>ORDFORRÅD</emphasis> Tunnel"

msgid "<primary>tunnel</primary><secondary>SSH</secondary><seealso>VPN</seealso>"
msgstr "<primary>tunnell</primary><secondary>SSH</secondary><seealso>VPN</seealso>"

msgid "<primary>SSH</primary><secondary>tunnel</secondary><seealso>VPN</seealso>"
msgstr "<primary>SSH</primary><secondary>tunnell</secondary><seealso>VPN</seealso>"

msgid "The Internet, and most LANs that are connected to it, operate in packet mode and not in connected mode, meaning that a packet issued from one computer to another is going to be stopped at several intermediary routers to find its way to its destination. You can still simulate a connected operation where the stream is encapsulated in normal IP packets. These packets follow their usual route, but the stream is reconstructed unchanged at the destination. We call this a “tunnel”, analogous to a road tunnel in which vehicles drive directly from the entrance (input) to the exit (output) without encountering any intersections, as opposed to a path on the surface that would involve intersections and changing direction."
msgstr "Internettet, og de fleste lokalnett som er koblet til det, opererer i pakke-modus, og ikke i tilkoblet modus. Dette betyr at en pakke utstedt fra en datamaskin til en annen, kommer til å bli oppholdt på flere mellomliggende rutere for å finne veien til sin destinasjon. Du kan fortsatt simulere en tilkoblet operasjon der strømmen er innkapslet i normale IP-pakker. Disse pakkene følger sin vanlige rute, men strømmen blir rekonstruert uendret på bestemmelsesstedet. Vi kaller dette en «tunnel», tilsvarende en veitunnel der biler kjører direkte fra inngangen (inndata) til utgangen (utdata) uten å møte noen kryss, i motsetning til en bane på overflaten, som ville innebære kryss og skiftende retninger."

msgid "You can use this opportunity to add encryption to the tunnel: the stream that flows through it is then unrecognizable from the outside, but it is returned in decrypted form at the exit of the tunnel."
msgstr "Du kan bruke denne muligheten til å legge kryptering til tunnelen: Strømmen som flommer igjennom er da ugjenkjennelig fra utsiden, men den blir levert dekryptert ved utgangen av tunnelen."

msgid "<command>ssh -L 8000:server:25 intermediary</command> establishes an SSH session with the <replaceable>intermediary</replaceable> host and listens to local port 8000 (see <xref linkend=\"figure.ssh-L\" />). For any connection established on this port, <command>ssh</command> will initiate a connection from the <replaceable>intermediary</replaceable> computer to port 25 on the <replaceable>server</replaceable>, and will bind both connections together."
msgstr "<command>ssh -L 8000:server:25 intermediary</command> etablerer en SSH-økt med <replaceable>intermediary</replaceable>-verten, og lytter til lokal port 8000 (se <xref linkend=\"figure.ssh-L\" />). For alle tilkoblinger som etableres til denne porten, vil <command>ssh</command> initiere en forbindelse fra <replaceable>intermediary</replaceable>-datamaskinen til port 25 på <replaceable>server</replaceable>-tjeneren, og vil binde begge tilknytninger sammen."

msgid "<command>ssh -R 8000:server:25 intermediary</command> also establishes an SSH session to the <replaceable>intermediary</replaceable> computer, but it is on this machine that <command>ssh</command> listens to port 8000 (see <xref linkend=\"figure.ssh-R\" />). Any connection established on this port will cause <command>ssh</command> to open a connection from the local machine on to port 25 of the <replaceable>server</replaceable>, and to bind both connections together."
msgstr "<command>ssh -R 8000:server:25 intermediary</command> etablerer også en SSH-økt til <replaceable>intermediary</replaceable>-datamaskinen, men det er på denne maskinen at <command>ssh</command> lytter til port 8000 (se <xref linkend=\"figure.ssh-R\" />). Alle tilknytninger som er etablert til denne porten vil få <command>ssh</command> til å åpne en tilknytning fra den lokale maskinen til port 25 hos <replaceable>server</replaceable>-en, og til å binde begge tilknytninger sammen."

msgid "In both cases, connections are made to port 25 on the <replaceable>server</replaceable> host, which pass through the SSH tunnel established between the local machine and the <replaceable>intermediary</replaceable> machine. In the first case, the entrance to the tunnel is local port 8000, and the data move towards the <replaceable>intermediary</replaceable> machine before being directed to the <replaceable>server</replaceable> on the “public” network. In the second case, the input and output in the tunnel are reversed; the entrance is port 8000 on the <replaceable>intermediary</replaceable> machine, the output is on the local host, and the data are then directed to the <replaceable>server</replaceable>. In practice, the server is usually either the local machine or the intermediary. That way SSH secures the connection from one end to the other."
msgstr "I begge tilfeller er forbindelsene lagt til port 25 på <replaceable> 1server</replaceable>-verten, og passerer gjennom SSH-tunnelen som er etablert mellom den lokale maskinen og <replaceable> 3intermediary</replaceable>-maskinen. I det første tilfellet er inngangen til tunnelen lokal port 8000, og dataene beveger seg mot <replaceable>intermediary</replaceable>-maskinen før de blir dirigert videre til <replaceable>server</replaceable>en i det «offentlige» nettverket. I det andre tilfellet er inngangen og utgangen i tunnelen reversert: Inngangen er port 8000 på <replaceable>intermediary</replaceable>-maskinen, og utdataene er på den lokale verten, og dataene blir deretter sendt til <replaceable>server</replaceable>-en. I praksis er tjeneren vanligvis enten den lokale maskinen eller mellomstasjonen. På den måten sikrer SSH forbindelsen fra den ene enden til den andre."

msgid "Forwarding a local port with SSH"
msgstr "Videresende en lokal port med SSH"

msgid "Forwarding a remote port with SSH"
msgstr "Videresende en ekstern port med SSH"

msgid "Using Remote Graphical Desktops"
msgstr "Å bruke eksterne grafiske skrivebord"

msgid "VNC (Virtual Network Computing) allows remote access to graphical desktops."
msgstr "VNC (Virtual Network Computing) tillater ekstern tilgang til grafiske skrivebord."

msgid "<primary>VNC</primary>"
msgstr "<primary>VNC</primary>"

msgid "<primary>Virtual Network Computing</primary><seealso>VNC</seealso>"
msgstr "<primary>Virtual Network Computing</primary><seealso>VNC</seealso>"

msgid "<primary>graphical desktop</primary><secondary>remote</secondary>"
msgstr "<primary>grafisk skrivebord</primary><secondary>eksternt</secondary>"

msgid "<primary>remote graphical desktop</primary>"
msgstr "<primary>ekstern grafisk skrivebord</primary>"

msgid "<primary>desktop, remote graphical desktop</primary>"
msgstr "<primary>skrivebord, ekstern grafisk skrivebord</primary>"

msgid "This tool is mostly used for technical assistance; the administrator can see the errors that the user is facing, and show them the correct course of action without having to stand by them."
msgstr "Dette verktøyet er mest brukt for teknisk assistanse; administratoren kan se feil som brukeren står overfor, og vise dem hva det er riktig å gjøre, uten å måtte stå ved siden av dem."

msgid "<primary>VNC</primary><secondary>server</secondary>"
msgstr "<primary>VNC</primary><secondary>tjener</secondary>"

msgid "<primary>server</primary><secondary>VNC</secondary>"
msgstr "<primary>tjener</primary><secondary>VNC</secondary>"

msgid "<primary><emphasis role=\"pkg\">vino</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vino</emphasis></primary><seealso>VNC</seealso>"

msgid "<primary><emphasis role=\"pkg\">krfb</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">krfb</emphasis></primary><seealso>VNC</seealso>"

msgid "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary><seealso>VNC</seealso>"

msgid "<primary><emphasis role=\"pkg\">tightvncserver</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">tightvncserver</emphasis></primary><seealso>VNC</seealso>"

msgid "<primary><emphasis role=\"pkg\">tigervnc-standalone-server</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">tigervnc-standalone-server</emphasis></primary><seealso>VNC</seealso>"

#, fuzzy
#| msgid "First, the user must authorize sharing their session. The GNOME graphical desktop environment from <emphasis role=\"distribution\">Jessie</emphasis> onward includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). KDE Plasma still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon."
msgid "First, the user must authorize sharing their session. The GNOME graphical desktop environment includes that option via <menuchoice> <guimenu>Settings</guimenu> <guimenuitem>Sharing</guimenuitem> </menuchoice> (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). For this to work <emphasis role=\"pkg\">network-manager</emphasis> must be managing the network used (e.g. enable the <literal>managed</literal> mode for devices handled by <emphasis role=\"pkg\">ifupdown</emphasis> in <filename>/etc/NetworkManager/NetworkManager.conf</filename>). KDE Plasma still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> or <command>tightvncserver</command> commands (from the Debian packages of the same name) or <command>tigervncserver</command> (<emphasis role=\"pkg\">tigervnc-standalone-server</emphasis>) serve the same purpose and provide the <emphasis role=\"pkg\">vnc-server</emphasis> virtual package; you can make either of them available to the user with an explicit menu or desktop entry."
msgstr "Først må brukeren autorisere deling av sin økt. GNOMEs grafiske skrivebordsmiljø fra <emphasis role=\"distribution\">Jessie</emphasis> og videre omfatter dette alternativet i sitt oppsettspanel (i motsetning til tidligere versjoner av Debian, der brukeren måtte installere og kjøre <command>vino</command>). KDE Plasma krever fortsatt at <command>krfb</command> brukes for å tillate deling av en eksisterende økt over VNC. For andre grafiske skrivebordsmiljøer tjener <command>x11vnc</command>-kommandoen (fra Debian-pakken med samme navn) samme formål: Du kan gjøre det tilgjengelig for brukeren med et eksplisitt ikon."

msgid "<primary>VNC</primary><secondary>client</secondary>"
msgstr "<primary>VNC</primary><secondary>klient</secondary>"

msgid "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary><seealso>VNC</seealso>"

msgid "<primary><emphasis role=\"pkg\">krdc</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">krdc</emphasis></primary><seealso>VNC</seealso>"

msgid "<primary><emphasis role=\"pkg\">xtightvncviewer</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">xtightvncviewer</emphasis></primary><seealso>VNC</seealso>"

msgid "<primary><emphasis role=\"pkg\">tigervnc-viewer</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">tigervnc-viewer</emphasis></primary><seealso>VNC</seealso>"

#, fuzzy
#| msgid "When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while the KDE project provides <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xvnc4viewer</command> in the Debian package of the same name. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed."
msgid "When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while the KDE project provides <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xtightvncviewer</command> from the homonym package or <command>xtigervncviewer</command> from the <emphasis role=\"pkg\">tigervnc-viewer</emphasis> Debian package. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed."
msgstr "Når den grafiske økten er gjort tilgjengelig av VNC, må administratoren koble den til med en VNC-klient. GNOME har <command>vinagre</command> og <command>remmina</command> til det, mens KDE prosjektet inkluderer <command>krdc</command> (i menyen hos <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Tilkobling til et eksternt system (Remote Desktop Client)</guimenuitem></menuchoice>). Det er andre VNC-klienter som bruker kommandolinjen, for eksempel <command>xvnc4viewer</command> i Debian-pakken med samme navn. Når du er tilkoblet, kan administratoren se hva som skjer, arbeide eksternt på maskinen, og vise brukeren hvordan man går frem."

msgid "<emphasis>SECURITY</emphasis> VNC over SSH"
msgstr "<emphasis>SIKKERHET</emphasis> VNC over SSH"

msgid "<primary>tunnel</primary><secondary>VNC</secondary>"
msgstr "<primary>tunnell</primary><secondary>VNC</secondary>"

msgid "<primary>SSH</primary><secondary>tunnel</secondary><tertiary>VNC</tertiary>"
msgstr "<primary>SSH</primary><secondary>tunnell</secondary><tertiary>VNC</tertiary>"

msgid "<primary><command>vncviewer</command></primary>"
msgstr "<primary><command>vncviewer</command></primary>"

msgid "If you want to connect by VNC, and you don't want your data sent in clear text on the network, it is possible to encapsulate the data in an SSH tunnel (see <xref linkend=\"sect.ssh-port-forwarding\" />). You simply have to know that VNC uses port 5900 by default for the first screen (called “localhost:0”), 5901 for the second (called “localhost:1”), etc."
msgstr "Hvis du ønsker å koble til med VNC, og du ikke vil at dataene sendes i klartekst på nettverket, er det mulig å kapsle dataene i en SSH-tunnel (se <xref linkend=\"sect.ssh-port-forwarding\" />). Du må bare vite at VNC bruker port 5900 som standard for det første skjermbildet (kalt «localhost:0»), 5901 for den andre (kalt «localhost:1»), osv."

msgid "The <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> command creates a tunnel between local port 5901 in the localhost interface and port 5900 of the <replaceable>machine</replaceable> host. The first “localhost” restricts SSH to listening to only that interface on the local machine. The second “localhost” indicates the interface on the remote machine which will receive the network traffic entering in “localhost:5901”. Thus <command>vncviewer localhost:1</command> will connect the VNC client to the remote screen, even though you indicate the name of the local machine."
msgstr "<command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>maskin</replaceable></command>-kommandoen oppretter en tunnel mellom lokal port 5901 i lokalvertgrensesnittet og til 5900-porten hos <replaceable>maskin</replaceable>-verten. Den første «lokalverten» begrenser SSH til å lytte bare til det grensesnittet på den lokale maskinen. Den andre «lokalverten» indikerer grensesnittet på den eksterne maskinen som skal motta nettverkstrafikk til «localvertst:5901». Dermed vil <command>vncviewer localhost:1</command> knytte VNC-klienten til den eksterne skjermen, selv om du anga navnet på den lokale maskinen."

msgid "When the VNC session is closed, remember to close the tunnel by also quitting the corresponding SSH session."
msgstr "Når VNC-økten er lukket, må du huske å stenge tunnelen ved også å avslutte den tilsvarende SSH-økten."

msgid "<emphasis>BACK TO BASICS</emphasis> Display manager"
msgstr "<emphasis>DET GRUNNLEGGENDE</emphasis> Display manager"

msgid "<primary><command>gdm3</command></primary>"
msgstr "<primary><command>gdm3</command></primary>"

msgid "<primary><command>kdm</command></primary>"
msgstr "<primary><command>kdm</command></primary>"

msgid "<primary><command>xdm</command></primary>"
msgstr "<primary><command>xdm</command></primary>"

msgid "<primary><command>lightdm</command></primary>"
msgstr "<primary><command>lightdm</command></primary>"

msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgstr "<primary>styrer</primary><secondary>skjermstyrer</secondary>"

msgid "<primary>display manager</primary>"
msgstr "<primary>skjermstyrer</primary>"

msgid "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, and <command>xdm</command> are Display Managers (they all provide the <emphasis role=\"pkg\">x-display-manager</emphasis> meta package). They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session."
msgstr "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, og <command>xdm</command> er skjermhåndterere (de tilbyr alle <emphasis role=\"pkg\">x-display-manager</emphasis>-metapakken). De tar kontroll over det grafiske grensesnittet kort tid etter oppstart for å gi brukeren en innloggingsskjerm. Når brukeren har logget inn, kjøres de programmene som trengs for å starte en grafisk arbeidsøkt."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/gdm3/daemon.conf</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/gdm3/daemon.conf</filename></secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/inetd.conf</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/inetd.conf</filename></secondary>"

msgid "Managing Rights"
msgstr "Håndtering av rettigheter"

msgid "<primary>permissions</primary>"
msgstr "<primary>rettigheter</primary>"

msgid "<primary>rights</primary><seealso>permissions</seealso>"
msgstr "<primary>rettigheter</primary><seealso>tilganger</seealso>"

msgid "<primary>device</primary><secondary>files</secondary>"
msgstr "<primary>enhet</primary><secondary>filer</secondary>"

msgid "Linux is definitely a multi-user system, so it is necessary to provide a permission system to control the set of authorized operations on files and directories, which includes all the system resources and devices (on a Unix system, any device is represented by a file or directory). This principle is common to all Unix systems, but a reminder is always useful, especially as there are some interesting and relatively unknown advanced uses."
msgstr "Linux er definitivt et flerbrukersystem (multi-user system), så det er nødvendig å gi et tillatelsessystem for å kontrollere et sett autoriserte operasjoner på filer og kataloger, for alle systemressurser og enheter (på et Unix-system, er enhver enhet representert ved en fil eller katalog). Dette prinsippet er felles for alle Unix-systemer, men en påminnelse er alltid nyttig, særlig fordi det er noen interessante og relativt ukjente, avanserte bruksmåter."

msgid "Owners and Permissions"
msgstr "Eiere og tilganger"

msgid "<primary>user</primary><secondary>owner</secondary>"
msgstr "<primary>bruker</primary><secondary>eier</secondary>"

msgid "<primary>group</primary><secondary>owner</secondary>"
msgstr "<primary>gruppe</primary><secondary>eier</secondary>"

msgid "<primary>owner</primary><secondary>user</secondary>"
msgstr "<primary>eier</primary><secondary>bruker</secondary>"

msgid "<primary>owner</primary><secondary>group</secondary>"
msgstr "<primary>eier</primary><secondary>gruppe</secondary>"

msgid "Each file or directory has specific permissions for three categories of users:"
msgstr "Hver fil eller katalog har egne tillatelser for tre kategorier av brukere:"

msgid "<primary>permissions</primary><secondary><literal>u</literal></secondary>"
msgstr "<primary>tilganger</primary><secondary><literal>u</literal></secondary>"

msgid "its owner (symbolized by <literal>u</literal> as in “user”);"
msgstr "dens eier (symbolisert ved <literal>u</literal> som i «user»);"

msgid "<primary>permissions</primary><secondary><literal>g</literal></secondary>"
msgstr "<primary>tilganger</primary><secondary><literal>g</literal></secondary>"

msgid "its owner group (symbolized by <literal>g</literal> as in “group”), representing all the members of the group;"
msgstr "dens eiergruppe (symbolisert med <literal>g</literal> som i «gruppe»), som representerer alle medlemmene i gruppen;"

msgid "<primary>permissions</primary><secondary><literal>o</literal></secondary>"
msgstr "<primary>tilganger</primary><secondary><literal>o</literal></secondary>"

msgid "the others (symbolized by <literal>o</literal> as in “other”)."
msgstr "de andre (symbolisert med <literal>o</literal> som i «other»)."

msgid "Three basic types of rights can be combined:"
msgstr "Tre grunnleggende typer rettigheter kan kombineres:"

msgid "<primary>permissions</primary><secondary><literal>r</literal></secondary>"
msgstr "<primary>tilganger</primary><secondary><literal>r</literal></secondary>"

msgid "reading (symbolized by <literal>r</literal> as in “read”);"
msgstr "lesing (symbolisert med <literal>r</literal> som i «read»);"

msgid "<primary>permissions</primary><secondary><literal>w</literal></secondary>"
msgstr "<primary>tilganger</primary><secondary><literal>w</literal></secondary>"

msgid "writing (or modifying, symbolized by <literal>w</literal> as in “write”);"
msgstr "skrive (eller modifisere, symbolisert ved <literal>w</literal> som i «write»);"

msgid "<primary>permissions</primary><secondary><literal>x</literal></secondary>"
msgstr "<primary>tilganger</primary><secondary><literal>x</literal></secondary>"

msgid "executing (symbolized by <literal>x</literal> as in “eXecute”)."
msgstr "utføre (symbolisert med <literal>x</literal> som i «eXecute»)."

msgid "<primary>read, right</primary>"
msgstr "<primary>lese, rettighet</primary>"

msgid "<primary>write, right</primary>"
msgstr "<primary>skrive, rettighet</primary>"

msgid "<primary>modification, right</primary>"
msgstr "<primary>endring, rettighet</primary>"

msgid "<primary>execution, right</primary>"
msgstr "<primary>utføre, rettighet</primary>"

msgid "<primary>permissions</primary><secondary>read</secondary>"
msgstr "<primary>tilganger</primary><secondary>lesing</secondary>"

msgid "<primary>permissions</primary><secondary>write</secondary>"
msgstr "<primary>tilganger</primary><secondary>skriving</secondary>"

msgid "<primary>permissions</primary><secondary>execute</secondary>"
msgstr "<primary>tilganger</primary><secondary>kjøring</secondary>"

msgid "In the case of a file, these rights are easily understood: read access allows reading the content (including copying), write access allows changing it, and execute access allows you to run it (which will only work if it is a program)."
msgstr "Når det gjelder en fil, er disse rettighetene lette å forstå: Lesetilgang tillater å lese innhold (inkludert kopiering), skrivetilgang tillater å endre den, og med kjøretilgang kan du kjøre den (som bare vil fungere hvis den er et program)."

msgid "<emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables"
msgstr "<emphasis>SIKKERHET</emphasis> <literal>setuid</literal>- og <literal>setgid</literal>-programmer"

msgid "<primary>permissions</primary><secondary><literal>setuid</literal></secondary><seealso><literal>setuid</literal></seealso>"
msgstr "<primary>tilganger</primary><secondary><literal>setuid</literal></secondary><seealso><literal>setuid</literal></seealso>"

msgid "<primary>permissions</primary><secondary><literal>setgid</literal></secondary><seealso><literal>setgid</literal></seealso>"
msgstr "<primary>tilganger</primary><secondary><literal>setgid</literal></secondary><seealso><literal>setgid</literal></seealso>"

msgid "<primary>permissions</primary><secondary><literal>s</literal></secondary>"
msgstr "<primary>tilganger</primary><secondary><literal>s</literal></secondary>"

msgid "Two particular rights are relevant to executable files: <literal>setuid</literal> and <literal>setgid</literal> (symbolized with the letter “s”). Note that we frequently speak of “bit”, since each of these Boolean values can be represented by a 0 or a 1. These two rights allow any user to execute the program with the rights of its owner or its group, respectively. This mechanism grants access to features requiring higher level permissions than those you would usually have."
msgstr "To spesielle rettigheter er relevante for kjørbare filer:<literal>setuid</literal> og <literal>setgid</literal> (symbolisert med bokstaven «s»). Merk at vi ofte snakker om «bit», siden hver av disse Boolske verdiene kan representeres ved en 0 eller et 1. Disse to rettighetene tillater alle brukere å kjøre programmet med henholdsvis rettighetene dets eier eller gruppe. Denne mekanismen gir tilgang til funksjoner som krever tilganger på et høyere nivå enn du vanligvis har."

msgid "<primary><literal>setuid</literal>, right</primary>"
msgstr "<primary><literal>setuid</literal>, rettighet</primary>"

msgid "<primary><literal>setgid</literal>, right</primary>"
msgstr "<primary><literal>setgid</literal>, rettighet</primary>"

msgid "Since a <literal>setuid</literal> root program is systematically run under the super-user identity, it is very important to ensure it is secure and reliable. Indeed, a user who would manage to subvert it to call a command of their choice could then impersonate the root user and have all rights on the system."
msgstr "Ettersom et <literal>setuid</literal>-root-program systematisk kjøres under superbruker-identiteten, er det svært viktig å sikre at det er trygt og pålitelig. Faktisk, skulle en bruker klare å forbigå (undergrave) det for å bruke en kommando etter eget valg, kunne denne brukeren utgi seg for å være root-bruker, og få alle rettigheter til systemet."

msgid "<primary><command>su</command></primary>"
msgstr "<primary><command>su</command></primary>"

msgid "<primary><command>sudo</command></primary>"
msgstr "<primary><command>sudo</command></primary>"

msgid "<primary><command>runuser</command></primary>"
msgstr "<primary><command>runuser</command></primary>"

msgid "If you require running a program under a different user or if a program requires higher permissions, the <command>sudo</command>, <command>su</command>, or <command>runuser</command> commands are usually better choices than using these bits (see <xref linkend=\"sect.sharing-admin-rights\" />)."
msgstr "Hvis du må kjøre et program som en annen bruker eller hvis et program krever høyere tilganger, er <command>sudo</command>, <command>su</command>, eller <command>runuser</command>-kommandoene vanligvis bedre valg enn å bruke disse bit-ene (sjekk <xref linkend=\"sect.sharing-admin-rights\" />)."

msgid "A directory is handled differently. Read access gives the right to consult the list of its entries (files and directories), write access allows creating or deleting files, and execute access allows crossing through it (especially to go there with the <command>cd</command> command). Being able to cross through a directory without being able to read it gives permission to access the entries therein that are known by name, but not to find them if you do not know their existence or their exact name."
msgstr "En katalog håndteres annerledes. Lesetilgang gir rett til å gjennomgå listen over oppføringene (filer og kataloger), skrivetilgang tillater å lage eller slette filer, og utføringstilgang tillater å krysse gjennom den (spesielt å gå dit med <command>cd</command>-kommandoen). Å kunne krysse gjennom en katalog uten å kunne lese den, gir tillatelse til å gå til de oppføringene som er kjent ved navn, men ikke til å finne dem hvis man ikke vet at de finnes, eller deres nøyaktige navn."

msgid "<emphasis>SECURITY</emphasis> <literal>setgid</literal> directory and <emphasis>sticky bit</emphasis>"
msgstr "<emphasis>SIKKERHET</emphasis> <literal>setgid</literal> katalog og <emphasis>sticky bit</emphasis>"

msgid "<primary><literal>setgid</literal> directory</primary>"
msgstr "<primary><literal>setgid</literal> katalog</primary>"

msgid "The <literal>setgid</literal> bit also applies to directories. Any newly-created item in such directories is automatically assigned the owner group of the parent directory, instead of inheriting the creator's main group as usual. This setup avoids the user having to change its main group (with the <command>newgrp</command> command) when working in a file tree shared between several users of the same dedicated group."
msgstr "<literal>setgid</literal>-biten gjelder også kataloger. Ethvert nyopprettet element i slike kataloger blir automatisk knyttet til eiergruppen til den overordnede katalogen, i stedet for, som vanlig, å arve opphavsmannens (skaperens) hovedgruppe. Med dette oppsettet unngås det at brukeren trenger å endre sin hovedgruppe (med <command>newgrp</command>-kommandoen) når man arbeider i et fil-tre som deles mellom flere brukere i samme dediserte gruppe."

msgid "<primary><command>newgrp</command></primary>"
msgstr "<primary><command>newgrp</command></primary>"

msgid "<primary>sticky bit</primary>"
msgstr "<primary>sticky/«klebrige» bit</primary>"

msgid "<primary>permissions</primary><secondary><literal>t</literal></secondary>"
msgstr "<primary>tilganger</primary><secondary><literal>t</literal></secondary>"

msgid "The “sticky” bit (symbolized by the letter “t”) is a permission that is only useful in directories. It is especially used for temporary directories where everybody has write access (such as <filename>/tmp/</filename>): it restricts deletion of files so that only their owner (or the owner of the parent directory) can do it. Lacking this, everyone could delete other users' files in <filename>/tmp/</filename>."
msgstr "«Sticky bit» - den «klebrige» bit-en - (symbolisert med bokstaven «t») er en tillatelse som bare er nyttig i kataloger. Det blir spesielt brukt for midlertidige kataloger, der alle har skrivetilgang (for eksempel <filename>/tmp/</filename>): Bit-en begrenser slettingen av filer slik at bare fileieren (eller eieren av den overordnede katalogen) kan gjøre det. Mangler denne, kan alle slette andre brukeres filer i <filename>/tmp/</filename>."

msgid "Three commands control the permissions associated with a file:"
msgstr "Tre kommandoer kontrollerer tillatelser knyttet til en fil:"

msgid "<primary><command>chown</command></primary>"
msgstr "<primary><command>chown</command></primary>"

msgid "<command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command> changes the owner of the file;"
msgstr "<command>chown <replaceable>bruker</replaceable> <replaceable>fil</replaceable></command> endrer eieren av filen;"

msgid "<primary><command>chgrp</command></primary>"
msgstr "<primary><command>chgrp</command></primary>"

msgid "<command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command> alters the owner group;"
msgstr "<command>chgrp <replaceable>gruppe</replaceable> <replaceable>fil</replaceable></command> endrer eiergruppen;"

msgid "<primary><command>chmod</command></primary>"
msgstr "<primary><command>chmod</command></primary>"

msgid "<command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command> changes the permissions for the file."
msgstr "<command>chmod <replaceable>rettigheter</replaceable> <replaceable>fil</replaceable></command> endrer tillatelsene for filen."

msgid "<primary>symbolic representation of rights</primary>"
msgstr "<primary>symbolsk representasjon av rettigheter</primary>"

msgid "<primary>rights</primary><secondary>symbolic representation</secondary>"
msgstr "<primary>rettigheter</primary><secondary>symbolsk representasjon</secondary>"

msgid "<primary>permissions</primary><secondary>symbolic representation</secondary>"
msgstr "<primary>tilganger</primary><secondary>symbolsk representasjon</secondary>"

msgid "There are two ways of presenting rights. Among them, the symbolic representation is probably the easiest to understand and remember. It involves the letter symbols mentioned above. You can define rights for each category of users (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), by setting them explicitly (with <literal>=</literal>), by adding (<literal>+</literal>), or subtracting (<literal>-</literal>). Thus the <literal>u=rwx,g+rw,o-r</literal> formula gives the owner read, write, and execute rights, adds read and write rights for the owner group, and removes read rights for other users. Rights not altered by the addition or subtraction in such a command remain unmodified. The letter <literal>a</literal>, for “all”, covers all three categories of users, so that <literal>a=rx</literal> grants all three categories the same rights (read and execute, but not write)."
msgstr "Det er to måter å presentere rettighetene på. Blant dem er den symbolske representasjon trolig den enkleste å forstå og huske. Det innebærer bokstavsymboler som nevnt ovenfor. Du kan definere rettigheter for hver kategori av brukere (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), ved å sette dem eksplisitt (ved <literal>=</literal>), ved å legge til (<literal>+</literal>), eller trekke fra (<literal>-</literal>). Dermed gir <literal>u=rwx,g+rw,o-r</literal>-formelen eieren lese-, skrive-, og utføringsrettigheter, legger til lese- og skriverettigheter for eiergruppen, og fjerner leserettigheter for andre brukere. Rettigheter som ikke er endret ved å legge til eller fjerne i en slik kommando, forblir uendret. Bokstaven <literal>a</literal>, for «alle», dekker alle tre kategorier brukere, slik at <literal>a=rx</literal> gir alle tre kategorier de samme rettigheter (lese og kjøre, men ikke skrive)."

msgid "<primary>octal representation of rights</primary>"
msgstr "<primary>oktal representasjon av rettigheter</primary>"

msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgstr "<primary>rettigheter</primary><secondary>oktal representasjon</secondary>"

msgid "<primary>permissions</primary><secondary>octal representation</secondary>"
msgstr "<primary>tilganger</primary><secondary>oktal representasjon</secondary>"

msgid "The (octal) numeric representation associates each right with a value: 4 for read, 2 for write, and 1 for execute. We associate each combination of rights with the sum of the figures. Each value is then assigned to different categories of users by putting them end to end in the usual order (owner, group, others)."
msgstr "Den (åttetalls-) numeriske representasjonen forbinder hver rettighet med en verdi: 4 for lese-, 2 for skrive, og 1 for å utføre. Vi forbinder hver kombinasjon av rettigheter med summen av tallene. Hver verdi blir deretter knyttet til ulike kategorier av brukere ved å sette dem side ved side (end to end)i den vanlige rekkefølgen (eier, gruppe, andre)."

msgid "For instance, the <command>chmod 754 <replaceable>file</replaceable></command> command will set the following rights: read, write and execute for the owner (since 7 = 4 + 2 + 1); read and execute for the group (since 5 = 4 + 1); read-only for others. The <literal>0</literal> (zero) means no rights; thus <command>chmod 600 <replaceable>file</replaceable></command> allows for read/write rights for the owner, and no rights for anyone else. The most frequent right combinations are <literal>755</literal> for executable files and directories, and <literal>644</literal> for data files."
msgstr "For eksempel <command>chmod 754 <replaceable>fil</replaceable></command>-kommandoen vil gi de følgende rettigheter: lese, skrive og utføre for eieren (fordi 7 = 4 + 2 + 1); lese og utføre for gruppen (fordi 5 = 4 + 1); bare lese for andre. <literal>0</literal> (zero) betyr ingen rettigheter; da <command>chmod 600 <replaceable>fil</replaceable></command> tillater lese/skrive-rettigheter for eieren, og ingen rettigheter for noen andre. De hyppigste rettighetskombinasjonene er <literal>755</literal> for kjørbare filer og kataloger, og <literal>644</literal> for datafiler."

msgid "<primary><literal>setuid</literal></primary>"
msgstr "<primary><literal>setuid</literal></primary>"

msgid "<primary><literal>setgid</literal></primary>"
msgstr "<primary><literal>setgid</literal></primary>"

msgid "To represent special rights, you can prefix a fourth digit to this number according to the same principle, where the <literal>setuid</literal>, <literal>setgid</literal> and <literal>sticky</literal> bits are 4, 2 and 1, respectively. <command>chmod 4754</command> will associate the <literal>setuid</literal> bit with the previously described rights."
msgstr "For å representere spesielle rettigheter kan du stille et fjerde siffer foran dette tallet etter samme prinsipp, der <literal>setuid</literal>, <literal>setgid</literal> og <literal>sticky</literal>-bitene er henholdsvis 4, 2 og 1. <command>chmod 4754</command> vil knytte <literal>setuid</literal>-biten til den tidligere beskrevne rettigheten."

msgid "Note that the use of octal notation only allows to set all the rights at once on a file; you cannot use it to simply add a new right, such as read access for the group owner, since you must take into account the existing rights and compute the new corresponding numerical value."
msgstr "Merk at bruk av åttetallsystemet bare tillater å sette alle rettigheter samtidig i en fil; du kan ikke bruke den til å bare legge til en ny rett, slik som lesetilgang for gruppens eier, siden du må ta hensyn til eksisterende rettigheter, og beregne ny tilsvarende tallverdi."

msgid "<emphasis>TIP</emphasis> Recursive operation"
msgstr "<emphasis>TIPS</emphasis> Gjentatte operasjoner"

msgid "<primary>permissions</primary><secondary>recursive operation</secondary>"
msgstr "<primary>tilganger</primary><secondary>rekursiv operasjon</secondary>"

msgid "Sometimes we have to change rights for an entire file tree. All the commands above have a <literal>-R</literal> option to operate recursively in sub-directories."
msgstr "Noen ganger må vi endre rettighetene for et helt fil-tre. Alle kommandoene ovenfor har en <literal>-R</literal>-mulighet til å operere gjentakende (rekursivt) i underkataloger."

msgid "<primary>permissions</primary><secondary><literal>X</literal></secondary>"
msgstr "<primary>tilganger</primary><secondary><literal>X</literal></secondary>"

#, fuzzy
#| msgid "The distinction between directories and files sometimes causes problems with recursive operations. That is why the “X” letter has been introduced in the symbolic representation of rights. It represents a right to execute which applies only to directories (and not to files lacking this right). Thus, <command>chmod -R a+X <replaceable>directory</replaceable></command> will only add execute rights for all categories of users (<literal>a</literal>) for all of the sub-directories and files for which at least one category of user (even if their sole owner) already has execute rights."
msgid "The distinction between directories and files sometimes causes problems with recursive operations. That is why the “<literal>X</literal>” letter has been introduced in the symbolic representation of rights. It also represents the right to execute, but it applies differently to directories and files."
msgstr "Skillet mellom kataloger og filer fører noen ganger til problemer med rekursive operasjoner. Det er derfor «<literal>X</literal>»-bokstaven har blitt introdusert i den symbolske representasjonen over rettigheter. Den representerer også rettigheten til kjøring, men den har kun innvirkning på mappetrær og filer."

msgid "For directories it adds executable permissions to the chosen user(s). For files, it adds the executable bit <emphasis>only</emphasis> if at least one of the users (owner, group, or others) already has executable permissions. Let's demonstrate it, because this bit can be confusing:"
msgstr "For mapper legger det til kjørbare tilganger for de(n) valgte bruker(ene). For filer, legger det til kjørbar bit <emphasis>kun</emphasis> hvis minst én av brukerne (eier, gruppe, eller andre) allerede har kjøringstilganger. Her kommer en demonstrasjon, siden dette kan være forvirrende:"

msgid ""
"<computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rw-r--r-- 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  <computeroutput>$ </computeroutput><userinput>chmod u+X test.txt</userinput>\n"
"  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rw-r--r-- 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  <computeroutput>$ </computeroutput><userinput>chmod o+x test.txt</userinput>\n"
"  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rw-r--r-x 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  <computeroutput>$ </computeroutput><userinput>chmod u+X test.txt</userinput>\n"
"  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rwxr--r-x 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  "
msgstr "<computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n  <computeroutput>-rw-r--r-- 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n  <computeroutput>$ </computeroutput><userinput>chmod u+X test.txt</userinput>\n  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n  <computeroutput>-rw-r--r-- 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n  <computeroutput>$ </computeroutput><userinput>chmod o+x test.txt</userinput>\n  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n  <computeroutput>-rw-r--r-x 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n  <computeroutput>$ </computeroutput><userinput>chmod u+X test.txt</userinput>\n  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n  <computeroutput>-rwxr--r-x 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n  "

#, fuzzy
msgid "The example shows a typical file with its default permissions: its owner can read and write it, the owner's group and all other users can read it. The next operation (<literal>u+X</literal>) won't add executable permissions for the owner of the file, because permissions to execute have not been assigned. The operation has no effect on the file. Next we assign execute rights for \"other\" users and repeat the operation. This time it is successful, because at least one user group already had executable permissions."
msgstr "Eksempelet viser en typisk fil med sine forvalgte tilganger: eieren kan lese og skrive den, eierens gruppe og alle andre brukere kan lese den. Neste operasjon (<literal>u+X</literal>) legger ikke til kjørbar tilgang for eier av filen, fordi tilganger til å kjøre ikke har blitt tildelt. Operasjonen har ingen effekt på filen. Deretter tildeler vi kjøringsrettigheter for «andre» brukere og gjentar operasjonen. Denne gangen lykkes det, fordi minst én brukergruppe allerede har kjøringstilganger."

#, fuzzy
msgid "It is a misconception that this bit will only affect directories. If files and directories have mixed permissions, it is often a good idea to use the <command>find</command> command to locate the targets you want to operate on."
msgstr "Det er en misforståelse at bit-et kun har innvirkning på mapper. Hvis filer og mapper har blandede tilganger er det ofte en god idé å bruke <command>find</command>-kommandoen for å finne målene du vil utføre endringer på."

msgid "<emphasis>TIP</emphasis> Changing the user and group together"
msgstr "<emphasis>TIPS</emphasis> Endring av bruker og gruppering"

msgid "Frequently you want to change the group of a file at the same time that you change the owner. The <command>chown</command> command has a special syntax for that: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>. This syntax can also be used to recursively (<literal>-R</literal>) change the ownership of a whole directory."
msgstr "Ofte vil du ønske å endre filgruppen samtidig som du endrer eier. <command>chown</command>-kommandoen har en egen syntaks for det: <command>chown <replaceable>bruker</replaceable>:<replaceable>gruppe</replaceable> <replaceable>fil</replaceable></command>. Denne notasjonen kan også brukes for å rekursivt (<literal>-R</literal>) endre eierskap for hele katalogtrær."

msgid "<emphasis>GOING FURTHER</emphasis> <command>umask</command>"
msgstr "<emphasis>FOR VIDEREKOMMENDE</emphasis> <command>umask</command>"

msgid "<primary><command>umask</command></primary>"
msgstr "<primary><command>umask</command></primary>"

msgid "When an application creates a file, it assigns indicative permissions, knowing that the system automatically removes certain rights, given by the command <command>umask</command>. Enter <command>umask</command> in a shell; you will see a mask such as <computeroutput>0022</computeroutput>. This is simply an octal representation of the rights to be systematically removed. In this case, the write right for the group and other users: With the above umask value, the default for directories <literal>777</literal> becomes <literal>755</literal> and the default permissions for files <literal>666</literal> become <literal>644</literal>."
msgstr "Når et program oppretter en fil, tildeler det indikative tillatelser, vel vitende om at systemet fjerner visse rettigheter, gitt av kommandoen <command>umask</command>. Skriv inn <command>umask</command> i et skall; og du vil se en maske slik som <computeroutput>0022</computeroutput>. Dette er rett og slett en åttetalls representasjon av rettighetene som systematisk skal fjernes (i dette tilfellet, skriverettigheten for gruppen og andre brukere: Med umask-verdien ovenfor blir forvalget for katalogene som er <literal>777</literal> til <literal>755</literal> og forvalgte tilganger for filer som er <literal>666</literal> blir <literal>644</literal>."

msgid "<primary>rights</primary><secondary>mask</secondary>"
msgstr "<primary>rettigheter</primary><secondary>maske</secondary>"

msgid "<primary>permissions</primary><secondary>umask</secondary>"
msgstr "<primary>tilganger</primary><secondary>umask</secondary>"

msgid "<primary>mask</primary><secondary>rights mask</secondary>"
msgstr "<primary>maske</primary><secondary>rettighetsmaske</secondary>"

msgid "The system's default value is handled by <citerefentry><refentrytitle>pam_umask</refentrytitle> <manvolnum>8</manvolnum></citerefentry> and <filename>/etc/login.defs</filename>."
msgstr "Systemets forvalgsverdi håndteres av <citerefentry><refentrytitle>pam_umask</refentrytitle> <manvolnum>8</manvolnum></citerefentry> og <filename>/etc/login.defs</filename>."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/login.defs</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/login.defs</filename></secondary>"

msgid "If you give it a new octal value, the <command>umask</command> command modifies the mask. Used in a shell initialization file (for example, <filename>~/.bashrc</filename> or <filename>~/.profile</filename>), it will effectively change the default mask for your work sessions."
msgstr "Hvis du gir den en ny oktal verdi, endrer <command>umask</command>-kommandoen masken. Brukt i en skall-initialiseringsfil (for eksempel <filename>~/.bashrc</filename> eller <filename>~/.profile</filename>), vil den effektivt sett endre forvalgt maske for dine arbeidsøkter."

#, fuzzy
msgid "ACLs - Access Control Lists"
msgstr "ACL-er - Tilgangskontroll-lister"

msgid "<primary>ACL</primary>"
msgstr "<primary>ACL</primary>"

msgid "<primary>Access Control List</primary><see>ACL</see>"
msgstr "<primary>Tilgangskontrollister (Access Control List)</primary><see>ACL</see>"

msgid "<primary><emphasis role=\"pkg\">acl</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">acl</emphasis></primary>"

msgid "Many filesystems, e.g. Btrfs, Ext3, Ext4, JFS, XFS, etc., support the use of Access Control Lists (ACLs). These extend the basic features of file ownership and permission, described in the previous section, and allow for a more fine-grained control of each (file) object. For example: A user wants to share a file with another user and that user should only be able to read the file, but not write or change it."
msgstr "Mange filsystemer, f.eks. Btrfs, Ext3, Ext4, JFS, XFS, osv. støtter bruk av tilgangskontroll-lister (ACL-er). Disse utvider grunnleggende funksjoner for eierskap og tilganger (beskrevet i den forrige delen) og tillater mer finmasket kontroll over hvert objekt (fil). F.eks. Hvis en bruker ønsker å dele en fil med en annen og den brukeren kun skal kunne lese filen, men ikke skrive eller endre den."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/fstab</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/fstab</filename></secondary>"

msgid "<primary>ACL</primary><secondary><literal>acl</literal></secondary>"
msgstr "<primary>ACL</primary><secondary><literal>acl</literal></secondary>"

msgid "<primary>ACL</primary><secondary><literal>noacl</literal></secondary>"
msgstr "<primary>ACL</primary><secondary><literal>noacl</literal></secondary>"

msgid "For some of the filesystems, the usage of ACLs is enabled by default (e.g. Btrfs, Ext3, Ext4). For other filesystems or older systems it must be enabled using the <literal>acl</literal> mount option - either in the <command>mount</command> command directly or in <filename>/etc/fstab</filename>. In the same way the usage of ACLs can be disabled by using the <literal>noacl</literal> mount option. For Ext* filesystems one can also use the <command>tune2fs -o [no]acl /dev/<replaceable>device</replaceable></command> command to enable/disable the usage of ACLs by default. The default values for each filesystem can usually be found in their homonym manual pages in section 5 (<citerefentry><refentrytitle><replaceable>filesystem</replaceable></refentrytitle> <manvolnum>5</manvolnum></citerefentry>) or in <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry>."
msgstr "For noen filsystemer er bruk av ACL-er påskrudd som forvalg (f.eks. Btrfs, Ext3, Ext4). For andre filsystemer eller eldre systemer må det skrus på ved bruk av <literal>acl</literal>-monteringsvalg. Enten i <command>mount</command>-kommandoen direkte, eller i <filename>/etc/fstab</filename>. På samme vis kan bruk av ACL-er skrus av ved bruk av <literal>noacl</literal>-monteringsvalget. For Ext*-filsystemer kan man også bruke <command>tune2fs -o [no]acl /dev/<replaceable>enhet</replaceable></command>-kommandoen for å skru av/på bruk av ACL-er som forvalg. De forvalgte verdiene for hvert filsystem er vanligvis å finne i deres homonym-manualsider i del 5 (<citerefentry><refentrytitle><replaceable>filsystem</replaceable></refentrytitle> <manvolnum>5</manvolnum></citerefentry>) eller i <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry>."

#, fuzzy
msgid "After enabling ACLs, permissions can be set using the <citerefentry><refentrytitle>setfacl</refentrytitle> <manvolnum>1</manvolnum></citerefentry> command, while <citerefentry><refentrytitle>getfacl</refentrytitle> <manvolnum>1</manvolnum></citerefentry> allows one to retrieve the ACLs for a given object or path. These commands are part of the <emphasis role=\"pkg\">acl</emphasis> package. With <command>setfacl</command> one can also configure newly created files or directories to inherit permissions from the parent directory. It is important to note that ACLs are processed in their order and that an earlier entry that fits the situation has precedence over later entries."
msgstr "Etter å ha skrudd på ACL-er, kan tilganger settes ved bruk av <citerefentry><refentrytitle>setfacl</refentrytitle> <manvolnum>1</manvolnum></citerefentry>-kommandoen, mens <citerefentry><refentrytitle>getfacl</refentrytitle> <manvolnum>1</manvolnum></citerefentry> lar en motta ACL-er for et gitt objekt eller sti. Disse kommandoene er en del av <emphasis role=\"pkg\">acl</emphasis>-pakken. Med <command>setfacl</command> kan man også sette opp at nylig opprettede filer eller mapper skal arve tilganger fra overnevnt mappe. Det er viktig å merke seg at ACL-er behandles i rekkefølgen deres, og at en tidligere oppføring som passer situasjonen har rang over senere oppføringer."

msgid "If a file has ACLs set, the output of the <command>ls -l</command> command will show a plus-sign after the traditional permissions. When using ACLs, the <command>chmod</command> command behaves slightly different, and <command>umask</command> might be ignored. The extensive documentation, e.g. <citerefentry><refentrytitle>acl</refentrytitle> <manvolnum>5</manvolnum></citerefentry> contains more information."
msgstr "Hvis en fil har ACL-er satt, vil utdata for <command>ls -l</command>-kommandoen vise et pluss-tegn etter de tradisjonelle tilgangene. Ved bruk av ACL-er oppfører <command>chmod</command> seg litt annerledes, og det kan hende at <command>umask</command> blir ignorert. Den detaljrike dokumentasjonen, f.eks. <citerefentry><refentrytitle>acl</refentrytitle> <manvolnum>5</manvolnum></citerefentry> har mer info."

msgid "Administration Interfaces"
msgstr "Administrasjonsgrensesnitt"

msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgstr "<primary>grensesnitt</primary><secondary>administrasjonsgrensesnitt</secondary>"

msgid "<primary>administration, interfaces</primary>"
msgstr "<primary>administrasjon, grensesnitt</primary>"

msgid "Using a graphical interface for administration is interesting in various circumstances. An administrator does not necessarily know all the configuration details for all their services, and doesn't always have the time to go seeking out the documentation on the matter. A graphical interface for administration can thus accelerate the deployment of a new service. It can also simplify the setup of services which are hard to configure."
msgstr "Å bruke et grafisk administrasjonsgrensesnitt er interessant i ulike situasjoner. En administrator kjenner ikke nødvendigvis alle oppsettsdetaljer for alle sine tjenester, og har ikke alltid tid til å gå igjennom dokumentasjonen i saken. Et grafisk administrasjonsgrensesnitt kan dermed akselerere utplassering av en ny tjeneste. Det kan også forenkle oppsettet av tjenester som er vanskelige å sette opp."

msgid "Such an interface is only an aid, and not an end in itself. In all cases, the administrator must master its behavior in order to understand and work around any potential problem."
msgstr "Et slikt grensesnitt er bare et hjelpemiddel, og ikke et mål i seg selv. I alle tilfeller må administratoren beherske hvordan det virker for å forstå og løse mulige problemer."

msgid "Since no interface is perfect, you may be tempted to try several solutions. This is to be avoided as much as possible, since different tools are sometimes incompatible in their work methods. Even if they all aim to be very flexible and try to adopt the configuration file as a single reference, they are not always able to integrate external changes."
msgstr "Siden ingen grensesnitt er perfekte, kan du bli fristet til å prøve ulike løsninger. Dette bør så mye som mulig unngås, siden arbeidsmetodikken til ulike verktøy ofte er uforenlige. Selv om alle har som mål å være svært fleksible, og prøve å adoptere oppsettsfilen som en eneste referanse, er de ikke alltid i stand til å integrere eksterne endringer."

msgid "Administrating on a Web Interface: <command>webmin</command>"
msgstr "Å administrere med et nettbrukergrensesnitt: <command>webmin</command>"

msgid "<primary><emphasis>webmin</emphasis></primary>"
msgstr "<primary><emphasis>webmin</emphasis></primary>"

msgid "<primary>administration, interfaces</primary><secondary><emphasis>webmin</emphasis></secondary>"
msgstr "<primary>administrasjon, grensesnitt</primary><secondary><emphasis>webmin</emphasis></secondary>"

msgid "This is, without a doubt, one of the most successful administration interfaces. It is a modular system managed through a web browser, covering a wide array of areas and tools. Furthermore, it is internationalized and available in many languages."
msgstr "Dette er uten tvil et av de mest vellykkede administrasjonsgrensesnittene. Det er et modulsystem styrt gjennom en nettleser, og dekker et bredt spekter av områder og verktøy. Videre er det internasjonalisert, og tilgjengelig på mange språk."

msgid "Webmin dashboard"
msgstr "Webmin-kontrollpanel"

msgid "Sadly, <command>webmin</command> is no longer part of Debian. Its Debian maintainer removed the packages created because they no longer had the time required to maintain them at an acceptable quality level. Nobody has officially taken over, so Debian does not provide the <command>webmin</command> package."
msgstr "Trist nok, er ikke <command>webmin</command> lenger en del av Debian. Debian-vedlikeholderen fjernet pakkene han hadde laget fordi han ikke lenger hadde tid til å vedlikeholde dem på et akseptabelt kvalitetsnivå. Ingen har offisielt tatt over, så Debian har ingen <command>webmin</command>-pakke."

msgid "There is, however, an unofficial package distributed on the <literal>webmin.com</literal> website. Contrary to the original Debian packages, this package is monolithic; all of its configuration modules are installed and activated by default, even if the corresponding service is not installed on the machine."
msgstr "Det er imidlertid en uoffisiell pakke tilgjengelig fra nettsiden <literal>webmin.com</literal>. Til forskjell fra den opprinnelige Debian-pakken, er denne pakken monolittisk; alle oppsettsmodulene installeres og aktiveres som standard, selv om den tilsvarende tjenesten ikke er installert på maskinen."

msgid "<emphasis>SECURITY</emphasis> Changing the root password"
msgstr "<emphasis>SIKKERHET</emphasis> Endre rotpassordet"

#, fuzzy
#| msgid "On the first login, identification is conducted with the root username and its usual password. It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the root password for the server will not be involved, even if this confers important administrative rights to the machine."
msgid "On the first login, identification is conducted with the root username and its usual password (or any user's login credentials which belongs to the <literal>sudo</literal> group). It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the server's user accounts will not be involved, even if this confers important administrative rights to the machine."
msgstr "Ved den første innloggingen blir identifikasjon avklart med root-brukernavnet og tilhørende passord. Det anbefales å endre passordet som brukes for <command>webmin</command> så snart som mulig, slik at hvis det er kompromittert, berøres ikke root-passordet, selv om dette tildeler viktige administrative rettigheter til maskinen."

#, fuzzy
#| msgid "Beware! Since <command>webmin</command> has so many features, a malicious user accessing it could compromise the security of the entire system. In general, interfaces of this kind are not recommended for important systems with strong security constraints (firewall, sensitive servers, etc.)."
msgid "Beware! Since <command>webmin</command> has so many features, a malicious user accessing it could compromise the security of the entire system. In general, interfaces of this kind are not recommended for important systems with strong security constraints (firewall, sensitive servers, etc.), and they are not recommended to be exposed to the public either."
msgstr "Vær forsiktig! Fordi <command>webmin</command> har så mange funksjoner, vil en ondsinnet bruker med tilgang til den kunne kompromittere sikkerheten til hele systemet. Generelt er grensesnitt av denne typen ikke anbefalt for viktige systemer med sterke sikkerhetsbegrensninger (brannmur, sensitive servere, etc.)."

msgid "Webmin is used through a web interface, but it does not require Apache to be installed. Essentially, this software has its own integrated mini web server. This server listens by default on port 10000 and accepts secure HTTP connections."
msgstr "Webmin brukes via et nettgrensesnitt, men krever ikke at Apache installeres. I hovedsak har dette programmet sin egen integrerte mini-nettjener. Denne tjeneren lytter som standard på port 10000, og aksepterer sikre HTTP-tilkoblinger."

msgid "Included modules cover a wide variety of services, among which:"
msgstr "De inkluderte moduler dekker et bredt spekter av tjenester, blant disse er:"

msgid "all base services: creation of users and groups, management of <filename>crontab</filename> files, service scripts/files, viewing of logs, etc."
msgstr "alle basistjenester: oppretting av brukere og grupper, håndtering av <filename>crontab</filename>-filer, tjenesteskript/filer, visning av logger, osv."

msgid "bind: DNS server configuration (name service);"
msgstr "bind: DNS tjeneroppsett (navntjeneste);"

msgid "postfix: SMTP server configuration (e-mail);"
msgstr "postfix: SMTP-tjeneroppsett (e-post);"

msgid "network services: configuration of the <command>xinetd</command> super-server;"
msgstr "nettverkstjenester: oppsett av <command>xinetd</command>-supertjener;"

msgid "disk quota: user quota management;"
msgstr "diskkvote: brukerkvotehåndtering;"

msgid "dhcpd: DHCP server configuration;"
msgstr "dhcpd: DHCP-tjeneroppsett;"

msgid "proftpd: FTP server configuration;"
msgstr "proftpd: FTP-tjeneroppsett;"

msgid "samba: Samba file server configuration;"
msgstr "samba: Samba filtjeneroppsett;"

msgid "software: installation or removal of software from Debian packages and system updates."
msgstr "software: Installasjon eller fjerning av programvare fra Debian-pakker og systemoppdateringer ."

msgid "The administration interface is available in a web browser at <literal>https://localhost:10000</literal>. Beware! Not all the modules are directly usable. Sometimes they must be configured by specifying the locations of the corresponding configuration files and some executable files (program). Frequently the system will politely prompt you when it fails to activate a requested module."
msgstr "Administrasjonsgrensesnittet er tilgjengelig i en nettleser på <literal>https://localhost:10000</literal>. Pass opp! Ikke alle modulene kan brukes direkte. Noen ganger må de settes opp ved å angi plasseringen av de tilhørende oppsettsfiler og noen kjørbare filer (programmer). Ofte vil systemet høflig stille deg spørsmål når det ikke klarer å aktivere den modulen det er bedt om."

msgid "<emphasis>ALTERNATIVE</emphasis> GNOME control center"
msgstr "<emphasis>ALTERNATIV</emphasis> GNOME kontrollsenter"

msgid "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"

msgid "The GNOME project also provides multiple administration interfaces that are usually accessible via the “Settings” entry in the user menu on the top right. <command>gnome-control-center</command> is the main program that brings them all together but many of the system wide configuration tools are effectively provided by other packages (<emphasis role=\"pkg\">accountsservice</emphasis>, <emphasis role=\"pkg\">system-config-printer</emphasis>, etc.). Although they are easy to use, these applications cover only a limited number of base services: user management, time configuration, network configuration, printer configuration, and so on."
msgstr "GNOME-prosjektet gir også flere administrasjonsgrensesnitt som vanligvis er tilgjengelig via «Innstillinger»-elementet i brukermenyen øverst til høyre. <command>gnome-control-center</command> er hovedprogrammet som bringer dem alle sammen, men mange av de brede systemomfattende oppsettsverktøy er effektivt levert av andre pakker (<emphasis role=\"pkg\">accountsservice</emphasis>, <emphasis role=\"pkg\">system-config-printer</emphasis>, etc.). Selv om de er enkle å bruke, dekker disse programmene kun et begrenset antall basetjenester: Brukeradministrasjon, tidsoppsett, nettverksoppsett, skriveroppsett, og så videre."

msgid "Configuring Packages: <command>debconf</command>"
msgstr "Oppsett av pakker: <command>debconf</command>"

msgid "<primary><command>debconf</command></primary><seealso><command>dpkg-reconfigure</command></seealso>"
msgstr "<primary><command>debconf</command></primary><seealso><command>dpkg-reconfigure</command></seealso>"

msgid "<primary><command>dpkg-reconfigure</command></primary><seealso><command>debconf</command></seealso>"
msgstr "<primary><command>dpkg-reconfigure</command></primary><seealso><command>debconf</command></seealso>"

msgid "Many packages are automatically configured after asking a few questions during installation through the Debconf tool. These packages can be reconfigured by running <command>dpkg-reconfigure -p<replaceable>level</replaceable> <replaceable>package</replaceable></command>."
msgstr "Mange pakker blir automatisk satt opp etter å ha spurt noen spørsmål under installasjon via Debconf-verktøyet. Disse pakkene kan settes opp ved å kjøre <command>dpkg-reconfigure -p<replaceable>level</replaceable><replaceable>pakke</replaceable></command>."

msgid "For most cases, these settings are very simple; only a few important variables in the configuration file are changed. These variables are often grouped between two “demarcation” lines so that reconfiguration of the package only impacts the enclosed area. In other cases, reconfiguration will not change anything if the script detects a manual modification of the configuration file, in order to preserve these human interventions (because the script can't ensure that its own modifications will not disrupt the existing settings)."
msgstr "I de fleste tilfeller er disse innstillingene veldig enkle; bare noen få viktige variabler i oppsettsfilen er endret. Disse variablene er ofte gruppert mellom to «avgrensnings»-linjer slik at nytt oppsett av pakken bare påvirker dette avgrensede området. I andre tilfeller vil ikke et nytt oppsett endre noe om skriptet oppdager en manuell endring i oppsettsfilen, for å kunne bevare disse manuelle inngrepene (fordi skriptet ikke kan sikre at egne tilpasninger ikke vil forstyrre eksisterende innstillinger)."

msgid "<emphasis>DEBIAN POLICY</emphasis> Preserving changes"
msgstr "<emphasis>DEBIAN-RETNINGSLINJER</emphasis> Ta vare på endringer"

msgid "<primary>Debian Project</primary><secondary>policy</secondary>"
msgstr "<primary>Debian-prosjekt</primary><secondary>praksis</secondary>"

msgid "<primary>configuration</primary><secondary>files</secondary>"
msgstr "<primary>oppsett</primary><secondary>filer</secondary>"

msgid "The Debian Policy expressly stipulates that everything should be done to preserve manual changes made to a configuration file, so more and more scripts take precautions when editing configuration files. The general principle is simple: the script will only make changes if it knows the status of the configuration file, which is verified by comparing the checksum of the file against that of the last automatically generated file. If they are the same, the script is authorized to change the configuration file. Otherwise, it determines that the file has been changed and asks what action it should take (install the new file, save the old file, or try to integrate the new changes with the existing file). This precautionary principle has long been unique to Debian, but other distributions have gradually begun to embrace it."
msgstr "Debian-retningslinjene fastslår uttrykkelig at alt skal gjøres for å bevare manuelle endringer i en oppsettsfil, slik at flere og flere skript tar forholdsregler når du redigerer oppsettsfiler. Det generelle prinsippet er enkelt: Skriptet vil bare gjøre endringer hvis den kjenner statusen til oppsettsfilen, som er bekreftet ved å sammenligne kontrollsummen til filen mot den til den siste automatisk genererte filen. Hvis de er de samme, er skriptet autorisert til å endre oppsettsfilen. Ellers bestemmer det at filen er blitt endret, og spør hvilke tiltak det skal ta (installere den nye filen, lagre den gamle filen, eller prøve å integrere de nye endringene med den eksisterende filen). Dette føre var-prinsippet har lenge vært unikt for Debian, men andre distribusjoner har gradvis begynt å omfavne det."

msgid "<primary><command>ucf</command></primary>"
msgstr "<primary><command>ucf</command></primary>"

msgid "The <command>ucf</command> program (from the Debian package of the same name) can be used to implement such a behavior."
msgstr "Programmet <command>ucf</command> (fra Debian-pakken med samme navn) kan brukes til å få til at det skjer."

msgid "<command>syslog</command> System Events"
msgstr "<command>syslog</command> Systemhendelser"

msgid "<primary><command>rsyslogd</command></primary>"
msgstr "<primary><command>rsyslogd</command></primary>"

msgid "<primary>file</primary><secondary>log file</secondary>"
msgstr "<primary>fil</primary><secondary>loggfil</secondary>"

msgid "<primary>log files</primary><secondary>dispatching</secondary>"
msgstr "<primary>loggfiler</primary><secondary>utsending</secondary>"

msgid "<primary>log files</primary><seealso><filename>/var/log</filename></seealso>"
msgstr "<primary>loggfiler</primary><seealso><filename>/var/log</filename></seealso>"

msgid "Principle and Mechanism"
msgstr "Prinsipp og mekanisme"

msgid "The <command>rsyslogd</command> daemon is responsible for collecting service messages coming from applications and the kernel, then dispatching them into log files (usually stored in the <filename>/var/log/</filename> directory). It obeys the <filename>/etc/rsyslog.conf</filename> configuration file."
msgstr "<command>rsyslogd</command>-bakgrunnsprosessen er ansvarlig for innsamling av servicemeldinger som kommer fra programmer og kjernen, og deretter ekspedere dem til loggfiler (vanligvis lagret i <filename>/var/log/</filename>-mappen). Den adlyder oppsettsfilen <filename>/etc/rsyslog.conf</filename>."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rsyslog.conf</filename></secondary><see><command>rsyslogd</command></see>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rsyslog.conf</filename></secondary><see><command>rsyslogd</command></see>"

msgid "Each log message is associated with an application subsystem (called “facility” in the documentation):"
msgstr "Hver loggmelding er forbundet med en delsystemapplikasjon (kalt «facility» i dokumentasjonen):"

#, fuzzy
#| msgid "<primary><command>rsyslogd</command></primary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>facility</secondary>"
msgstr "<primary><command>rsyslogd</command></primary><secondary>facility</secondary>"

msgid "<literal>auth</literal> and <literal>authpriv</literal>: for authentication;"
msgstr "<literal>auth</literal> og <literal>authpriv</literal>: for autentisering;"

msgid "<literal>cron</literal>: comes from task scheduling services, <command>cron</command> and <command>atd</command>;"
msgstr "<literal>cron</literal>: kommer fra aktivitetsplanleggingstjenester,<command>cron</command> og <command>atd</command>;"

msgid "<literal>daemon</literal>: affects a daemon without any special classification (DNS, NTP, etc.);"
msgstr "<literal>daemon</literal>: påvirker en bakgrunnsprosess uten noen spesiell klassifisering (DNS, NTP, etc.);"

msgid "<literal>ftp</literal>: concerns the FTP server;"
msgstr "<literal>ftp</literal>: gjelder FTP-tjeneren;"

msgid "<literal>kern</literal>: message coming from the kernel;"
msgstr "<literal>kern</literal>: melding kommer fra kjernen;"

msgid "<literal>lpr</literal>: comes from the printing subsystem;"
msgstr "<literal>lpr</literal>: kommer fra skriver-delsystemet;"

msgid "<literal>mail</literal>: comes from the e-mail subsystem;"
msgstr "<literal>mail</literal>: kommer fra e-post-delsystemet (the e-mail-subsystem);"

msgid "<literal>news</literal>: Usenet subsystem message (especially from an NNTP — Network News Transfer Protocol — server that manages newsgroups);"
msgstr "<literal>news</literal>: Usenet delsystem-melding (spesielt fra en NNTP - Network News Transfer Protocol - tjener som styrer nyhetsgrupper);"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>Network News Transfer Protocol</primary><seealso>NNTP</seealso>"
msgstr "<primary>Network News Transfer Protocol</primary><seealso>NNTP</seealso>"

msgid "<literal>syslog</literal>: messages from the <command>syslogd</command> server, itself;"
msgstr "<literal>syslog</literal>: meldinger fra <command>syslogd</command>-tjeneren selv;"

msgid "<literal>user</literal>: user messages (generic);"
msgstr "<literal>user</literal>: brukermeldinger (generisk);"

msgid "<literal>uucp</literal>: messages from the UUCP server (Unix to Unix Copy Program, an old protocol notably used to distribute e-mail messages);"
msgstr "<literal>uucp</literal>: meldinger fra UUCP-tjeneren (Unix til Unix Copy Program, en gammel protokoll som særlig brukes til å distribuere e-postmeldinger);"

msgid "<literal>local0</literal> to <literal>local7</literal>: reserved for local use."
msgstr "<literal>local0</literal> til <literal>local7</literal>: reservert for lokal bruk."

msgid "Each message is also associated with a priority level. Here is the list in decreasing order:"
msgstr "Hver melding er også knyttet til et prioritetsnivå. Her er listen i synkende rekkefølge:"

msgid "<primary><command>rsyslogd</command></primary><secondary>priority</secondary>"
msgstr "<primary><command>rsyslogd</command></primary><secondary>prioritet</secondary>"

msgid "<literal>emerg</literal>: “Help!” There is an emergency, the system is probably unusable."
msgstr "<literal>emerg</literal>: «Hjelp!» Det er krise, systemet er sannsynligvis ubrukelig."

msgid "<literal>alert</literal>: hurry up, any delay can be dangerous, action must be taken immediately;"
msgstr "<literal>alert</literal>: skynd deg, enhver forsinkelse kan være farlig, det må handles umiddelbart;"

msgid "<literal>crit</literal>: conditions are critical;"
msgstr "<literal>crit</literal>: forholdene er kritiske;"

msgid "<literal>err</literal>: error;"
msgstr "<literal>err</literal>: feil;"

msgid "<literal>warn</literal>: warning (potential error);"
msgstr "<literal>warn</literal>: advarsel (mulig fare);"

msgid "<literal>notice</literal>: conditions are normal, but the message is important;"
msgstr "<literal>notice</literal>: forholdene er normale, men budskapet er viktig;"

msgid "<literal>info</literal>: informative message;"
msgstr "<literal>info</literal>: informativt budskap;"

msgid "<literal>debug</literal>: debugging message."
msgstr "<literal>debug</literal>: feilsøkingsbudskap."

msgid "The Configuration File"
msgstr "Oppsettsfilen"

msgid "<primary><command>rsyslogd</command></primary><secondary>configuration</secondary><seealso><filename>/etc/rsyslog.conf</filename></seealso>"
msgstr "<primary><command>rsyslogd</command></primary><secondary>oppsett</secondary><seealso><filename>/etc/rsyslog.conf</filename></seealso>"

msgid "The syntax of the <filename>/etc/rsyslog.conf</filename> file is detailed in the <citerefentry><refentrytitle>rsyslog.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page, but there is also HTML documentation available in the <emphasis role=\"pkg\">rsyslog-doc</emphasis> package (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). The overall principle is to write “selector” and “action” pairs. The selector defines all relevant messages, and the action describes how to deal with them."
msgstr "Syntaksen til <filename>/etc/rsyslog.conf</filename>-filen er beskrevet detaljert i <citerefentry><refentrytitle>rsyslog.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry>-manualsiden, men det er også HTML-dokumentasjon tilgjengelig i <emphasis role=\"pkg\">rsyslog-doc</emphasis>-pakken (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Det gjennomgående prinsippet er å skrive «selector» og «action»-par. «Selector» definerer alle relevante meldinger, og handlingen beskriver hvordan man skal håndtere dem."

msgid "Syntax of the Selector"
msgstr "Syntaksen til velgeren (Selector)"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>selector</secondary>"
msgstr "<primary><command>rsyslogd</command></primary><secondary>selector</secondary>"

msgid "The selector is a semicolon-separated list of <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> pairs (example: <literal>auth.notice;mail.info</literal>). An asterisk may represent all subsystems or all priorities (examples: <literal>*.alert</literal> or <literal>mail.*</literal>). Several subsystems can be grouped, by separating them with a comma (example: <literal>auth,mail.info</literal>). The priority indicated also covers messages of equal or higher priority; thus <literal>auth.alert</literal> indicates the <literal>auth</literal> subsystem messages of <literal>alert</literal> or <literal>emerg</literal> priority. Prefixed with an exclamation point (!), it indicates the opposite, in other words the strictly lower priorities; <literal>auth.!notice</literal>, thus, indicates messages issued from <literal>auth</literal>, with <literal>info</literal> or <literal>debug</literal> priority. Prefixed with an equal sign (=), it corresponds to precisely and only the priority indicated (<literal>auth.=notice</literal> only concerns messages from <literal>auth</literal> with <literal>notice</literal> priority)."
msgstr "Selektoren (velgeren) er en semikolon-delt liste med <literal><replaceable>subsystem</replaceable>.<replaceable>prioritet</replaceable></literal>-par (for eksempel: <literal>auth.notice;mail.info</literal>). En stjerne kan representere alle delsystemer, eller alle prioriteringer (eksempler: <literal>*.alert</literal>, eller <literal>mail.*</literal>). En stjerne kan representere alle delsystemer, eller alle prioriteringer (eksempler: <literal>auth,mail.info</literal>). Den indikerte prioriteten dekker også meldinger med tilsvarende, eller høyere prioritet; på den måten <literal>auth.alert</literal> indikerer <literal>auth</literal> subsystem-meldingene til <literal>alert</literal>, eller <literal>emerg</literal>-prioritet. Prefiks med et utropstegn (!), indikerer det motsatte, med andre ord de strengt tatt lavere prioriteringer; <literal>auth.!notice</literal>, og indikerer dermed meldinger utstedt fra <literal>auth</literal>, med <literal>info</literal> eller <literal>debug</literal>-prioritet. Prefiks med et likhetstegn (=), tilsvarer presist og bare den angitte prioriteten (<literal>auth.=notice</literal>, gjelder bare meldinger fra <literal>auth</literal> med <literal>notice</literal>-prioritet)."

msgid "Each element in the list on the selector overrides previous elements. It is thus possible to restrict a set or to exclude certain elements from it. For example, <literal>kern.info;kern.!err</literal> means messages from the kernel with priority between <literal>info</literal> and <literal>warn</literal>. The <literal>none</literal> priority indicates the empty set (no priorities), and may serve to exclude a subsystem from a set of messages. Thus, <literal>*.crit;kern.none</literal> indicates all the messages of priority equal to or higher than <literal>crit</literal> not coming from the kernel."
msgstr "Hvert element i Selektor-listen overstyrer tidligere elementer. Dermed er det mulig å avgrense et sett, eller å utestenge visse elementer fra den. For eksempel betyr <literal>kern.info;kern.!err</literal> meldinger fra kjernen med prioritet mellom <literal>info</literal> og <literal>warn</literal>. <literal>none</literal>-prioritet indikerer det tomme settet (ingen prioriteringer), og kan tjene til å utelukke et delsystem fra et sett med meldinger. Dermed indikerer <literal>*.crit;kern.none</literal> alle meldingene med prioritet lik eller høyere enn <literal>crit</literal>, som ikke kommer fra kjernen."

msgid "Syntax of Actions"
msgstr "Syntaks for handlinger"

msgid "<primary><command>rsyslogd</command></primary><secondary>action</secondary>"
msgstr "<primary><command>rsyslogd</command></primary><secondary>handling</secondary>"

msgid "<emphasis>BACK TO BASICS</emphasis> The named pipe, a persistent pipe"
msgstr "<emphasis>DET GRUNNLEGGENDE</emphasis> Den navngitte kanalen (named pipe), en vedvarende kanal"

msgid "<primary>named pipe</primary>"
msgstr "<primary>navngitt kanal</primary>"

msgid "<primary>pipe</primary><secondary>named pipe</secondary>"
msgstr "<primary>rør</primary><secondary>navngitt rør</secondary>"

msgid "<primary><command>mkfifo</command></primary>"
msgstr "<primary><command>mkfifo</command></primary>"

msgid "A named pipe is a particular type of file that operates like a traditional pipe (the pipe that you make with the “|” symbol on the command line), but via a file. This mechanism has the advantage of being able to relate two unrelated processes. Anything written to a named pipe blocks the process that writes until another process attempts to read the data written. This second process reads the data written by the first, which can then resume execution."
msgstr "En navngitt kanal er en spesiell type fil som virker som en tradisjonell kanal (kanalen som du lager med «|» -symbolet på kommandolinjen), men via en fil. Denne mekanismen har fordelen av å kunne forholde seg til to ikke-relaterte prosesser. Alt som er skrevet til en navngitt kanal blokkerer prosessen som skriver frem til en annen fremgangsmåte forsøker å lese de data som er skrevet. Denne andre prosessen leser de dataene som er skrevet av den første, som så kan gjenoppta kjøringen."

msgid "Such a file is created with the <command>mkfifo</command> command."
msgstr "En slik fil er laget med <command>mkfifo</command>-kommandoen."

msgid "The various possible actions are:"
msgstr "De forskjellige mulige handlinger er:"

msgid "add the message to a file (example: <filename>/var/log/messages</filename>);"
msgstr "å legge til en melding til en fil (eksempel: <filename>/var/log/messages</filename>);"

msgid "send the message to a remote <command>syslog</command> server (example: <literal>@log.falcot.com</literal>);"
msgstr "sende meldingen til en ekstern <command>syslog</command>-tjener (eksempel: <literal>@log.falcot.com</literal>);"

msgid "send the message to an existing named pipe (example: <literal>|/dev/xconsole</literal>);"
msgstr "send meldingen til en eksisterende navngitt kanal (eksempelvis: <literal>|/dev/xconsole</literal>);"

msgid "send the message to one or more users, if they are logged in (example: <literal>root,rhertzog</literal>);"
msgstr "send meldingen til én eller flere brukere, hvis de er innlogget (eksempelvis:<literal>root,rhertzog</literal>);"

msgid "send the message to all logged in users (example: <literal>*</literal>);"
msgstr "send meldingen til alle innloggede brukere (eksempelvis: <literal>*</literal>);"

msgid "write the message in a text console (example: <literal>/dev/tty8</literal>)."
msgstr "skriv meldingen i en tekstkonsoll (eksempelvis: <literal>/dev/tty8</literal>)."

msgid "<emphasis>SECURITY</emphasis> Forwarding logs"
msgstr "<emphasis>SIKKERHET</emphasis> Videresending av logger"

msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgstr "<primary>logg</primary><secondary>videresendelse</secondary>"

msgid "<primary><command>rsyslogd</command></primary><secondary>server</secondary>"
msgstr "<primary><command>rsyslogd</command></primary><secondary>tjener</secondary>"

msgid "It is a good idea to record the most important logs on a separate machine (perhaps dedicated for this purpose), since this will prevent any possible intruder from removing traces of their intrusion (unless, of course, they also compromise this other server). Furthermore, in the event of a major problem (such as a kernel crash), you have the logs available on another machine, which increases your chances of determining the sequence of events that caused the crash."
msgstr "Det er en god idé å spille inn de viktigste loggene på en annen maskin (kanskje avsatt til dette formålet), siden dette vil hindre enhver mulig inntrenger fra å fjerne sporene av inntrengningen deres (med mindre, selvfølgelig, de også kompromitterer denne andre tjeneren). Videre har du, ved et stort problem (for eksempel et kjernekrasj), logger tilgjengelig på en annen maskin, noe som øker dine sjanser til å bestemme rekkefølgen av hendelser som forårsaket ulykken."

msgid "To accept log messages sent by other machines, you must reconfigure <emphasis>rsyslog</emphasis>: in practice, it is sufficient to activate the ready-for-use entries in <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> and <literal>$UDPServerRun 514</literal>)."
msgstr "For å godta loggmeldinger sendt fra andre maskiner må du sette opp <emphasis>rsyslog</emphasis>: I praksis, er det tilstrekkelig å aktivere de ferdig-til-bruk oppføringene i <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> og <literal>$UDPServerRun 514</literal>)."

msgid "The <command>inetd</command> Super-Server"
msgstr "Super-server <command>inetd</command>"

msgid "Inetd (often called “Internet super-server”) is a server of servers. It executes rarely used servers on demand, so that they do not have to run continuously."
msgstr "Inetd (ofte kalt «Internet super-server») er en tjener for tjenere. Den kjører tjenere som sjeldent blir brukt, etter behov, slik at de slipper å kjøre kontinuerlig."

msgid "<primary><command>inetd</command></primary><seealso>super-server</seealso>"
msgstr "<primary><command>inetd</command></primary><seealso>super-tjener</seealso>"

msgid "<primary>super-server</primary>"
msgstr "<primary>super-server (super-tjener)</primary>"

msgid "The <filename>/etc/inetd.conf</filename> file lists these servers and their usual ports. The <command>inetd</command> command listens to all of them; when it detects a connection to any such port, it executes the corresponding server program."
msgstr "<filename>/etc/inetd.conf</filename>-filen lister disse tjenerne og deres vanlige porter. Kommandoen <command>inetd</command> lytter til dem alle; Når den oppdager en forbindelse til en slik port, kjører den det tjenesteprogrammet som hører til."

msgid "<emphasis>DEBIAN POLICY</emphasis> Register a server in <filename>/etc/inetd.conf</filename>"
msgstr "<emphasis>DEBIAN-RETNINGSLINJER</emphasis> Registrering av tjener i <filename>/etc/inetd.conf</filename>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/inetd.conf</filename></secondary><see><command>inetd</command></see>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/inetd.conf</filename></secondary><see><command>inetd</command></see>"

msgid "<primary><command>update-inetd</command></primary><seealso>super-server</seealso>"
msgstr "<primary><command>update-inetd</command></primary><seealso>super-tjener</seealso>"

msgid "<primary>super-server</primary><secondary>register new server</secondary><seealso><command>update-inetd</command></seealso>"
msgstr "<primary>super-tjener</primary><secondary>registrering av ny tjener</secondary><seealso><command>update-inetd</command></seealso>"

msgid "Packages frequently want to register a new server in the <filename>/etc/inetd.conf</filename> file, but Debian Policy prohibits any package from modifying a configuration file that it doesn't own. This is why the <command>update-inetd</command> script (in the package with the same name) was created: It manages the configuration file, and other packages can thus use it to register a new server to the super-server's configuration."
msgstr "Pakker ønsker ofte å registrere en ny tjener i <filename>/etc/inetd.conf</filename>-filen, men Debian Policy forhindrer alle pakker fra å modifisere en oppsettsfil som den ikke eier. Dette er grunnen til at <command>update-inetd</command>-skriptet (i pakken med samme navn) ble opprettet: Den håndterer oppsettfilen, og andre pakker kan dermed bruke den til å registrere en ny tjener i super-tjenerens oppsett."

msgid "Each significant line of the <filename>/etc/inetd.conf</filename> file describes a server through seven fields (separated by spaces):"
msgstr "Hver viktige linje i <filename>/etc/inetd.conf</filename>-filen beskriver en tjener med syv felt (atskilt med mellomrom):"

msgid "<primary>super-server</primary><secondary>configuration</secondary>"
msgstr "<primary>supertjener</primary><secondary>oppsett</secondary>"

msgid "The TCP or UDP port number, or the service name (which is mapped to a standard port number with the information contained in the <filename>/etc/services</filename> file)."
msgstr "TCP- eller UDP-portnummer, eller tjenestenavnet (som er koblet til et standard portnummer med den informasjonen som finnes i <filename>/etc/services</filename>-filen)."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/services</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/services</filename></secondary>"

msgid "The socket type: <literal>stream</literal> for a TCP connection, <literal>dgram</literal> for UDP datagrams."
msgstr "Type socket: <literal>stream</literal> for en TCP-forbindelse, <literal>dgram</literal> for UDP-datagrammer."

msgid "The protocol: <literal>tcp</literal>, <literal>tcp6</literal>, <literal>udp</literal>, or <literal>udp6</literal>."
msgstr "Protokollen: <literal>tcp</literal>, <literal>tcp6</literal>, <literal>udp</literal>, eller <literal>udp6</literal>."

msgid "The options: two possible values: <literal>wait</literal> or <literal>nowait</literal>, to tell <command>inetd</command> whether it should wait or not for the end of the launched process before accepting another connection. For TCP connections, easily multiplexable, you can usually use <literal>nowait</literal>. For programs responding over UDP, you should use <literal>nowait</literal> only if the server is capable of managing several connections in parallel. You can suffix this field with a period, followed by the maximum number of connections authorized per minute (the default limit is 256)."
msgstr "Valgene: To mulige verdier: <literal>wait</literal> eller <literal>nowait</literal>, for å formidle til <command>inetd</command> om det skal vente eller ikke til slutten av den startede prosessen før du godtar en annen forbindelse. For TCP-forbindelser, enkelt multiplexbare, kan du vanligvis bruke <literal>nowait</literal>. For programmer som svarer over UDP, skal du bruke <literal>nowait</literal> bare hvis tjeneren kan håndtere flere tilkoblinger i parallell. Du kan ende dette feltet med et punktum, fulgt av det maksimale antall forbindelser autorisert pr. minutt (standardgrensen er 256)."

msgid "The user name of the user under whose identity the server will run. Optionally one can add the group too via <literal>user.group</literal> syntax."
msgstr "Brukernavnet til brukeren under den identitet tjeneren skal kjøre. Alternativt kan man legge til gruppen via <literal>user.group</literal>-syntaks også."

msgid "The full path to the server program to execute."
msgstr "Den fullstendige banen til det tjenerprogrammet som skal kjøres."

msgid "The arguments: this is a complete list of the program's arguments, including its own name (<literal>argv[0]</literal> in C)."
msgstr "Argumentene: Dette er en oversikt over programmets argumenter, inkludert dets eget navn (<literal>argv[0]</literal> in C)."

msgid "The following example illustrates some use-cases after installing <emphasis role=\"pkg\">talkd</emphasis>, <emphasis role=\"pkg\">nullidentd</emphasis> (<emphasis role=\"pkg\">ident-server</emphasis>), and <emphasis role=\"pkg\">fingerd</emphasis>:"
msgstr "Følgende eksempler viser noen brukstilfeller etter installering av <emphasis role=\"pkg\">talkd</emphasis>, <emphasis role=\"pkg\">nullidentd</emphasis> (<emphasis role=\"pkg\">ident-server</emphasis>), og <emphasis role=\"pkg\">fingerd</emphasis>:"

msgid "Excerpt from <filename>/etc/inetd.conf</filename>"
msgstr "Utdrag fra <filename>/etc/inetd.conf</filename>"

#, fuzzy
msgid ""
"#:BSD: Shell, login, exec and talk are BSD protocols.\n"
"talk   dgram   udp     wait    nobody.tty   /usr/sbin/in.talkd      in.talkd\n"
"ntalk  dgram   udp     wait    nobody.tty   /usr/sbin/in.ntalkd     in.ntalkd\n"
"\n"
"#:INFO: Info services\n"
"ident  stream  tcp     nowait  nobody       /usr/sbin/nullidentd    nullidentd\n"
"finger stream  tcp     nowait  nobody       /usr/sbin/tcpd          /usr/sbin/in.fingerd"
msgstr "#:BSD: Shell, login, exec og talk er BSD-protokoller.\ntalk   dgram   udp     wait    nobody.tty   /usr/sbin/in.talkd      in.talkd\nntalk  dgram   udp     wait    nobody.tty   /usr/sbin/in.ntalkd     in.ntalkd\n\n#:INFO: Info-tjenester\nident  stream  tcp     nowait  nobody       /usr/sbin/nullidentd    nullidentd\nfinger stream  tcp     nowait  nobody       /usr/sbin/tcpd          /usr/sbin/in.fingerd"

msgid "<primary><command>tcpd</command></primary>"
msgstr "<primary><command>tcpd</command></primary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>super-server</primary><secondary>access limitation</secondary>"
msgstr "<primary>tjenesten</primary><secondary>restart</secondary>"

msgid "The <command>tcpd</command> program is frequently used in the <filename>/etc/inetd.conf</filename> file. It allows limiting incoming connections by applying access control rules, documented in the <citerefentry><refentrytitle>hosts_access</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page, and which are configured in the <filename>/etc/hosts.allow</filename> and <filename>/etc/hosts.deny</filename> files. Once it has been determined that the connection is authorized, <command>tcpd</command> executes the real server (like <command>in.fingerd</command> in our example). It is worth noting that <command>tcpd</command> relies on the name under which it was invoked (that is the first argument, <literal>argv[0]</literal>) to identify the real program to run. So you should not start the arguments list with <literal>tcpd</literal> but with the program that must be wrapped."
msgstr "Programmet <command>tcpd</command> er ofte brukt i <filename>/etc/inetd.conf</filename>-filen. Det lar deg begrense innkommende tilkoblinger ved å bruke regler for adgangskontroll, dokumentert på manualsiden <citerefentry><refentrytitle>hosts_access</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, og som er satt opp i <filename>/etc/hosts.allow</filename> og <filename>/etc/hosts.deny</filename>-filene. Når det er fastslått at tilkoblingen er autorisert, <command>tcpd</command> kjøres den virkelige tjeneren (som <command>in.fingerd</command> i vårt eksempel). Det er ikke verdt noe at <command>tcpd</command> støtter seg til det navnet det ble aktivert med (som er det første argumentet, <literal>argv[0]</literal>) for å identifisere det virkelige programmet som skal kjøres. Så du bør ikke starte argumentslisten med <literal>tcpd</literal>, men med programmet som skal innpakkes."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/hosts.allow</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/hosts.allow</filename></secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/hosts.deny</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/hosts.deny</filename></secondary>"

msgid "<emphasis>COMMUNITY</emphasis> Wietse Venema"
msgstr "<emphasis>FELLESSKAP</emphasis> Wietse Venema"

msgid "<primary>Wietse Venema</primary>"
msgstr "<primary>Wietse Venema</primary>"

msgid "<primary>Venema, Wietse</primary>"
msgstr "<primary>Venema, Wietse</primary>"

#, fuzzy
#| msgid "Wietse Venema, whose expertise in security has made him a renowned programmer, is the author of the <command>tcpd</command> program. He is also the main creator of Postfix, the modular e-mail server (SMTP, Simple Mail Transfer Protocol), designed to be safer and more reliable than <command>sendmail</command>, which features a long history of security vulnerabilities."
msgid "Wietse Venema, whose expertise in security has made him a renowned programmer, is the author of the <command>tcpd</command> program. He is also the main creator of Postfix, the modular e-mail server (SMTP, Simple Mail Transfer Protocol), designed to be safer and more reliable than <command>sendmail</command>, which features a long history of security vulnerabilities. We will have a closer look at this mail server in <xref linkend=\"sect.smtp-mail-server\" />."
msgstr "Wietse Venema, hvis ekspertise innen sikkerhet har gjort ham til en kjent programmerer, er forfatter av <command>tcpd</command>-programmet. Han er også den viktigste skaperen av Postfix, den modulære e-post (SMTP, Simple Mail Transfer Protocol), designet for å være tryggere og mer pålitelig enn <command>sendmail</command>, som har en lang historie med sikkerhetsproblemer."

msgid "<emphasis>ALTERNATIVE</emphasis> Other <command>inetd</command> commands"
msgstr "<emphasis>ALTERNATIV</emphasis> Andre <command>inetd</command>-kommandoer"

msgid "<primary><emphasis role=\"pkg\">inet-superserver</emphasis></primary><seealso>super-user</seealso>"
msgstr "<primary><emphasis role=\"pkg\">inet-superserver</emphasis></primary><seealso>super-tjener</seealso>"

msgid "<primary><emphasis role=\"pkg\">xinetd</emphasis></primary><seealso>super-user</seealso>"
msgstr "<primary><emphasis role=\"pkg\">xinetd</emphasis></primary><seealso>super-tjener</seealso>"

#, fuzzy
#| msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> and <emphasis role=\"pkg\">xinetd</emphasis>."
msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis>, and <emphasis role=\"pkg\">xinetd</emphasis>, which all provide the virtual package <emphasis role=\"pkg\">inet-superserver</emphasis>."
msgstr "Mens Debian installerer <emphasis role=\"pkg\">openbsd-inetd</emphasis> ved oppstart, mangler det ikke alternativer. Vi kan nevne <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> og <emphasis role=\"pkg\">xinetd</emphasis>."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/xinetd.d/</filename></secondary><seealso><command>xinetd</command></seealso>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/xinetd.d/</filename></secondary><seealso><command>xinetd</command></seealso>"

msgid "Most of these alternatives share the same configuration file <filename>/etc/inetd.conf</filename>."
msgstr "De fleste av disse alternativene deler samme oppsettsfil, <filename>/etc/inetd.conf</filename>."

#, fuzzy
#| msgid "This last incarnation of a super-server offers very interesting possibilities. Most notably, its configuration can be split into several files (stored, of course, in the <filename>/etc/xinetd.d/</filename> directory), which can make an administrator's life easier."
msgid "This last incarnation of a super-server however, offers different syntax and very interesting possibilities. Most notably, its configuration can be split into several files (stored, of course, in the <filename>/etc/xinetd.d/</filename> directory), which can make an administrator's life easier. It is considered to be more powerful, but also more complex."
msgstr "Denne siste utgaven av en super-tjener tilbyr svært interessante muligheter. Først og fremst kan oppsettet deles opp i flere filer (lagret, selvfølgelig, i <filename>/etc/xinetd.d/</filename>-mappen), noe som kan gjøre en administrators liv lettere."

msgid "Last but not least, it is even possible to emulate <command>inetd</command>'s behavior with <command>systemd</command>'s socket-activation mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "Sist, men ikke minst, er det også mulig å etterligne <command>inetd</command>s virke med <command>systemd</command>s socket-akiveringsmekanisme (se <xref linkend=\"sect.systemd\" />)."

msgid "Scheduling Tasks with <command>cron</command> and <command>atd</command>"
msgstr "Planlegge oppgaver i tide med <command>cron</command> og <command>atd</command>"

msgid "<primary><command>cron</command></primary>"
msgstr "<primary><command>cron</command></primary>"

msgid "<primary><command>atd</command></primary>"
msgstr "<primary><command>atd</command></primary>"

msgid "<primary>scheduled commands</primary>"
msgstr "<primary>planlagte kommandoer</primary>"

msgid "<primary>command scheduling</primary>"
msgstr "<primary>kommandoplanlegging</primary>"

#, fuzzy
#| msgid "<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every day, every week, etc.); <command>atd</command> is that which deals with commands to be executed a single time, but at a specific moment in the future."
msgid "<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every hour, every day, every week, etc.). <command>atd</command> deals with commands to be executed a single time, but at a specific moment in the future."
msgstr "<command>cron</command> er bakgrunnsprosessen som kjører planlagte og gjentatte kommandoer (hver dag, hver uke, etc.); <command>atd</command> håndterer kommandoer som skal utføres en eneste gang, på et bestemt tidspunkt i fremtiden."

msgid "In a Unix system, many tasks are scheduled for regular execution:"
msgstr "I et Unix-system er mange oppgaver planlagt for regelmessig gjennomføring:"

msgid "rotating the logs;"
msgstr "å rotere loggene;"

msgid "updating the database for the <command>locate</command> program;"
msgstr "å oppdatere databasen for <command>locate</command>-programmet;"

msgid "back-ups;"
msgstr "sikkerhetskopieringer;"

msgid "maintenance scripts (such as cleaning out temporary files)."
msgstr "vedlikeholdsskript (for eksempel opprydding i midlertidige filer)."

msgid "<primary><command>crontab</command></primary>"
msgstr "<primary><command>crontab</command></primary>"

msgid "By default, all users can schedule the execution of tasks. Each user has thus their own <emphasis>crontab</emphasis> in which they can record scheduled commands. It can be edited by running <command>crontab -e</command> (its content is stored in the <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> file)."
msgstr "Som standard kan alle brukere planlegge kjøring av oppgaver. Hver bruker har da sin egen <emphasis>crontab</emphasis>, der de kan legge planlagte kommandoer. Den kan redigeres ved å kjøre <command>crontab -e</command> (innholdet er lagret i <filename>/var/spool/cron/crontabs/<replaceable>bruker</replaceable></filename>-filen)."

msgid "<emphasis>SECURITY</emphasis> Restricting <command>cron</command> or <command>atd</command>"
msgstr "<emphasis>SIKKERHET</emphasis> Begrense <command>cron</command> eller <command>atd</command>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/at.allow</filename></secondary><seealso><command>atd</command></seealso>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/at.allow</filename></secondary><seealso><command>atd</command></seealso>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/at.deny</filename></secondary><seealso><command>atd</command></seealso>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/at.deny</filename></secondary><seealso><command>atd</command></seealso>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.allow</filename></secondary><seealso><command>cron</command></seealso>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.allow</filename></secondary><seealso><command>cron</command></seealso>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.deny</filename></secondary><seealso><command>cron</command></seealso>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.deny</filename></secondary><seealso><command>cron</command></seealso>"

#, fuzzy
#| msgid "You can restrict access to <command>cron</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files."
msgid "You can restrict access to <command>crontab</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files (also described in their manual pages)."
msgstr "Du kan begrense adgangen til <command>cron</command> ved å lage en eksplisitt tillatelsesfil (hviteliste) i <filename>/etc/cron.allow</filename>, der du angir de eneste brukerne med tillatelse til å planlegge kommandoer. Alle andre vil automatisk bli fratatt denne funksjonen. Motsatt, for å bare blokkere én eller to bråkmakere kan du skrive deres brukernavn i en eksplisitt forbudsfil (svarteliste),<filename>/etc/cron.deny</filename>. Denne samme egenskapen er tilgjengelig for <command>atd</command>, med <filename>/etc/at.allow</filename> og <filename>/etc/at.deny</filename>-filene."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/crontab</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/crontab</filename></secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.d/</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.d/</filename></secondary>"

msgid "The root user has their own <emphasis>crontab</emphasis>, but can also use the <filename>/etc/crontab</filename> file, or write additional <emphasis>crontab</emphasis> files in the <filename>/etc/cron.d</filename> directory. These last two solutions have the advantage of being able to specify the user identity to use when executing the command."
msgstr "Rotbrukeren har sine egne <emphasis>crontab</emphasis>, men kan også bruke <filename>/etc/crontab</filename>-filen, eller skrive i tillegg <emphasis>crontab</emphasis>-filer i <filename>/etc/cron.d</filename>-mappen. Disse to siste løsningene har fordelen av å kunne spesifisere brukerens identitet når kommandoen utføres."

msgid "The <emphasis>cron</emphasis> package includes by default some scheduled commands that execute:"
msgstr "Pakken <emphasis>cron</emphasis> inkluderer som standard enkelte planlagte kommandoer som kjører:"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.hourly/</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.hourly/</filename></secondary>"

msgid "programs in the <filename>/etc/cron.hourly/</filename> directory once per hour;"
msgstr "programmer i <filename>/etc/cron.hourly/</filename>-mappen en gang i timen;"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.daily/</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.daily/</filename></secondary>"

msgid "programs in <filename>/etc/cron.daily/</filename> once per day;"
msgstr "programmer i <filename>/etc/cron.daily/</filename> en gang om dagen;"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.weekly/</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.weekly/</filename></secondary>"

msgid "programs in <filename>/etc/cron.weekly/</filename> once per week;"
msgstr "programmer i <filename>/etc/cron.weekly/</filename> en gang per uke;"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.monthly/</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.monthly/</filename></secondary>"

msgid "programs in <filename>/etc/cron.monthly/</filename> once per month."
msgstr "programmer i <filename>/etc/cron.monthly/</filename> en gang per måned."

msgid "Many Debian packages rely on this service: by putting maintenance scripts in these directories, they ensure optimal operation of their services."
msgstr "Mange Debian-pakker er avhengige av denne tjenesten: Ved å sette vedlikeholdsskript i disse katalogene, sikrer de optimal drift av sine tjenester."

msgid "Format of a <filename>crontab</filename> File"
msgstr "Format til en <filename>crontab</filename>-fil"

msgid "<primary><command>crontab</command></primary><secondary><filename>crontab</filename> file format</secondary>"
msgstr "<primary><command>crontab</command></primary><secondary><filename>crontab</filename>-filformat</secondary>"

msgid "<emphasis>TIP</emphasis> Text shortcuts for <command>cron</command>"
msgstr "<emphasis>TIPS</emphasis> Tekstsnarveier for <command>cron</command>"

msgid "<command>cron</command> recognizes some abbreviations which replace the first five fields in a <filename>crontab</filename> entry. They correspond to the most classic scheduling options:"
msgstr "<command>cron</command> gjenkjenner noen forkortelser som erstatter de første fem feltene i en <filename>crontab</filename>-inngang. De svarer til de klassiske planleggingsalternativene:"

msgid "<literal>@yearly</literal>: once per year (January 1, at 00:00);"
msgstr "<literal>@yearly</literal>: en gang i året (1. januar klokken 00:00);"

msgid "<literal>@monthly</literal>: once per month (the 1st of the month, at 00:00);"
msgstr "<literal>@monthly</literal>: en gang per måned (den første i måneden, kl. 00:00);"

msgid "<literal>@weekly</literal>: once per week (Sunday at 00:00);"
msgstr "<literal>@weekly</literal>: en gang i uken (søndag kl 00:00);"

msgid "<literal>@daily</literal>: once per day (at 00:00);"
msgstr "<literal>@daily</literal>: en gang hver dag (kl 00:00);"

msgid "<literal>@hourly</literal>: once per hour (at the beginning of each hour)."
msgstr "<literal>@hourly</literal>: en gang i timen (ved begynnelsen av hver time)."

#, fuzzy
#| msgid "The protocol: <literal>tcp</literal> or <literal>udp</literal>."
msgid "More abbreviations are recognized, like <literal>@reboot</literal>or <literal>@midnight</literal>."
msgstr "Protokollen: <literal>tcp</literal> eller <literal>udp</literal>."

msgid "<emphasis>SPECIAL CASE</emphasis> <command>cron</command> and daylight savings time"
msgstr "<emphasis>KONKRET SAK</emphasis> <command>cron</command> og sommertid"

msgid "In Debian, <command>cron</command> takes the time change (for Daylight Savings Time, or in fact for any significant change in the local time) into account as best as it can. Thus, the commands that should have been executed during an hour that never existed (for example, tasks scheduled at 2:30 am during the Spring time change in France, since at 2:00 am the clock jumps directly to 3:00 am) are executed shortly after the time change (thus around 3:00 am DST). On the other hand, in autumn, when commands would be executed several times (2:30 am DST, then an hour later at 2:30 am standard time, since at 3:00 am DST the clock turns back to 2:00 am) are only executed once."
msgstr "I Debian tar <command>cron</command> hensyn til tidsendringen (for sommertid, eller faktisk for alle vesentlige endringer i lokal tid) som best den kan. Dermed kjøres kommandoene som burde vært utført i løpet av en time som aldri har eksistert (for eksempel oppgaver planlagt til 02:30 under vårens tidsendring i Frankrike, ettersom klokken 02:00 hopper direkte til 03:00) kort tid etter den tidsendringen (altså rundt 03:00 sommertid). På den andre siden, om høsten, når kommandoer ville bli kjørt flere ganger (02:30 sommertid, så en time senere på 02:30 normert tid, så på 03:00 sommertid for klokken går tilbake til 02:00) blir bare kjørt én gang."

msgid "Be careful, however, if the order in which the different scheduled tasks and the delay between their respective executions matters, you should check the compatibility of these constraints with <command>cron</command>'s behavior; if necessary, you can prepare a special schedule for the two problematic nights per year."
msgstr "Vær forsiktig, for hvis rekkefølgen for når de ulike tidfestede oppgavene, og forsinkelsen mellom de respektive kjøringene betyr noe, bør du sjekke kompatibiliteten til disse begrensningene opp mot hvordan <command>cron</command> virker; Hvis det er nødvendig, kan du forberede en spesiell tidsplan for de to årlige, problematiske nettene."

#, fuzzy
#| msgid "Each significant line of a <emphasis>crontab</emphasis> describes a scheduled command with the six (or seven) following fields:"
msgid "Each significant line of a <filename>crontab</filename> entry describes a scheduled command with the six (or seven) following fields:"
msgstr "Hver signifikante linje i en <emphasis>crontab</emphasis> beskriver en planlagt kommando med de seks (eller syv) følgende felter:"

#, fuzzy
#| msgid "the value for the minute (number from 0 to 59);"
msgid "the value for the minute (from 0 to 59);"
msgstr "verdien for minuttet (tall fra 0 til 59);"

msgid "the value for the hour (from 0 to 23);"
msgstr "verdien for timen (nummer 0 til 23);"

msgid "the value for the day of the month (from 1 to 31);"
msgstr "verdien for dagen i måneden (fra 1 til 31);"

msgid "the value for the month (from 1 to 12);"
msgstr "verdien for måneden (fra 1 til 12);"

msgid "the value for the day of the week (from 0 to 7, 1 corresponding to Monday, Sunday being represented by both 0 and 7; it is also possible to use the first three letters of the name of the day of the week in English, such as <literal>Sun</literal>, <literal>Mon</literal>, etc.);"
msgstr "verdien for ukedagen (0-7, 1 tilsvarer mandag, søndag korresponderer med både 0 og 7; Det er også mulig å bruke de tre første bokstavene i navnet på ukedagen på engelsk, som for eksempel <literal>Sun</literal>, <literal>Mon</literal>, etc.);"

msgid "the user name under whose identity the command must be executed (in the <filename>/etc/crontab</filename> file and in the fragments located in <filename>/etc/cron.d/</filename>, but not in the users' own crontab files);"
msgstr "brukernavnet hvis identitet kommandoen må kjøres i (i <filename>/etc/crontab</filename>-filen, og i fragmentene som ligger i <filename>/etc/cron.d/</filename>, men ikke i brukerens egne crontab-filer);"

msgid "the command to execute (when the conditions defined by the first five columns are met)."
msgstr "kommandoen kjøres (når vilkårene som er definert i de fem første kolonnene er oppfylt)."

msgid "All these details are documented in the <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgstr "Alle disse detaljene er dokumentert i manualsiden <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."

#, fuzzy
#| msgid "Each value can be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values."
msgid "Each value can also be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values."
msgstr "Hver verdi kan uttrykkes i form av en liste over mulige verdier (atskilt med kommaer). Syntaksen <literal>a-b</literal> beskriver intervallet for alle verdiene mellom <literal>a</literal> og <literal>b</literal>. Syntaksen <literal>a-b/c</literal> beskriver intervallet med økningen til <literal>c</literal> (eksempel: <literal>0-10/2</literal> betyr <literal>0,2,4,6,8,10</literal>). En asterisk <literal>*</literal> er et jokertegn som representerer alle mulige verdier."

#, fuzzy
#| msgid "Sample <filename>crontab</filename> file"
msgid "Sample user <filename>crontab</filename> file"
msgstr "Eksempelbruker <filename>crontab</filename>-fil"

msgid ""
"#Format\n"
"#min hour day mon dow  command\n"
"\n"
"# Download data every night at 7:25 pm\n"
" 25  19   *   *   *    $HOME/bin/get.pl\n"
"\n"
"# 8:00 am, on weekdays (Monday through Friday)\n"
" 00  08   *   *   1-5  $HOME/bin/dosomething\n"
"\n"
"# every two hours\n"
" *  */2   *   *   *    $HOME/bin/dosomethingelse\n"
"\n"
"# Restart the IRC proxy after each reboot\n"
"@reboot /usr/bin/dircproxy"
msgstr "# Format\n# min time dag måned ukedag kommando\n\n# Last ned data hver natt kl. 19:25\n 25  19   *   *   *    $HOME/bin/get.pl\n\n# 08:00, på ukedager (mandag til fredag)\n 00  08   *   *   1-5  $HOME/bin/gjørnoe\n\n# hver andre time\n *  */2   *   *   *    $HOME/bin/gjørnoeannet\n\n# Start IRC-mellomtjener på nytt etter hver omstart\n@reboot /usr/bin/dircproxy"

msgid "<emphasis>TIP</emphasis> Executing a command on boot"
msgstr "<emphasis>TIPS</emphasis> Kjøre en kommando ved oppstart"

msgid "<primary><command>cron</command></primary><secondary><literal>@reboot</literal></secondary>"
msgstr "<primary><command>cron</command></primary><secondary><literal>@reboot</literal></secondary>"

msgid "To execute a command a single time, just after booting the computer, you can use the <literal>@reboot</literal> macro (a simple restart of <command>cron</command> does not trigger a command scheduled with <literal>@reboot</literal>). This macro replaces the first five fields of an entry in the <emphasis>crontab</emphasis>."
msgstr "For å kjøre en kommando en eneste gang like etter oppstart av datamaskinen, kan du bruke <literal>@reboot</literal> makro (en enkelt omstart av <command>cron</command> utløser ikke en kommando planlagt med <literal>@reboot</literal>). Denne makroen erstatter de første fem feltene i en oppføring i <emphasis>crontab</emphasis>."

msgid "<emphasis>ALTERNATIVE</emphasis> Emulating <command>cron</command> with <command>systemd</command>"
msgstr "<emphasis>ALTERNATIV</emphasis> Å etterligne <command>cron</command> med <command>systemd</command>"

msgid "It is possible to emulate part of <command>cron</command>'s behavior with <command>systemd</command>'s timer mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "Det er mulig å etterligne en del av <command>cron</command>s oppgaver med <command>systemd</command>s timermekanisme (se <xref linkend=\"sect.systemd\" />)."

msgid "Using the <command>at</command> Command"
msgstr "Bruk av <command>at</command>-kommandoen"

msgid "<primary><command>at</command></primary>"
msgstr "<primary><command>at</command></primary>"

msgid "The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.22</literal> thus representing 27 July 2022), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2022-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (i.e., <literal>12/25/22</literal> or <literal>12/25/2022</literal> will be December 25, 2022), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122522</literal> or <literal>12252022</literal> will, likewise, represent December 25, 2022). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory."
msgstr "<command>at</command> utfører en kommando på et angitt tidspunkt i fremtiden. Det tar ønsket tid og dato som kommandolinjeparametere, og kommandoen som skal utføres i sin standard inndata. Kommandoen vil bli utført som om den hadde blitt lagt inn i det gjeldende skallet. <command>at</command> sørger selv for å beholde det aktuelle miljøet, for å reprodusere de samme betingelser når det utfører kommandoen. Tiden er indikert ved å følge de vanlige konvensjonene: <literal>16:12</literal> eller <literal>4:12pm</literal> representerer 4:12 pm. Datoen kan spesifiseres i flere europeiske og vestlige formater, inkludert <literal>DD.MM.YY</literal> (<literal>27.07.22</literal> som da representerer 27 juli 2022), <literal>YYYY-MM-DD</literal> (samme dato blir uttrykt som <literal>2022-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (dvs., <literal>12/25/22</literal> eller <literal>12/25/2022</literal> vil bli 25. desember 25, 2022), eller ganske enkelt <literal>MMDD[CC]YY</literal> (slik at <literal>122522</literal> eller <literal>12252022</literal> vil på samme måte representere Desember 25, 2022 (25. desember 2022). Uten det, vil kommandoen bli utført så snart klokken når tiden som er angitt (samme dag, eller i morgen hvis det tidspunktet allerede er passert på samme dag). Du kan også bare skrive «today» (i dag) eller «tomorrow» (i morgen), som er selvforklarende."

#, fuzzy
#| msgid ""
#| "\n"
#| "<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
#| "<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
#| "<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
#| "<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
#| "<computeroutput>warning: commands will be executed using /bin/sh\n"
#| "job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.22 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 1 at Wed Jul 27 09:00:00 2022</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Ikke glem å gratulere Raphaël med dagen!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"

msgid "An alternative syntax postpones the execution for a given duration: <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command>. The <replaceable>period</replaceable> can be <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal>, or <literal>weeks</literal>. The <replaceable>number</replaceable> simply indicates the number of said units that must elapse before execution of the command."
msgstr "En alternativ syntaks utsetter gjennomføringen med en bestemt varighet: <command>at now + <replaceable>nummer</replaceable> <replaceable>varighet</replaceable></command>. <replaceable>varighet</replaceable> kan være <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal>, eller <literal>weeks</literal>. <replaceable>nummer</replaceable> indikerer rett og slett antallet av de nevnte enheter som må ha passert før kommandoen utføres."

msgid "To cancel a task scheduled by <command>cron</command>, simply run <command>crontab -e</command> and delete the corresponding line in the <emphasis>crontab</emphasis> file. For <command>at</command> tasks, it is almost as easy: run <command>atrm <replaceable>task-number</replaceable></command>. The task number is indicated by the <command>at</command> command when you scheduled it, but you can find it again with the <command>atq</command> command, which gives the current list of scheduled tasks."
msgstr "For å avbryte en tidfestet oppgave med <command>cron</command>, kjør ganske enkelt <command>crontab -e</command>, og slett den tilsvarende linjen i <emphasis>crontab</emphasis>-filen. For <command>at</command>-oppgaver, er det nesten like lett; kjør <command>atrm <replaceable>oppgavenummer</replaceable></command>. Oppgavenummeret er indikert av <command>at</command>-kommandoen når du har tidfestet den, men du kan finne det igjen med <command>atq</command>-kommandoen, som gir den gjeldende listen over tidfestede oppgaver."

msgid "<primary><command>atrm</command></primary>"
msgstr "<primary><command>atrm</command></primary>"

msgid "<primary><command>atq</command></primary>"
msgstr "<primary><command>atq</command></primary>"

msgid "Scheduling Asynchronous Tasks: <command>anacron</command>"
msgstr "Asynkrone oppgaver på timeplanen: <command>anacron</command>"

msgid "<primary><command>anacron</command></primary><seealso><command>cron</command></seealso>"
msgstr "<primary><command>anacron</command></primary><seealso><command>cron</command></seealso>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/anacrontab</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/anacrontab</filename></secondary>"

msgid "<command>anacron</command> is the daemon that completes <command>cron</command> for computers that are not on at all times. Since regular tasks are usually scheduled for the middle of the night, they will never be executed if the computer is off at that time. The purpose of <command>anacron</command> is to execute them, taking into account periods in which the computer is not working."
msgstr "<command>anacron</command> er bakgrunnsprosessen som fullfører <command>cron</command> for datamaskiner som ikke er på hele tiden. Siden vanlige oppgaver vanligvis er planlagt midt på natten, vil de aldri bli kjørt hvis maskinen er slått av på den tiden. Meningen med <command>anacron</command> er å utføre dem, når det tas hensyn til perioder når datamaskinen ikke er på."

msgid "<primary><command>nice</command></primary>"
msgstr "<primary><command>nice</command></primary>"

msgid "Please note that <command>anacron</command> will frequently execute such activity a few minutes after booting the machine, which can render the computer less responsive. This is why the tasks in the <filename>/etc/anacrontab</filename> file are started with the <command>nice</command> command, which reduces their execution priority and thus limits their impact on the rest of the system. Beware, the format of this file is not the same as that of <filename>/etc/crontab</filename>; if you have particular needs for <command>anacron</command>, see the <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page."
msgstr "Noter gjerne at <command>anacron</command> ofte vil utføre slik aktivitet noen få minutter etter oppstart av maskinen, noe som kan gjøre datamaskinen mindre tilgjengelig. Dette er grunnen til at oppgavene i <filename>/etc/anacrontab</filename>-filen er startet med <command>nice</command>-kommandoen, noe som reduserer kjøreprioriteten deres, og dermed begrenser innvirkningen deres på resten av systemet. Vær klar over at formatet på denne filen ikke er det samme som for <filename>/etc/crontab</filename>. Har du bestemte behov for <command>anacron</command>, se manualsiden <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."

msgid "<emphasis>BACK TO BASICS</emphasis> Priorities and <command>nice</command>"
msgstr "<emphasis>DET GRUNNLEGGENDE</emphasis> Prioriteter og <command>nice</command>"

msgid "<primary><command>renice</command></primary>"
msgstr "<primary><command>renice</command></primary>"

msgid "<primary>niceness</primary><seealso><command>nice</command></seealso>"
msgstr "<primary>snillhet</primary><seealso><command>nice</command></seealso>"

msgid "Unix systems (and thus Linux) are multi-tasking and multi-user systems. Indeed, several processes can run in parallel, and be owned by different users: the kernel mediates access to the resources between the different processes. As a part of this task, it has a concept of priority, which allows it to favor certain processes over others, as needed. When you know that a process can run in low priority, you can indicate so by running it with <command>nice <replaceable>program</replaceable></command>. The program will then have a smaller share of the CPU, and will have a smaller impact on other running processes. Of course, if no other process needs to run, the program will not be artificially held back."
msgstr "Unix-systemer (og dermed Linux) er fleroppgavekjøring og flerbrukersystemer. Faktisk kan flere prosesser kjøres parallelt, og være eid av forskjellige brukere; kjernen formidler tilgang til ressursene mellom de ulike prosessene. Som en del av denne oppgaven, har den et prioritetskonsept som etter behov gjør det mulig å favorisere visse prosesser fremfor andre. Når du vet at en prosess kan kjøre i lav prioritet, kan du angi det ved å kjøre den med <command>nice <replaceable>program</replaceable></command>. Programmet vil da få en mindre andel av CPU, og vil ha en mindre innvirkning på andre prosesser som kjører. Selvfølgelig, hvis ingen annen prosess trenger å kjøre, vil programmet ikke bli holdt kunstig tilbake."

msgid "<command>nice</command> works with levels of “niceness”: the positive levels (from 1 to 19) progressively lower the priority, while the negative levels (from -1 to -20) will increase it — but only root can use these negative levels. Unless otherwise indicated (see the <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry> manual page), <command>nice</command> increases the current level by 10."
msgstr "<command>nice</command> arbeider med nivåer av «snillhet»; de positive nivåene (fra 1 til 19) senker prioriteten progressivt, mens de negative nivåer (fra -1 til -20) vil øke det - men bare rot kan bruke disse negative nivåer. Dersom ikke annet er angitt (se håndboken side <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry>), <command>nice</command> øker det gjeldende nivået med 10."

msgid "If you discover that an already running task should have been started with <command>nice</command> it is not too late to fix it; the <command>renice</command> command changes the priority of an already running process, in either direction (but reducing the “niceness” of a process is reserved for the root user)."
msgstr "Hvis du oppdager at en allerede kjørende oppgave skulle vært i gang med <command>nice</command>, er det ikke for sent å ordne det; <command>renice</command>-kommandoen endrer prioritet for en prosess som allerede kjører, i begge retninger (men å redusere «snillheten» for en prosess er forbeholdt rotbrukeren)."

msgid "Installation of the <emphasis role=\"pkg\">anacron</emphasis> package deactivates execution by <command>cron</command> of the scripts in the <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, and <filename>/etc/cron.monthly/</filename> directories. This avoids their double execution by <command>anacron</command> and <command>cron</command>. The <command>cron</command> command remains active and will continue to handle the other scheduled tasks (especially those scheduled by users)."
msgstr "Installasjon av <emphasis role=\"pkg\">anacron</emphasis>-pakken deaktiverer kjøring med <command>cron</command> av skriptene i <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, og <filename>/etc/cron.monthly/</filename>-mappene. Dette hindrer dobbel kjøring av <command>anacron</command> og <command>cron</command>. <command>cron</command>-kommandoen er fortsatt aktiv, og vil fortsette å håndtere de andre planlagte oppgavene (spesielt de planlagt av brukere)."

msgid "Quotas"
msgstr "Kvoter"

msgid "<primary>quota</primary>"
msgstr "<primary>kvote</primary>"

msgid "The quota system allows limiting disk space allocated to a user or group of users. To set it up, you must have a kernel that supports it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is the case with Debian kernels. The quota management software is found in the <emphasis role=\"pkg\">quota</emphasis> Debian package."
msgstr "Kvotesystemet kan begrense diskplass avsatt til en bruker, eller gruppe av brukere. For å sette det opp må du ha en kjerne som støtter det (utarbeidet med <varname>CONFIG_QUOTA</varname> alternativ) - som er tilfellet med Debian-kjernene. Kvotehåndteringsprogrammet finnes i <emphasis role=\"pkg\">quota</emphasis> Debian-pakken."

msgid "<primary><literal>usrquota</literal></primary><seealso>quota</seealso>"
msgstr "<primary><literal>usrquota</literal></primary><seealso>quota</seealso>"

msgid "<primary><literal>grpquota</literal></primary><seealso>quota</seealso>"
msgstr "<primary><literal>grpquota</literal></primary><seealso>quota</seealso>"

msgid "To activate quota in a filesystem, you have to indicate the <literal>usrquota</literal> and <literal>grpquota</literal> options in <filename>/etc/fstab</filename> for the user and group quotas, respectively. Rebooting the computer will then update the quotas in the absence of disk activity (a necessary condition for proper accounting of already used disk space)."
msgstr "For å aktivere kvoter i et filsystem må du angi <literal>usrquota</literal> og <literal>grpquota</literal>-valgene i <filename>/etc/fstab</filename> for henholdsvis bruker- og gruppekvotene. Deretter vil omstart av maskinen oppdatere kvotene når det ikke er diskaktivitet (en nødvendig betingelse for riktig bokføring av allerede brukt diskplass)."

msgid "<primary><command>edquota</command></primary>"
msgstr "<primary><command>edquota</command></primary>"

msgid "<primary>quota</primary><secondary><command>edquota</command></secondary>"
msgstr "<primary>kvote</primary><secondary><command>edquota</command></secondary>"

msgid "The <command>edquota <replaceable>user</replaceable></command> (or <command>edquota -g <replaceable>group</replaceable></command>) command allows you to change the limits while examining current disk space usage."
msgstr "Kommandoen <command>edquota <replaceable>bruker</replaceable></command> (eller <command>edquota -g <replaceable>gruppe</replaceable></command>) tillater deg å endre grensene mens bruken av gjeldende diskplass undersøkes."

msgid "<emphasis>GOING FURTHER</emphasis> Defining quotas with a script"
msgstr "<emphasis>FOR VIDEREKOMMENDE</emphasis> Å definere kvoter med et skript"

msgid "<primary><command>setquota</command></primary>"
msgstr "<primary><command>setquota</command></primary>"

msgid "<primary>quota</primary><secondary><command>setquota</command></secondary>"
msgstr "<primary>kvote</primary><secondary><command>setquota</command></secondary>"

msgid "The <command>setquota</command> program can be used in a script to automatically change many quotas. Its <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> manual page details the syntax to use."
msgstr "Programmet <command>setquota</command> kan bli brukt i et skript for automatisk å forandre mange kvoter. Dets manualside <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> gir detaljer om syntaksen som kan brukes."

msgid "The quota system allows you to set four limits:"
msgstr "Kvotesystemet lar deg sette fire grenser:"

#, fuzzy
#| msgid "two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, a block contains 1024 bytes from the same file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will, however, be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total."
msgid "two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, the 1024 available bytes of each block can only be assigned to one file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will, however, be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total."
msgstr "to grenser (kalt «myk» og «hard») refererer til det antall blokker som brukes. Hvis filsystemet ble opprettet med en blokk-størrelse på 1 kibibyte, inneholder en blokk 1024 byte fra den samme filen. Ikke fylte blokker forårsaker dermed tap av diskplass . En kvote på 100 blokker, som teoretisk tillater lagring av 102.400 byte, vil imidlertid være fylt med bare 100 filer på 500 byte hver, og bare representere 50.000 byte totalt."

#, fuzzy
#| msgid "two limits (soft and hard) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files."
msgid "two limits (“soft” and “hard”) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files."
msgstr "to grenser (myke og harde) refererer til antall brukte inoder. Hver fil opptar minst en inode for å lagre informasjon om den (tillatelser, eier, tidsstempel for siste tilgang, etc.). Det er derfor en grense på antallet brukerfiler ."

msgid "<primary>inode</primary>"
msgstr "<primary>inode</primary>"

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary>quota</primary><secondary>soft limit</secondary>"
msgstr "<primary>logg inn</primary><secondary>logge inn eksternt </secondary>"

#, fuzzy
#| msgid "<primary>link</primary><secondary>hard link</secondary>"
msgid "<primary>quota</primary><secondary>hard limit</secondary>"
msgstr "<primary>lenke</primary><secondary>hardlenke</secondary>"

msgid "A “soft” limit can be temporarily exceeded; the user will simply be warned that they are exceeding the quota by the <command>warnquota</command> command, which is usually invoked by <command>cron</command>. A “hard” limit can never be exceeded: the system will refuse any operation that will cause a hard quota to be exceeded."
msgstr "En «myk» grense kan overskrides midlertidig; brukeren vil bare bli advart om at de overstiger kvoten fra <command>warnquota</command>-kommandoen, som vanligvis er utløst av <command>cron</command>. En «hard» grense kan aldri bli overskredet: Systemet vil nekte enhver operasjon som vil føre til at en hard kvote blir overskredet."

msgid "<primary>quota</primary><secondary><command>warnquota</command></secondary>"
msgstr "<primary>kvote</primary><secondary><command>warnquota</command></secondary>"

msgid "<emphasis>VOCABULARY</emphasis> Blocks and inodes"
msgstr "<emphasis>ORDFORRÅD</emphasis> Blokker og inoder"

msgid "<primary>block (disk)</primary>"
msgstr "<primary>blokk (disk)</primary>"

msgid "The filesystem divides the hard drive into blocks — small contiguous areas. The size of these blocks is defined during creation of the filesystem, and generally varies between 1 and 8 kibibytes."
msgstr "Filsystemet deler harddisken inn i blokker - små sammenhengende områder. Størrelsen på disse blokkene er definert ved etableringen av filsystemet, og varierer vanligvis mellom 1 og 8 kibibytes."

msgid "A block can be used either to store the real data of a file, or for meta-data used by the filesystem. Among this meta-data, you will especially find the inodes. An inode uses a block on the hard drive (but this block is not taken into consideration in the block quota, only in the inode quota), and contains both the information on the file to which it corresponds (name, owner, permissions, etc.) and the pointers to the data blocks that are actually used. For very large files that occupy more blocks than it is possible to reference in a single inode, there is an indirect block system; the inode references a list of blocks that do not directly contain data, but another list of blocks."
msgstr "En blokk kan enten brukes til å lagre de virkelige dataene fra en fil, eller til metadata som brukes av filsystemet. Blant disse metadataene vil du særlig finne inoder. En inode bruker en blokk på harddisken (men denne blokken er det ikke tatt hensyn til i blokkvoten, bare i inodekvoten), og inneholder både informasjon om filen som den tilsvarer (navn, eier, tillatelser, etc .) og pekere til datablokker som faktisk brukes. For meget store filer som opptar flere blokker enn det er mulig å referere til i en enkelt inode, er det et indirekte blokkeringssystem; inoden refererer til en liste med blokker som ikke direkte inneholder data, men en annen liste med blokker."

msgid "With the <command>edquota -t</command> command, you can define a maximum authorized “grace period” within which a soft limit may be exceeded. After this period, the soft limit will be treated like a hard limit, and the user will have to reduce their disk space usage to within this limit in order to be able to write anything to the hard drive."
msgstr "Med <command>edquota -t</command>-kommandoen, kan du definere en maksimal tillatt «nådeperiode» («grace period») innenfor hvilken en myk grense kan overskrides. Etter denne perioden, vil den myke grensen bli behandlet som en hard grense, og brukeren vil måtte redusere sin bruk av diskplass til denne grensen, for å kunne skrive noe på harddisken."

msgid "<emphasis>GOING FURTHER</emphasis> Setting up a default quota for new users"
msgstr "<emphasis>FOR VIDEREKOMMENDE</emphasis> Setting av utgangskvote for nye brukere"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>quota</primary><secondary><varname>QUOTAUSER</varname></secondary>"
msgstr "<primary>bruker</primary><secondary>eier</secondary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>environment variable</primary><secondary><varname>QUOTAUSER</varname></secondary>"
msgstr "<primary>tjenesten</primary><secondary>restart</secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/adduser.conf</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/adduser.conf</filename></secondary>"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary>quota</primary><secondary>template user</secondary>"
msgstr "<primary>eier</primary><secondary>bruker</secondary>"

msgid "To automatically setup a quota for new users, you have to configure a template user (with <command>edquota</command> or <command>setquota</command>) and indicate their user name in the <varname>QUOTAUSER</varname> variable in the <filename>/etc/adduser.conf</filename> file. This quota configuration will then be automatically applied to each new user created with the <command>adduser</command> command."
msgstr "For å sette opp en kvote til nye brukere automatisk må du sette opp en brukermal (med <command>edquota</command>, eller <command>setquota</command>), og indikere brukernavnet deres i <varname>QUOTAUSER</varname>-variabelen i <filename>/etc/adduser.conf</filename>-filen. Dette kvoteoppsettet vil da automatisk bli brukt på hver nye bruker som opprettes med <command>adduser</command>-kommandoen."

msgid "<primary>backup</primary>"
msgstr "<primary>sikkerhetskopi</primary>"

msgid "<primary>restoration</primary>"
msgstr "<primary>restaurering</primary>"

msgid "Making backups is one of the main responsibilities of any administrator, but it is a complex subject, involving powerful tools which are often difficult to master."
msgstr "Sikkerhetskopiering er en av hovedoppgavene for en administrator, men det er et komplekst tema, som involverer kraftige verktøy som det ofte er vanskelig å mestre."

msgid "<primary><command>amanda</command></primary>"
msgstr "<primary><command>amanda</command></primary>"

msgid "<primary><command>bacula</command></primary>"
msgstr "<primary><command>bacula</command></primary>"

msgid "<primary><command>dd</command></primary>"
msgstr "<primary><command>dd</command></primary>"

msgid "<primary><command>duplicity</command></primary>"
msgstr "<primary><command>duplicity</command></primary>"

msgid "<primary><command>fsarchiver</command></primary>"
msgstr "<primary><command>fsarchiver</command></primary>"

msgid "<primary><command>BackupPC</command></primary>"
msgstr "<primary><command>BackupPC</command></primary>"

msgid "<primary><command>rdiff-backup</command></primary>"
msgstr "<primary><command>rdiff-backup</command></primary>"

msgid "<primary><command>rsnapshot</command></primary>"
msgstr "<primary><command>rsnapshot</command></primary>"

msgid "<primary><command>timeshift</command></primary>"
msgstr "<primary><command>timeshift</command></primary>"

#, fuzzy
#| msgid "Many programs exist, such as <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Those are client/server system featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. But Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>."
msgid "Many programs exist, such as <command>amanda</command>, <command>bacula</command>, or <command>BackupPC</command>. Those are client/server systems featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. For non-enterprise systems, administrators might want to check out <command>rsnapshot</command> or <command>rdiff-backup</command>. Users can easily create backups of their filesystems with <command>timeshift</command>, <command>fsarchiver</command>, <command>duplicity</command>, or even <command>dd</command>."
msgstr "Mange programmer finnes, slike som <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. De er klient/tjener-systemer med mange muligheter, men oppsettet er ganske vanskelig. Noen av dem har brukervennlige nett-grensesnitt for å redusere denne. Men Debian inneholder dusinvis av andre sikkerhetskopieringsprogramvarer som dekker alle mulige bruksmåter, som du enkelt kan bekrefte med<command>apt-cache search backup</command>."

msgid "Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>."
msgstr "Debian inneholder mange andre programmer for sikkerhetskopiering, som dekker alle mulige brukstilfeller. Disse kan du sjekke selv med <command>apt-cache search backup</command>."

msgid "Rather than detailing some of them, this section will present the thoughts of the Falcot Corp administrators when they defined their backup strategy."
msgstr "Snarere enn en detaljert gjennomgang av noen av dem, vil dette avsnittet presentere de tanker Falcot Corp-administratorene har når de definerer sin strategi for sikkerhetskopiering."

msgid "At Falcot Corp, backups have two goals: recovering erroneously deleted files, and quickly restoring any computer (server or desktop) whose hard drive has failed."
msgstr "Hos Falcot Corp har sikkerhetskopiering to mål: Å gjenopprette feilaktig slettede filer, og raskt gjenopprette en datamaskin (tjener eller desktop) hvis harddisken har feilet."

msgid "Backing Up with <command>rsync</command>"
msgstr "Sikkerhetskopiering med <command>rsync</command>"

msgid "<primary><command>rsync</command></primary>"
msgstr "<primary><command>rsync</command></primary>"

msgid "Backups on tape having been deemed too slow and costly, data will be backed up on hard drives on a dedicated server, on which the use of software RAID (see <xref linkend=\"sect.raid-soft\" />) will protect the data from hard drive failure. Desktop computers are not backed up individually, but users are advised that their personal account on their department's file server will be backed up. The <command>rsync</command> command (from the package of the same name) is used daily to back up these different servers."
msgstr "Da sikkerhetskopier på tape har blitt ansett for å være tregt og dyrt, blir data sikkerhetskopiert på harddisker på en øremerket tjener, der bruk av programvare-RAID (se <xref linkend=\"sect.raid-soft\" />) vil beskytte data fra feil på harddisken. Stasjonære datamaskiner støttes ikke opp individuelt, men brukerne gjøres oppmerksom på at deres personlige konto på deres avdelings filtjener blir sikkerhetskopiert. <command>rsync</command>-kommando (fra pakken med samme navn) brukes daglig for å sikkerhetskopiere disse forskjellige tjenerne."

msgid "<emphasis>BACK TO BASICS</emphasis> The hard link, a second name for the file"
msgstr "<emphasis>DET GRUNNLEGGENDE</emphasis> Hardlenken, et annet navn for filen"

msgid "<primary>link</primary><secondary>hard link</secondary>"
msgstr "<primary>lenke</primary><secondary>hardlenke</secondary>"

msgid "<primary>hard link</primary>"
msgstr "<primary>hardlenke</primary>"

msgid "<primary><command>ln</command></primary>"
msgstr "<primary><command>ln</command></primary>"

msgid "A hard link, as opposed to a symbolic link, cannot be differentiated from the linked file. Creating a hard link is essentially the same as giving an existing file a second name. This is why the deletion of a hard link only removes one of the names associated with the file. As long as another name is still assigned to the file, the data therein remain present on the filesystem. It is interesting to note that, unlike a copy, the hard link does not take up additional space on the hard drive."
msgstr "En hard lenke, i motsetning til en symbolsk lenke, kan ikke skilles fra den lenkede filen. Å lage en hard lenke er egentlig det samme som å gi en eksisterende fil et navn til. Dette er grunnen til sletting av en hard lenke bare fjerner ett av navnene forbundet med filen. Så lenge et annet navn er fortsatt tildelt filen, er dataene fortsatt til stede i filsystemet. Det er interessant å merke seg at, i motsetning til en kopi, tar ikke den harde lenken opp tilleggsplass på harddisken."

msgid "A hard link is created with the <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> command. The <replaceable>link</replaceable> file is then a new name for the <replaceable>target</replaceable> file. Hard links can only be created on the same filesystem, while symbolic links are not subject to this limitation."
msgstr "En hard lenke lages med <command>ln <replaceable>mål</replaceable> <replaceable>lenke</replaceable></command>-kommandoen. <replaceable>lenke</replaceable>-filen er så det nye navnet for <replaceable>mål</replaceable>-filen. Harde lenker kan bare opprettes på samme filsystem, mens symbolske lenker er ikke underlagt denne begrensningen."

msgid "The available hard drive space prohibits implementation of a complete daily backup. As such, the <command>rsync</command> command is preceded by a duplication of the content of the previous backup with hard links, which prevents usage of too much hard drive space. The <command>rsync</command> process then only replaces files that have been modified since the last backup. With this mechanism a great number of backups can be kept in a small amount of space. Since all backups are immediately available and accessible (for example, in different directories of a given share on the network), you can quickly make comparisons between two given dates."
msgstr "Den tilgjengelige harddiskplassen forbyr gjennomføring av en komplett daglig sikkerhetskopiering. Som sådan, <command>rsync</command>-kommandoen innledes med en duplisering av innholdet i den forrige sikkerhetskopien med harde lenker, som forhindrer bruk av for mye plass på harddisken. Prosessen <command>rsync</command> erstatter da bare filer som har blitt endret siden siste backup. Med denne mekanismen kan et stort antall sikkerhetskopier holdes på en liten mengde plass. Ettersom alle sikkerhetskopier er umiddelbart tilgjengelige, og med adgang (for eksempel i ulike kataloger av en gitt andel på nettverket), kan du raskt gjøre sammenligninger mellom to gitte datoer."

msgid "<primary>copy, backup copy</primary>"
msgstr "<primary>kopiere, sikkerhetskopi</primary>"

msgid "<primary>backup</primary><secondary>copy</secondary>"
msgstr "<primary>sikkerhetskopi (backup)</primary><secondary>kopiere</secondary>"

msgid "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"

msgid "This backup mechanism is easily implemented with the <command>dirvish</command> program. It uses a backup storage space (“bank” in its vocabulary) in which it places timestamped copies of sets of backup files (these sets are called “vaults” in the dirvish documentation)."
msgstr "Denne sikkerhetskopi-mekanismen kan lett implementeres med <command>dirvish</command>-programmet. Den bruker en sikkerhetskopi-lagringsplass («bank» i sitt vokabular) hvor det plasserer tidsmerkede kopier av settene med sikkerhetskopi-filer (disse settene er kalt «vaults» i dirvish-dokumentasjon)."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/dirvish/master.conf</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/dirvish/master.conf</filename></secondary>"

msgid "The main configuration is in the <filename>/etc/dirvish/master.conf</filename> file. It defines the location of the backup storage space, the list of “vaults” to manage, and default values for expiration of the backups. The rest of the configuration is located in the <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> files and contains the specific configuration for the corresponding set of files."
msgstr "Hovedoppsettet er i <filename>/etc/dirvish/master.conf</filename>-filen. Den definerer plasseringen av lagringsplassen for sikkerhetskopien, listen over «vaults» for å administere, og standardverdier for utløpstidspunktet for sikkerhetskopier. Resten av oppsettet er plassert i <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename>-filer, og inneholder det spesifikke oppsettet for det tilsvarende settet med filer."

msgid "The <filename>/etc/dirvish/master.conf</filename> file"
msgstr "Filen <filename>/etc/dirvish/master.conf</filename>"

msgid ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   MIN HR    DOM MON       DOW  STRFTIME_FMT\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"
msgstr ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   MIN HR    DOM MON       DOW  STRFTIME_FMT\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"

msgid "The <literal>bank</literal> setting indicates the directory in which the backups are stored. The <literal>exclude</literal> setting allows you to indicate files (or file types) to exclude from the backup. The <literal>Runall</literal> is a list of file sets to backup with a time-stamp for each set, which allows you to assign the correct date to the copy, in case the backup is not triggered at precisely the assigned time. You have to indicate a time just before the actual execution time (according to <filename>/etc/cron.d/dirvish</filename>). Finally, the <literal>expire-default</literal> and <literal>expire-rule</literal> settings define the expiration policy for backups. The above example keeps forever backups that are generated on the first Sunday of each quarter, deletes after one year those from the first Sunday of each month, and after 3 months those from other Sundays. Other daily backups are kept for 15 days. The order of the rules does matter, Dirvish uses the last matching rule, or the <literal>expire-default</literal> one if no other <literal>expire-rule</literal> matches."
msgstr "Innstillingen <literal>bank</literal> angir katalogen hvor sikkerhetskopiene er lagret. Med <literal>exclude</literal>-innstillingen kan du angi filer (eller filtyper) som kan utelukkes fra sikkerhetskopieringen. <literal>Runall</literal> er en liste med filsett som kan sikkerhetskopieres med et tidsstempel for hvert sett, noe som gjør det mulig å tildele riktig dato til kopien, i tilfelle sikkerhetskopiering ikke er utløst på nøyaktig den tildelte tiden. Du må angi et tidspunkt like før selve utføringstidspunktet, ifølge <filename>/etc/cron.d/dirvish</filename>). Til slutt, <literal>expire-default</literal> og <literal>expire-rule</literal>-settingene definerer opplegget for når tiden for sikkerhetskopier utløper. Eksempelet ovenfor beholder for alltid sikkerhetskopier som er generert på den første søndagen i hvert kvartal, sletter etter ett år de fra den første søndagen i hver måned, og etter 3 måneder de fra andre søndager. Andre daglige sikkerhetskopier er beholdt i 15 dager. Rekkefølgen av reglene spiller en rolle, Dirvish bruker siste samsvarende regel, eller <literal>expire-default</literal> hvis ingen andre <literal>expire-rule</literal> samsvarer."

msgid "<emphasis>IN PRACTICE</emphasis> Scheduled expiration"
msgstr "<emphasis>I PRAKSIS</emphasis> Planlagt utløp"

msgid "The expiration rules are not used by <command>dirvish-expire</command> to do its job. In reality, the expiration rules are applied when creating a new backup copy to define the expiration date associated with that copy. <command>dirvish-expire</command> simply peruses the stored copies and deletes those for which the expiration date has passed."
msgstr "Utløpsreglene blir ikke brukt av <command>dirvish-expire</command> for å gjøre jobben sin. I realiteten blir utløpsregler brukt når du oppretter en ny sikkerhetskopi for å definere den utløpsdatoen som er knyttet til denne kopien. <command>dirvish-expire</command> leser ganske enkelt igjennom de lagrede kopiene, og sletter dem om utløpsdatoen har passert."

msgid "The <filename>/backup/root/dirvish/default.conf</filename> file"
msgstr "Filen <filename>/backup/root/dirvish/default.conf</filename>"

msgid ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"
msgstr ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"

msgid "The above example specifies the set of files to back up: these are files on the machine <emphasis>rivendell.falcot.com</emphasis> (for local data backup, simply specify the name of the local machine as indicated by <command>hostname</command>), especially those in the root tree (<literal>tree: /</literal>), except those listed in <literal>exclude</literal>. The backup will be limited to the contents of one filesystem (<literal>xdev: 1</literal>). It will not include files from other mount points. An index of saved files will be generated (<literal>index: gzip</literal>), and the image will be named according to the current date (<literal>image-default: %Y%m%d</literal>)."
msgstr "Eksempelet ovenfor spesifiserer settet med filer som skal sikkerhetskopieres: Dette er filer på maskinen <emphasis>rivendell.falcot.com</emphasis> (for lokal sikkerhetskopiering av data, ganske enkelt angi navnet på den lokale maskinen som angitt av <command>hostname</command>), særlig de i rot-treet (<literal>tree: /</literal>), untatt de som er listet i <literal>exclude</literal>. Sikkerhetskopien vil være avgrenset til innholdet i ett filsystem (<literal>xdev: 1</literal>). Den vil ikke inkludere filer fra andre monteringspunkter. En indeks over lagrede filer vil generes (<literal>index: gzip</literal>), og bildet blir navngitt med dagens dato (<literal>image-default: %Y%m%d</literal>)."

#, fuzzy
#| msgid "There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired."
msgid "There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired."
msgstr "Det er mange alternativer tilgjengelig, alle dokumentert i manualsiden <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>. Når disse oppsettsfilene er opprettet, må du starte hvert filsett med <command>dirvish --vault <replaceable>vault</replaceable> --init</command>-kommandoen. Fra da av vil den daglige påkallelsen fra <command>dirvish-runall</command> automatisk opprette en ny sikkerhetskopi like etter å ha slettet de som er utløpt."

msgid "<emphasis>IN PRACTICE</emphasis> Remote backup over SSH"
msgstr "<emphasis>I PRAKSIS</emphasis> Ekstern sikkerhetskopiering via SSH"

msgid "When dirvish needs to save data to a remote machine, it will use <command>ssh</command> to connect to it, and will start <command>rsync</command> as a server. This requires the root user to be able to automatically connect to it. The use of an SSH authentication key allows precisely that (see <xref linkend=\"sect.ssh-key-based-auth\" />)."
msgstr "Når dirvish trenger å lagre data på en ekstern maskin, vil den bruke <command>ssh</command> for å koble seg til den, og vil starte <command>rsync</command> som en tjener. Dette krever at rotbrukeren automatisk kan koble seg til den. Å bruke en SSH-autentiseringsnøkkel tillater nettopp dette (se <xref linkend=\"sect.ssh-key-based-auth\" />)."

msgid "Restoring Machines without Backups"
msgstr "Å gjenopprette maskiner uten sikkerhetskopier"

#, fuzzy
#| msgid "Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs prepared with <emphasis>Simple-CDD</emphasis> (see <xref linkend=\"sect.simple-cdd\" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to dconf (see <xref linkend=\"sect.gnome-desktop\" /> for more information about this)."
msgid "Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs/USB sticks prepared with <emphasis role=\"pkg\">simple-cdd</emphasis> (see <xref linkend=\"sect.simple-cdd\" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to <command>dconf</command> (see <xref linkend=\"sect.gnome-desktop\" /> for more information about this)."
msgstr "Stasjonære datamaskiner, som ikke er sikkerhetskopiert, kan enkelt installeres fra tilpassede DVD-ROM-er klargjort med <emphasis>Simple-CDD</emphasis> (se <xref linkend=\"sect.simple-cdd\" />). Siden dette lager en installasjon fra bunnen av, mistes noe tilpasning som kan ha blitt gjort etter den første installasjonen. Dette er greit, siden systemene alle er koblet til en sentral LDAP-katalog for kontoer, og de fleste skrivebordsprogrammer er forhåndsoppsatt takket være dconf (se <xref linkend=\"sect.gnome-desktop\" /> for mer informasjon om dette)."

msgid "The Falcot Corp administrators are aware of the limits in their backup policy. Since they can't protect the backup server as well as a tape in a fireproof safe, they have installed it in a separate room so that a disaster such as a fire in the server room won't destroy backups along with everything else. Furthermore, they do an incremental backup on DVD-ROM once per week — only files that have been modified since the last backup are included."
msgstr "Falcot Corp administratorer er klar over begrensningene i sin sikkerhetskopi-politikk. Siden de ikke kan beskytte sikkerhetskopi-tjeneren samt et bånd (tape) i en brannsikker safe, har de installert det i et eget rom, slik at hendelser, for eksempel en brann i tjenerrommet, ikke ødelegger sikkerhetskopier sammen med alt annet. Videre lager de en trinnvis sikkerhetskopiering på DVD-ROM en gang pr. uke - kun de filer som er endret siden siste sikkerhetskopiering er inkludert."

msgid "<emphasis>GOING FURTHER</emphasis> Backing up SQL and LDAP services"
msgstr "<emphasis>FOR VIDEREKOMMENDE</emphasis> Sikkerhetskopiere SQL- og LDAP-tjenester"

msgid "<primary><command>xdelta</command></primary>"
msgstr "<primary><command>xdelta</command></primary>"

msgid "<primary><command>diff</command></primary>"
msgstr "<primary><command>diff</command></primary>"

msgid "<primary>dump</primary>"
msgstr "<primary>dump</primary>"

msgid "Many services (such as SQL or LDAP databases) cannot be backed up by simply copying their files (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times). As such, it is necessary to use an “export” mechanism to create a “data dump” that can be safely backed up. These are often quite large, but they compress well. To reduce the storage space required, you will only store a complete text file per week, and a <command>diff</command> each day, which is created with a command of the type <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. The <command>xdelta</command> program produces incremental differences from binary dumps."
msgstr "Mange tjenester (som for eksempel SQL- eller LDAP-databaser) kan ikke sikkerhetskopieres bare ved å kopiere filene deres (med mindre de er riktig avbrutt når sikkerhetskopiene lages, noe som ofte er problematisk, siden de er ment å være tilgjengelig til enhver tid). Dermed er det nødvendig å bruke en «eksport»-mekanisme for å lage en «data dump» som trygt kan sikkerhetskopieres. Disse er ofte ganske store, men de komprimeres godt. For å redusere plassbehovet som trengs kan du bare lagre komplett tekstfil per uke, og en <command>diff</command> hver dag, som lages med en kommando av typen <command>diff <replaceable>gårsdagens_fil</replaceable> <replaceable>dagens_fil</replaceable></command>. Programmet <command>xdelta</command> lager økende forskjeller fra binære dumper."

msgid "<emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>, the standard for tape backups"
msgstr "<emphasis>KULTUR</emphasis> <emphasis>TAR</emphasis>, standarden for sikkerhetskopiering på tape (bånd)"

msgid "<primary>backup</primary><secondary>on tape</secondary>"
msgstr "<primary>sikkerhetskopiering</primary><secondary>på tape</secondary>"

msgid "<primary>tape, backup</primary>"
msgstr "<primary>tape, sikkerhetskopiering</primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary><acronym>TAR</acronym></primary><seealso>tape archive</seealso>"
msgstr "<primary>SSH tunnell</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>tape, backup</primary>"
msgid "<primary>tape archive</primary>"
msgstr "<primary>tape, sikkerhetskopiering</primary>"

msgid "Historically, the simplest means of making a backup on Unix was to store a <emphasis>TAR</emphasis> archive on a tape. The <command>tar</command> command even got its name from “Tape ARchive”."
msgstr "De enkleste måtene for å lage en sikkerhetskopi på Unix var, historisk sett, å lagre et <emphasis>TAR</emphasis>-arkiv på et bånd. Kommandoen <command>tar</command> fikk til og med sitt navn fra «Tape ARchive»."

msgid "Hot Plugging: <emphasis>hotplug</emphasis>"
msgstr "Varm tilkobling: <emphasis>hotplug</emphasis>"

msgid "Introduction"
msgstr "Introduksjon"

msgid "<primary>hotplug</primary>"
msgstr "<primary>hotplug</primary>"

#, fuzzy
#| msgid "<primary>booting</primary><secondary>the system</secondary>"
msgid "<primary>kernel</primary><secondary>hotplug subsystem</secondary>"
msgstr "<primary>oppstart</primary><secondary>systemet</secondary>"

msgid "<primary><command>udevd</command></primary>"
msgstr "<primary><command>udevd</command></primary>"

msgid "<primary><filename>/dev</filename></primary>"
msgstr "<primary><filename>/dev</filename></primary>"

msgid "<primary>device</primary><seealso><filename>/dev</filename></seealso>"
msgstr "<primary>enhet</primary><seealso><filename>/dev</filename></seealso>"

msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

msgid "<primary>PCMCIA</primary>"
msgstr "<primary>PCMCIA</primary>"

msgid "<primary>SATA</primary>"
msgstr "<primary>S-ATA</primary>"

#, fuzzy
#| msgid "The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be hotplugged: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory."
msgid "The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be “hotplugged“: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory."
msgstr "Kjerne-delsystemet <emphasis>hotplug</emphasis> håndterer å legge til og fjerne enheter ved å laste de riktige driverne, og ved å lage passende enhetsfiler (med hjelp av <command>udevd</command>). Med moderne maskinvare og visualisering, kan nesten alt bli varmtilkoblet (hotplugged): fra den vanlige USB/PCMCIA/IEEE 1394 enheter til SATA-harddisker, men også CPU-en og minnet."

msgid "The kernel has a database that associates each device ID with the required driver. This database is used during boot to load all the drivers for the peripheral devices detected on the different buses, but also when an additional hotplug device is connected. Once the device is ready for use, a message is sent to <command>udevd</command> so it will be able to create the corresponding entry in <filename>/dev/</filename>."
msgstr "Kjernen har en database som knytter hver enhets-ID med den nødvendige driveren. Denne databasen brukes under oppstart for å laste alle driverne til eksterne enheter som oppdages på forskjellige busser, men også når en ekstra varmtilkoblingsenhet blir koblet til. Når enheten er klar til bruk, sendes en melding til <command>udevd</command> slik at den kan lage den tilsvarende oppføringen i <filename>/dev/</filename>."

msgid "The Naming Problem"
msgstr "Navneproblemet"

msgid "Before the appearance of hotplug connections, it was easy to assign a fixed name to a device. It was based simply on the position of the devices on their respective bus. But this is not possible when such devices can come and go on the bus. The typical case is the use of a digital camera and a USB key, both of which appear to the computer as disk drives. The first one connected may be <filename>/dev/sdb</filename> and the second <filename>/dev/sdc</filename> (with <filename>/dev/sda</filename> representing the computer's own hard drive). The device name is not fixed; it depends on the order in which devices are connected."
msgstr "Før varm-tilkoblingene, var det enkelt å tilordne et fast navn til en enhet. Det var enkelt basert på enhetenes posisjonen på sine respektive busser. Men dette er ikke mulig når slike enheter kan komme og gå på bussen. Det typiske tilfellet er bruk av et digitalt kamera og en USB-minnepenn, som begge for datamaskinen ser ut som harddisker. Den første tilkoblede kan være <filename>/dev/sdb</filename> og den andre <filename>/dev/sdc</filename> (med <filename>/dev/sda</filename> som representerer datamaskinens egen harddisk). Enhetsnavnet er ikke fast; det er avhengig av rekkefølgen enheter er koblet til."

msgid "Additionally, more and more drivers use dynamic values for devices' major/minor numbers, which makes it impossible to have static entries for the given devices, since these essential characteristics may vary after a reboot."
msgstr "I tillegg bruker flere og flere drivere dynamiske verdier for enhetenes store/små nummer, noe som gjør det umulig å ha statiske oppføringer for de gitte enhetene, siden deres grunnleggende egenskaper kan variere etter en omstart."

msgid "<primary>udev</primary>"
msgstr "<primary>udev</primary>"

msgid "<emphasis>udev</emphasis> was created precisely to solve this problem."
msgstr "<emphasis>udev</emphasis> ble laget nettopp for å løse dette problemet."

msgid "How <emphasis>udev</emphasis> Works"
msgstr "Hvordan <emphasis>udev</emphasis> virker"

msgid "<primary><filename>/sys</filename></primary>"
msgstr "<primary><filename>/sys</filename></primary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/udev/rules.d/</filename></secondary>"
msgstr "<primary><filename>/etc</filename></primary><secondary><filename>/etc/udev/rules.d/</filename></secondary>"

msgid "<primary><filename>/lib</filename></primary><secondary><filename>/lib/udev/rules.d/</filename></secondary>"
msgstr "<primary><filename>/lib</filename></primary><secondary><filename>/lib/udev/rules.d/</filename></secondary>"

msgid "When <emphasis>udev</emphasis> is notified by the kernel of the appearance of a new device, it collects various information on the given device by consulting the corresponding entries in <filename>/sys/</filename>, especially those that uniquely identify it (MAC address for a network card, serial number for some USB devices, etc.)."
msgstr "Når <emphasis>udev</emphasis> varsles av kjernen når en ny enhet dukker opp, samler den ulike opplysninger om den gitte enheten ved å konsultere de tilsvarende oppføringene i <filename>/sys/</filename>, spesielt de som klart identifiserer den (MAC-adressen til et nettverkskort, serienummer for enkelte USB-enheter, etc.)."

msgid "<primary>udev</primary><secondary>rules</secondary>"
msgstr "<primary>udev</primary><secondary>regler</secondary>"

msgid "Armed with all of this information, <emphasis>udev</emphasis> then consults all of the rules contained in <filename>/etc/udev/rules.d/</filename> and <filename>/lib/udev/rules.d/</filename>. In this process it decides how to name the device, what symbolic links to create (to give it alternative names), and what commands to execute. All of these files are consulted, and the rules are all evaluated sequentially (except when a file uses “GOTO” directives). Thus, there may be several rules that correspond to a given event."
msgstr "Bevæpnet med all denne informasjonen, <emphasis>udev</emphasis> konsulterer så alle reglene som ligger i <filename>/etc/udev/rules.d/</filename> og <filename>/lib/udev/rules.d/</filename>. I denne prosessen bestemmer den hvordan enheten skal navnes, hvilke symbolske lenker som skal lages (for å gi den alternative navn), og hvilke kommandoer som skal kjøres. Alle disse filene er konsultert , og reglene er alle vurdert sekvensielt (bortsett fra når en fil bruker «GOTO»-direktiver). Således kan det være flere regler som svarer til en gitt hendelse."

msgid "The syntax of rules files is quite simple: each row contains selection criteria and variable assignments. The former are used to select events for which there is a need to react, and the latter defines the action to take. They are all simply separated with commas, and the operator implicitly differentiates between a selection criterion (with comparison operators, such as <literal>==</literal> or <literal>!=</literal>) or an assignment directive (with operators such as <literal>=</literal>, <literal>+=</literal> or <literal>:=</literal>)."
msgstr "Regelfilenes syntaks er ganske enkel: Hver rad inneholder utvalgskriterier og variable oppdrag. Den første er brukt til å velge hendelser der det er behov for å reagere, og sistnevnte definerer handlingen som skal utføres. De er alle enkelt atskilt med komma, og operatøren skiller implisitt mellom et utvalgskriterium (med sammenligningsoperatorer, for eksempel <literal>==</literal>, eller <literal>!=</literal>), eller et oppdragsdirektiv (med operatorer som <literal>=</literal>, <literal>+=</literal> eller <literal>:=</literal>)."

msgid "Comparison operators are used on the following variables:"
msgstr "Sammenligningsoperatorer brukes på følgende variabler:"

msgid "<literal>KERNEL</literal>: the name that the kernel assigns to the device;"
msgstr "<literal>KJERNE</literal>: navnet som kjernen tilordner til enheten;"

msgid "<literal>ACTION</literal>: the action corresponding to the event (“add” when a device has been added, “remove” when it has been removed);"
msgstr "<literal>ACTION</literal>: handlingen som tilsvarer hendelsen («add» når en enhet er lagt til, «remove» når den er fjernet);"

msgid "<literal>DEVPATH</literal>: the path of the device's <filename>/sys/</filename> entry;"
msgstr "<literal>DEVPATH</literal>: Stien til enhetens <filename>/sys/</filename> inngang;"

msgid "<literal>SUBSYSTEM</literal>: the kernel subsystem which generated the request (there are many, but a few examples are “usb”, “ide”, “net”, “firmware”, etc.);"
msgstr "<literal>SUBSYSTEM</literal>: kjerne-delsystemet som genererer forespørselen (det er mange, men noen eksempler er «usb»,«ide», «net», «firmware», etc.);"

msgid "<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: file contents of the <replaceable>attribute</replaceable> file in the <filename>/sys/<replaceable>$devpath</replaceable>/</filename> directory of the device. This is where you find the MAC address and other bus specific identifiers;"
msgstr "<literal>ATTR{<replaceable>attributt (egenskap)</replaceable>}</literal>: filinnholdet til <replaceable>attributt</replaceable>-filen i <filename>/sys/<replaceable>$devpath</replaceable>/</filename>-mappen til enheten. Det er her du finner MAC-adressen og andre buss-spesifikke identifikatorer;"

msgid "<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> and <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> are variations that will try to match the different options on one of the parent devices of the current device;"
msgstr "<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> og <literal>ATTRS{<replaceable>attributter</replaceable>}</literal> er variasjoner som vil prøve å treffe de ulike valgene hos en av de overordnede enhetene til den aktuelle enheten;"

msgid "<literal>PROGRAM</literal>: delegates the test to the indicated program (true if it returns 0, false if not). The content of the program's standard output is stored so that it can be reused by the <literal>RESULT</literal> test;"
msgstr "<literal>PROGRAM</literal>: delegerer testen til det angitte programmet (sant hvis den returnerer 0, falsk hvis ikke). Innholdet av programmmets standard resultat blir lagret slik at det kan brukes om igjen av <literal>RESULT</literal>-testen;"

msgid "<literal>RESULT</literal>: execute tests on the standard output stored during the last call to <literal>PROGRAM</literal>."
msgstr "<literal>RESULT</literal>: utfører tester på standardresultatet lagret under siste kontakt til <literal>PROGRAM</literal>."

msgid "The right operands can use pattern expressions to match several values at the same time. For instance, <literal>*</literal> matches any string (even an empty one); <literal>?</literal> matches any character, and <literal>[]</literal> matches the set of characters listed between the square brackets (or the opposite thereof if the first character is an exclamation point, and contiguous ranges of characters are indicated like <literal>a-z</literal>)."
msgstr "De riktige operander kan bruke mønsteruttrykk for å finne flere verdier som passer samtidig. For eksempel, <literal>*</literal> matcher alle strenger (selv en tom en); <literal>?</literal> treffer hvilken som helst tegn, og <literal>[]</literal> matcher settet med tegn som er listet mellom hakeparenteser (eller det motsatte hvis det første tegnet er et utropstegn, og sammenhengende rekker med tegn er angitt som <literal>a-z</literal>)."

msgid "Regarding the assignment operators, <literal>=</literal> assigns a value (and replaces the current value); in the case of a list, it is emptied and contains only the value assigned. <literal>:=</literal> does the same, but prevents later changes to the same variable. As for <literal>+=</literal>, it adds an item to a list. The following variables can be changed:"
msgstr "Når det gjelder tildelingsoperatørene, <literal>=</literal> tildeler en verdi (og erstatter gjeldende verdi); i tilfelle av en liste, blir den tømt, og inneholder bare den tildelte verdien. <literal>:=</literal> gjør det samme, men hindrer senere endringer i samme variabel. Når det gjelder <literal>+=</literal>, legger den til et element i en liste. Følgende variabler kan endres:"

msgid "<literal>NAME</literal>: the device filename to be created in <filename>/dev/</filename>. Only the first assignment counts; the others are ignored;"
msgstr "<literal>NAME</literal>: filnavnet til enheten som skal opprettes i <filename>/dev/</filename>. Bare den første oppgaven teller; de andre blir ignorert;"

msgid "<literal>SYMLINK</literal>: the list of symbolic links that will point to the same device;"
msgstr "<literal>SYMLINK</literal>: listen med symbolske lenker som vil peke til den samme enheten;"

msgid "<literal>OWNER</literal>, <literal>GROUP</literal> and <literal>MODE</literal> define the user and group that owns the device, as well as the associated permission;"
msgstr "<literal>OWNER</literal>, <literal>GROUP</literal> og <literal>MODE</literal> definerer brukeren og gruppen som eier enheten, samt tilhørende tillatelse;"

msgid "<literal>RUN</literal>: the list of programs to execute in response to this event."
msgstr "<literal>RUN</literal>: listen over programmer som må kjøres som reaksjon på denne hendelsen."

msgid "The values assigned to these variables may use a number of substitutions:"
msgstr "Verdiene tilordnet disse variablene kan bruke en rekke erstatninger:"

msgid "<literal>$kernel</literal> or <literal>%k</literal>: equivalent to <literal>KERNEL</literal>;"
msgstr "<literal>$kernel</literal> eller <literal>%k</literal>: som tilsvarer <literal>KERNEL</literal>;"

msgid "<literal>$number</literal> or <literal>%n</literal>: the order number of the device, for example, for <literal>sda3</literal>, it would be “3”;"
msgstr "<literal>$number</literal> eller <literal>%n</literal>: rekkefølgenummeret til enheten, for eksempel for <literal>sda3</literal>, ville det være «3»;"

msgid "<literal>$devpath</literal> or <literal>%p</literal>: equivalent to <literal>DEVPATH</literal>;"
msgstr "<literal>$devpath</literal> eller <literal>%p</literal>: som tilsvarerer <literal>DEVPATH</literal>;"

msgid "<literal>$attr{<replaceable>attribute</replaceable>}</literal> or <literal>%s{<replaceable>attribute</replaceable>}</literal>: equivalent to <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;"
msgstr "<literal>$attr{<replaceable>attributt</replaceable>}</literal> eller <literal>%s{<replaceable>attributt</replaceable>}</literal>: som tilsvarer <literal>ATTRS{<replaceable>attributt</replaceable>}</literal>;"

msgid "<literal>$major</literal> or <literal>%M</literal>: the kernel major number of the device;"
msgstr "<literal>$major</literal> eller <literal>%M</literal>: hovednummeret for enheten i kjernen;"

msgid "<literal>$minor</literal> or <literal>%m</literal>: the kernel minor number of the device;"
msgstr "<literal>$minor</literal> eller <literal>%m</literal>: undernummer for enheten i kjernen;"

msgid "<literal>$result</literal> or <literal>%c</literal>: the string output by the last program invoked by <literal>PROGRAM</literal>;"
msgstr "<literal>$result</literal> eller <literal>%c</literal>: resultatstrengen fra det siste programmet aktivert av <literal>PROGRAM</literal>;"

msgid "and, finally, <literal>%%</literal> and <literal>$$</literal> for the percent and dollar sign, respectively."
msgstr "og, til slutt, <literal>%%</literal> og <literal>$$</literal> for henholdsvis prosent og dollartegnet."

#, fuzzy
#| msgid "The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive."
msgid "The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle> <manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive."
msgstr "De ovennevnte listene er ikke komplette (de inneholder kun de viktigste parametrene), men manualside <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> skulle være uttømmende."

msgid "A concrete example"
msgstr "Et konkret eksempel"

msgid "Let us consider the case of a simple USB key and try to assign it a fixed name. First, you must find the elements that will identify it in a unique manner. For this, plug it in and run <command>udevadm info -a -n /dev/sdc</command> (replacing <replaceable>/dev/sdc</replaceable> with the actual name assigned to the key)."
msgstr "La oss vurdere tillfellet med en enkel USB-minnepenn, og prøve å tilordne et fast navn til den. Først må du finne de elementene som unikt vil identifisere den. For å få til dette plugg den inn og kjør <command>udevadm info -a -n /dev/sdc</command> (for å erstatte <replaceable>/dev/sdc</replaceable> med det faktiske navnet minnepennen har)."

#, fuzzy
#| msgid ""
#| "<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
#| "<computeroutput>[...]\n"
#| "  looking at device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0/block/sdc':\n"
#| "    KERNEL==\"sdc\"\n"
#| "    SUBSYSTEM==\"block\"\n"
#| "    DRIVER==\"\"\n"
#| "    ATTR{hidden}==\"0\"\n"
#| "    ATTR{events}==\"media_change\"\n"
#| "    ATTR{ro}==\"0\"\n"
#| "    ATTR{discard_alignment}==\"0\"\n"
#| "    ATTR{removable}==\"1\"\n"
#| "    ATTR{events_async}==\"\"\n"
#| "    ATTR{alignment_offset}==\"0\"\n"
#| "    ATTR{capability}==\"51\"\n"
#| "    ATTR{events_poll_msecs}==\"-1\"\n"
#| "    ATTR{stat}==\"     130        0     6328      435        0        0        0        0        0      252      252        0        0        0        0\"\n"
#| "    ATTR{size}==\"15100224\"\n"
#| "    ATTR{range}==\"16\"\n"
#| "    ATTR{ext_range}==\"256\"\n"
#| "    ATTR{inflight}==\"       0        0\"\n"
#| "[...]\n"
#| "\n"
#| "  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0':\n"
#| "[...]\n"
#| "    ATTRS{max_sectors}==\"240\"\n"
#| "[...]\n"
#| "  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1':\n"
#| "    KERNELS==\"2-1\"\n"
#| "    SUBSYSTEMS==\"usb\"\n"
#| "    DRIVERS==\"usb\"\n"
#| "    ATTRS{bDeviceProtocol}==\"00\"\n"
#| "    ATTRS{bNumInterfaces}==\" 1\"\n"
#| "    ATTRS{busnum}==\"2\"\n"
#| "    ATTRS{quirks}==\"0x0\"\n"
#| "    ATTRS{authorized}==\"1\"\n"
#| "    ATTRS{ltm_capable}==\"no\"\n"
#| "    ATTRS{speed}==\"480\"\n"
#| "    ATTRS{product}==\"TF10\"\n"
#| "    ATTRS{manufacturer}==\"TDK LoR\"\n"
#| "[...]\n"
#| "    ATTRS{serial}==\"07032998B60AB777\"\n"
#| "[...]\n"
#| "</computeroutput>"
msgid ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{hidden}==\"0\"\n"
"    ATTR{events}==\"media_change\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{discard_alignment}==\"0\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{events_async}==\"\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"51\"\n"
"    ATTR{events_poll_msecs}==\"-1\"\n"
"    ATTR{stat}==\"130  0  6328  435  0  0  0  0  0  252  252  0  0  0  0\"\n"
"    ATTR{size}==\"15100224\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{inflight}==\"0  0\"\n"
"[...]\n"
"\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0':\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1':\n"
"    KERNELS==\"2-1\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{bDeviceProtocol}==\"00\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{busnum}==\"2\"\n"
"    ATTRS{quirks}==\"0x0\"\n"
"    ATTRS{authorized}==\"1\"\n"
"    ATTRS{ltm_capable}==\"no\"\n"
"    ATTRS{speed}==\"480\"\n"
"    ATTRS{product}==\"TF10\"\n"
"    ATTRS{manufacturer}==\"TDK LoR\"\n"
"[...]\n"
"    ATTRS{serial}==\"07032998B60AB777\"\n"
"[...]\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{hidden}==\"0\"\n"
"    ATTR{events}==\"media_change\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{discard_alignment}==\"0\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{events_async}==\"\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"51\"\n"
"    ATTR{events_poll_msecs}==\"-1\"\n"
"    ATTR{stat}==\"     130        0     6328      435        0        0        0        0        0      252      252        0        0        0        0\"\n"
"    ATTR{size}==\"15100224\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{inflight}==\"       0        0\"\n"
"[...]\n"
"\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0':\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1':\n"
"    KERNELS==\"2-1\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{bDeviceProtocol}==\"00\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{busnum}==\"2\"\n"
"    ATTRS{quirks}==\"0x0\"\n"
"    ATTRS{authorized}==\"1\"\n"
"    ATTRS{ltm_capable}==\"no\"\n"
"    ATTRS{speed}==\"480\"\n"
"    ATTRS{product}==\"TF10\"\n"
"    ATTRS{manufacturer}==\"TDK LoR\"\n"
"[...]\n"
"    ATTRS{serial}==\"07032998B60AB777\"\n"
"[...]\n"
"</computeroutput>"

msgid "To create a new rule, you can use tests on the device's variables, as well as those of one of the parent devices. The above case allows us to create two rules like these:"
msgstr "For å opprette en ny regel kan du bruke tester på enhetens variabler, så vel som de fra en av de overordnede enhetene. Det ovennevnte tilfellet tillater oss å lage to regler som disse:"

msgid ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/part%n\""
msgstr ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/part%n\""

msgid "Once these rules are set in a file, named for example <filename>/etc/udev/rules.d/010_local.rules</filename>, you can simply remove and reconnect the USB key. You can then see that <filename>/dev/usb_key/disk</filename> represents the disk associated with the USB key, and <filename>/dev/usb_key/part1</filename> is its first partition."
msgstr "Når disse reglene er satt i en fil, som for eksempel er døpt <filename>/etc/udev/rules.d/010_local.rules</filename>, kan du enkelt fjerne og koble til USB-minnepennen. Deretter kan du se at <filename>/dev/usb_key/disk</filename> representerer disken knyttet til USB-minnepennen, og <filename>/dev/usb_key/part1</filename> er dens første partisjon."

msgid "<emphasis>GOING FURTHER</emphasis> Debugging <emphasis>udev</emphasis>'s configuration"
msgstr "<emphasis>FOR VIDEREKOMMENDE</emphasis> Feilsøking i oppsettet til <emphasis>udev</emphasis>"

msgid "<primary><command>udevd</command></primary><secondary><filename>/var/log/daemon.log</filename></secondary>"
msgstr "<primary><command>udevd</command></primary><secondary><filename>/var/log/daemon.log</filename></secondary>"

msgid "<primary><command>udevadm</command></primary>"
msgstr "<primary><command>udevadm</command></primary>"

msgid "Like many daemons, <command>udevd</command> stores logs in <filename>/var/log/daemon.log</filename>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <command>udevadm control --log-priority=info</command> command increases the verbosity level and solves this problem. <command>udevadm control --log-priority=err</command> returns to the default verbosity level."
msgstr "Som for mange bakgrunnsprosesser, lagrer <command>udevd</command> logger i <filename>/var/log/daemon.log</filename>. Men det er ikke veldig detaljert som standard, og det er som regel ikke nok til å forstå hva som skjer. Kommandoen <command>udevadm control --log-priority=info</command> øker detaljnivået, og løser dette problemet. <command>udevadm control --log-priority=err</command> returnerer til standard detaljnivå."

msgid "Power Management: Advanced Configuration and Power Interface (ACPI)"
msgstr "Strømstyring: Advanced Configuration and Power Interface (ACPI)"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>power management</primary><seealso>ACPI</seealso>"
msgstr "<primary>SSH tunnell</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>management, power management</primary>"
msgid "<primary>management, power management</primary><seealso>ACPI</seealso>"
msgstr "<primary>styring, strømstyring</primary>"

msgid "<primary>ACPI</primary>"
msgstr "<primary>ACPI</primary>"

msgid "<primary>Advanced Configuration and Power Interface</primary><seealso>ACPI</seealso>"
msgstr "<primary>Advanced Configuration and Power Interface</primary><seealso>ACPI</seealso>"

msgid "<primary><command>acpid</command></primary>"
msgstr "<primary><command>acpid</command></primary>"

msgid "The topic of power management is often problematic. Indeed, properly suspending the computer requires that all the computer's device drivers know how to put them to standby, and that they properly reconfigure the devices upon waking. Unfortunately, there are still a few devices unable to sleep well under Linux, because their manufacturers have not provided the required specifications."
msgstr "Emnet strømstyring er ofte problematisk. Faktisk, riktig hvilemodus for maskinen krever at alle datamaskinens enhetsdrivere vet hvordan de settes i ventemodus, og at de skal sette opp enhetene igjen ved oppvåkning. Dessverre er det fortsatt noen få enheter som ikke kan sove godt under Linux, fordi produsentene deres ikke har gitt de nødvendige spesifikasjonene."

msgid "Linux supports <acronym>ACPI</acronym> (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role=\"pkg\">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response."
msgstr "Linux støtter <acronym>ACPI</acronym> (Advanced Configuration and Power Interface) - den nyeste standarden for strømstyring. Pakken <emphasis role=\"pkg\">acpid</emphasis> har en bakgrunnsprosess som ser etter strømstyringsrelaterte hendelser (veksling mellom AC og batteristrøm på en bærbar PC, etc.) og som kan utføre ulike kommandoer når dette skjer."

msgid "<emphasis>BEWARE</emphasis> Graphics card and standby"
msgstr "<emphasis>PASS PÅ</emphasis> Grafikkort og ventemodus"

msgid "The graphics card driver is often the culprit when standby doesn't work properly. In that case, it is a good idea to test the latest version of the X.org graphics server."
msgstr "Grafikkortdriveren er ofte den skyldige når ventemodus ikke fungerer ordentlig. I så fall er det en god idé å teste den nyeste versjonen av X.org grafikktjener."

msgid "After this overview of basic services common to many Unix systems, we will focus on the environment of the administered machines: the network. Many services are required for the network to work properly. They will be discussed in the next chapter."
msgstr "Etter denne oversikten over grunnleggende tjenester felles for mange Unix-systemer, vil vi fokusere på miljøet for de administrerte maskinene: Nettverket. Mange tjenester er nødvendige for at nettverket skal fungere ordentlig. De blir diskutert i neste kapittel."

#~ msgid "<emphasis role=\"pkg\">file-rc</emphasis> is a boot system with a very simple process. It keeps the principle of runlevels, but replaces the directories and symbolic links with a configuration file, which indicates to <command>init</command> the processes that must be started and their launch order."
#~ msgstr "<emphasis role=\"pkg\">file-rc</emphasis> er et oppstartssystem med en veldig enkel prosess. Det beholder prinsippet om kjørenivå, men erstatter mapper og symbolske lenker med en oppsettsfil, som forteller <command>init</command> hvilke prosesser som må startes, og oppstartsrekkefølgen deres."

#~ msgid "As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed."
#~ msgstr "Som du kan se, er det svært lite kode her, bare deklarasjoner. Systemd tar seg av visning av fremdriftsrapporter, holder orden på prosessene, og starter dem selv når det trengs."

#~ msgid "<primary>Secure Shell</primary>"
#~ msgstr "<primary>Secure Shell</primary>"

#~ msgid "<primary>OpenSSH</primary>"
#~ msgstr "<primary>OpenSSH</primary>"

#~ msgid "VNC also works for mobile users, or company executives, who occasionally need to login from their home to access a remote desktop similar to the one they use at work. The configuration of such a service is more complicated: you first install the <emphasis role=\"pkg\">vnc4server</emphasis> package, change the configuration of the display manager to accept <literal>XDMCP Query</literal> requests (for <command>gdm3</command>, this can be done by adding <literal>Enable=true</literal> in the “xdmcp” section of <filename>/etc/gdm3/daemon.conf</filename>), and finally, start the VNC server with <command>inetd</command> so that a session is automatically started when a user tries to login. For example, you may add this line to <filename>/etc/inetd.conf</filename>:"
#~ msgstr "VNC fungerer også for mobile brukere, eller næringslivsledere, som av og til trenger å logge inn hjemmefra for å få tilgang til et eksternt skrivebord lik det de bruker på jobben. Oppsettet av en slik tjeneste er mer komplisert: Du må først installere <emphasis role=\"pkg\">vnc4server</emphasis>-pakken, endre oppsettet på skjermviseren til å godta <literal>XDMCP Query</literal>-forespørsler (for <command>gdm3</command>. Dette kan gjøres ved å legge til <literal>Enable=true</literal> i «xdmcp»-seksjonen til <filename>/etc/gdm3/daemon.conf</filename>), og til slutt, starte VNC-tjeneren med <command>inetd</command> slik at en økt starter automatisk når en bruker prøver å logge seg inn. For eksempel kan du legge til denne linjen til <filename>/etc/inetd.conf</filename>:"

#~ msgid "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"
#~ msgstr "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"

#~ msgid "Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <command>gdm3</command> login screen (or equivalent <command>kdm</command>, <command>xdm</command>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <command>vncviewer <replaceable>server</replaceable>:50</command>, because the port used is 5950."
#~ msgstr "Å omdirigere innkomne forbindelser til skjermhåndterer, løser problemet med autentisering, fordi bare brukere med lokale kontoer vil passere innloggingsskjermen <command>gdm3</command> login screen (eller tilsvarende <command>kdm</command>, <command>xdm</command>, etc.). Ettersom denne operasjonen tillater flere samtidige pålogginger uten problem (forutsatt at tjenermaskinen er kraftig nok), kan den også brukes til å tilby komplette skrivebord til mobile brukere (eller til mindre kraftige stasjonære systemer, satt opp som tynne klienter). Brukere logger bare inn på tjenermaskinens skjerm med <command>vncviewer <replaceable>server</replaceable>:50</command>, fordi den benyttede porten er 5950."

#~ msgid "<primary>rights</primary>"
#~ msgstr "<primary>rettigheter</primary>"

#~ msgid "<primary>umask</primary>"
#~ msgstr "<primary>umask</primary>"

#~ msgid "<primary><command>debconf</command></primary>"
#~ msgstr "<primary><command>debconf</command></primary>"

#~ msgid "<primary>pipe, named pipe</primary>"
#~ msgstr "<primary>kanal (pipe), navngitt kanal</primary>"

#~ msgid "The following example illustrates the most common cases:"
#~ msgstr "Følgende eksempel illustrerer de mest vanlige tilfellene:"

#~ msgid ""
#~ "talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
#~ "finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
#~ "ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"
#~ msgstr ""
#~ "talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
#~ "finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
#~ "ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"

#~ msgid "<primary><command>warnquota</command></primary>"
#~ msgstr "<primary><command>warnquota</command></primary>"

#~ msgid "<primary><emphasis>hotplug</emphasis></primary>"
#~ msgstr "<primary><emphasis>hotplug</emphasis></primary>"

#~ msgid "<primary>power management</primary>"
#~ msgstr "<primary>strømstyring</primary>"

#~ msgid "<emphasis>IN PRACTICE</emphasis> Network card management"
#~ msgstr "<emphasis>I PRAKSIS</emphasis> Håndtering av nettverkskort"

#~ msgid "Many computers have multiple network cards (sometimes two wired interfaces and a wifi interface), and with <emphasis>hotplug</emphasis> support on most bus types, the Linux kernel does not guarantee fixed naming of network interfaces. But users who want to configure their network in <filename>/etc/network/interfaces</filename> need a fixed name!"
#~ msgstr "Mange datamaskiner har flere nettverkskort (noen ganger to kablede grensesnitt og et Wi-Fi-grensesnitt), og med <emphasis>hotplug</emphasis>-støtte til de fleste busstyper, garanterer ikke Linux-kjernen fast navngiving av nettverksgrensesnitt. Men brukere som ønsker å sette opp sine nettverk i <filename>/etc/network/interfaces</filename> trenger et fastsatt navn!"

#~ msgid "It would be difficult to ask every user to create their own <emphasis>udev</emphasis> rules to address this problem. This is why <emphasis>udev</emphasis> was configured in a rather peculiar manner; on first boot (and, more generally, each time that a new network card appears) it uses the name of the network interface and its MAC address to create new rules that will reassign the same name on subsequent boots. These rules are stored in <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>."
#~ msgstr "Det ville være vanskelig å be hver bruker om å lage sine egne <emphasis>udev</emphasis>-regler for å løse dette problemet. Dette er grunnen til at <emphasis>udev</emphasis> ble satt opp på en heller spesiell måte. Ved første oppstart (og, mer generelt, hver gang et nytt nettverkskort vises) bruker den navnet på nettverksgrensesnittet og dets MAC-adresse for å lage nye regler som vil tilordne samme navn på de påfølgende oppstartene. Disse reglene er lagret i <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>."

#~ msgid "This mechanism has some side effects that you should know about. Let's consider the case of a computer that has only one PCI network card. The network interface is named <literal>eth0</literal>, logically. Now say the card breaks down, and the administrator replaces it; the new card will have a new MAC address. Since the old card was assigned the name, <literal>eth0</literal>, the new one will be assigned <literal>eth1</literal>, even though the <literal>eth0</literal> card is gone for good (and the network will not be functional because <filename>/etc/network/interfaces</filename> likely configures an <literal>eth0</literal> interface). In this case, it is enough to simply delete the <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> file before rebooting the computer. The new card will then be given the expected <literal>eth0</literal> name."
#~ msgstr "Denne mekanismen har noen sidevirkninger som du bør vite om. La oss vurdere hvordan på en datamaskin som bare har ett PCI-nettverkskort. Nettverkets grensesnitt heter <literal>eth0</literal>, logisk. Nå, si at kortet bryter sammen, og administratoren erstatter det; det nye kortet vil ha en ny MAC-adresse. Siden det gamle kortet ble gitt navnet, <literal>eth0</literal>, vil det nye bli tildelt <literal>eth1</literal>, selv om <literal>eth0</literal>-kortet er borte for godt (og nettverket vil ikke være funksjonelt fordi <filename>/etc/network/interfaces</filename> sannsynligvis satte opp et <literal>eth0</literal>-grensesnitt). I dette tilfellet er det nok å bare slette <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>-filen før maskinen restartes. Det nye kortet vil da bli gitt det forventede <literal>eth0</literal>-navnet."
