#
# Navid Emami <me@novid.name>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2022-09-27 17:55+0200\n"
"PO-Revision-Date: 2017-05-29 16:01+0430\n"
"Last-Translator: Navid Emami <me@novid.name>\n"
"Language-Team: Persian <>\n"
"Language: fa-IR\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"

msgid "System boot"
msgstr "راه‌اندازی سیستم"

msgid "Initscripts"
msgstr "اسکریپت‌های init"

msgid "SSH"
msgstr "SSH"

msgid "Telnet"
msgstr "Telnet"

msgid "Rights"
msgstr "حقوق"

msgid "Permissions"
msgstr "مجوزها"

msgid "Supervision"
msgstr "نظارت"

msgid "Inetd"
msgstr "Inetd"

msgid "Cron"
msgstr "Cron"

msgid "Backup"
msgstr "پشتیبان‌گیری"

msgid "Hotplug"
msgstr "Hotplug"

msgid "PCMCIA"
msgstr "PCMCIA"

msgid "APM"
msgstr "APM"

msgid "ACPI"
msgstr "ACPI"

msgid "Unix Services"
msgstr "سرویس‌های یونیکس"

msgid "This chapter covers a number of basic services that are common to many Unix systems. All administrators should be familiar with them."
msgstr "این فصل به پوشش سرویس‌های پایه‌ای می‌پردازد که در بسیاری از سیستم‌های یونیکس متداول هستند. تمام مدیرسیستم‌ها باید با آن‌ها آشنا باشند."

msgid "System Boot"
msgstr "راه‌اندازی سیستم"

msgid "<primary>booting</primary><secondary>the system</secondary>"
msgstr "<primary>راه‌اندازی</primary><secondary>سیستم</secondary>"

#, fuzzy
#| msgid "<primary>SSH</primary>"
msgid "<primary>BIOS</primary>"
msgstr "<primary>SSH</primary>"

#, fuzzy
#| msgid "<primary>TAR</primary>"
msgid "<primary>MBR</primary>"
msgstr "<primary>TAR</primary>"

#, fuzzy
#| msgid "<primary>SSH</primary>"
msgid "<primary>ESP</primary>"
msgstr "<primary>SSH</primary>"

#, fuzzy
#| msgid "<primary>tunnel (SSH)</primary><seealso>VPN</seealso>"
msgid "<primary>Compatibility Support Mode</primary><see>CSM</see>"
msgstr "<primary>تونل (SSH)</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>SSH</primary>"
msgid "<primary>CSM</primary>"
msgstr "<primary>SSH</primary>"

msgid "When you boot the computer, the many messages scrolling by on the console display many automatic initializations and configurations that are being executed. Sometimes you may wish to slightly alter how this stage works, which means that you need to understand it well. That is the purpose of this section."
msgstr "زمانی که رایانه را راه‌اندازی می‌کنید، پیام‌های زیادی که در کنسول به شما نمایش داده می‌شوند نشان‌دهنده عملیات خودکار راه‌اندازی و پیکربندی سیستم هستند. شاید بعضی وقت‌ها بخواهید تغییری در این مرحله ایجاد کنید، که به معنای درک اولیه صحیح از آن است. هدف این قسمت نیز همین است."

msgid "On systems with a BIOS, first, the BIOS takes control of the computer, initializes the controllers and hardware, detects the disks, and bridges everything together. Then it looks up the <emphasis>Master Boot Record</emphasis> (MBR) of the first disk in the boot order and loads the code stored there (first stage). This code then launches the second stage and finally executes the bootloader."
msgstr ""

msgid "In contrast to the BIOS, UEFI is more sophisticated, it knows filesystems and can read the partition tables. The interface searches the system storage for a partition labeled with a specific globally unique identifier (<acronym>GUID</acronym>) that marks it as the <acronym>EFI System Partition</acronym> (<acronym>ESP</acronym>), where the bootloaders, boot managers, UEFI shell, etc., are located, and launches the desired bootloader. If Secure Boot is enabled, the boot process will verify authenticity of the EFI binaries there by signature (thus <emphasis role=\"pkg\">grub-efi-<replaceable>arch</replaceable>-signed</emphasis> is required in this case). The UEFI specification also defines support for booting in legacy BIOS mode. This is called the <emphasis>Compatibility Support Module</emphasis> (<acronym>CSM</acronym>). If CSM is enabled, it will attempt to boot from a drive's MBR. However, many new systems do no longer support the CSM mode."
msgstr ""

#, fuzzy
#| msgid "First, the BIOS takes control of the computer, detects the disks, loads the <emphasis>Master Boot Record</emphasis>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <command>init</command>. Frequently, this “root partition” and this <command>init</command> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process."
msgid "In both cases then the actual bootloader takes over, finds either a chained bootloader or the kernel on the disk, loads, and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <command>init</command>. Frequently, this “root partition” and this <command>init</command> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process."
msgstr "ابتدا، BIOS کنترل رایانه را بر عهده می‌گیرد، دیسک‌ها را شناسایی کرده، <emphasis>Master Boot Record</emphasis> را بارگیری می‌کند و به اجرای راه‌اندازسیستم می‌پردازد. راه‌اندازسیستم کنترل را بدست گرفته، کرنل را روی دیسک پیدا می‌کند، آن را بارگیری کرده سپس اجرا می‌کند. کرنل در این مرحله راه‌اندازی شده و به جستجو پارتیشن شامل فایل‌سیستم روت می‌پردازد سپس آن را متصل کرده و اولین برنامه یعنی <command>init</command> را اجرا می‌کند. به طور معمول، این “پارتیشن روت” و این برنامه <command>init</command>، در حفیقت درون یک فایل‌سیستم مجازی در حافظه اصلی به نام “initramfs”، (که سابق بر این با نام “initrd” که مخفف “Initial Ram Disk” است)، قرار دارند. این فایل‌سیستم توسط راه‌اندازسیستم درون حافظه اصلی قرار می‌گیرد، که اغلب از طریق یک فایل روی هارد درایو یا شبکه قابل دسترس است. شامل حداقل امکانات لازم برای کرنل جهت راه‌اندازی فایل‌سیستم روت “حقیقی” است: ممکن است شامل ماژول‌های درایور مورد نیاز هارد درایو، یا دستگا‌ه‌های دیگری که سیستم قادر به راه‌اندازی آن‌ها نیست، یا به طور متداول، اسکریپت‌های راه‌اندازی و ماژول‌های مورد نیاز برای پیکربندی آرایه‌های RAID، بازکردن پارتیشن‌های رمزگذاری شده، فعال‌سازی LVM و مواردی از این دست باشد. زمانی که پارتیشن روت متصل گردید، initramfs کنترل را به init حقیقی می‌سپارد و ماشین به فرآیند راه‌اندازی استاندارد خود باز می‌گردد."

msgid "The systemd init system"
msgstr "سیستم راه‌انداز systemd"

#, fuzzy
#| msgid "<primary>booting</primary><secondary>the system</secondary>"
msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">systemd</emphasis></secondary>"
msgstr "<primary>راه‌اندازی</primary><secondary>سیستم</secondary>"

msgid "The “real init” is currently provided by <emphasis role=\"pkg\">systemd</emphasis> and this section documents this init system."
msgstr "“init حقیقی” توسط <emphasis role=\"pkg\">systemd</emphasis> ارائه شده است که این قسمت به بررسی آن می‌پردازد."

msgid "<emphasis>CULTURE</emphasis> Before <command>systemd</command>"
msgstr "<emphasis>فرهنگ</emphasis> قبل از <command>systemd</command>"

msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">sysv-rc</emphasis></secondary><seealso>System V init</seealso>"
msgstr ""

#, fuzzy
#| msgid "<primary>sticky bit</primary>"
msgid "<primary>System V init</primary>"
msgstr "<primary>بیت چسبنده</primary>"

msgid "<command>systemd</command> is a relatively recent “init system”, and although it was already available, to a certain extent, in <emphasis role=\"distribution\">Wheezy</emphasis>, it has only become the default in Debian <emphasis role=\"distribution\">Jessie</emphasis>. Previous releases relied, by default, on the “System V init” (in the <emphasis role=\"pkg\">sysv-rc</emphasis> package), a much more traditional system. We describe the System V init later on."
msgstr "<command>systemd</command> یک “سیستم راه‌انداز” جدید به حساب می‌آید، با اینکه در محیط‌های گوناگونی از قبل وجود داشته است مانند <emphasis role=\"distribution\">Wheezy</emphasis>، در نسخه <emphasis role=\"distribution\">Jessie</emphasis> از دبیان بود که به عنوان پیش‌فرض انتخاب شد. انتشارهای سابق آن، به صورت پیش‌فرض، بر اساس “System V init” بودند (در بسته <emphasis role=\"pkg\">sysv-rc</emphasis>)، یک سیستم قدیمی‌تر در این زمینه. در ادامه به توضیح System V init می‌پردازیم."

msgid "<emphasis>ALTERNATIVE</emphasis> Other boot systems"
msgstr "<emphasis>جایگزین</emphasis> سایر سیستم‌های راه‌انداز"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>boot systems</primary><seealso><command>init</command></seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "This book describes the boot system used by default in Debian <emphasis role=\"distribution\">Jessie</emphasis> (as implemented by the <emphasis role=\"pkg\">systemd</emphasis> package), as well as the previous default, <emphasis role=\"pkg\">sysvinit</emphasis>, which is derived and inherited from <emphasis>System V</emphasis> Unix systems; there are others."
msgid "This book describes the boot system used by default in Debian since <emphasis role=\"distribution\">Buster</emphasis> (as implemented by the <emphasis role=\"pkg\">systemd</emphasis> package), as well as the previous default, <emphasis role=\"pkg\">sysvinit</emphasis>, which is derived and inherited from <emphasis>System V</emphasis> Unix systems; there are others."
msgstr "این کتاب به توضیح سیستم راه‌انداز موجود در دبیان <emphasis role=\"distribution\">Jessie</emphasis> می‌پردازد (که توسط بسته <emphasis role=\"pkg\">systemd</emphasis> پیاده‌سازی شده است)، به همراه نسخه پیش‌فرض قبلی، <emphasis role=\"pkg\">sysvinit</emphasis> که از سیستم‌های یونیکس <emphasis>System V</emphasis> مشتق شده است؛ گزینه‌های دیگری نیز وجود دارد."

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">upstart</emphasis></secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

#, fuzzy
#| msgid "The <command>upstart</command> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <emphasis role=\"distribution\">Jessie</emphasis>, but is not the default; it comes, in fact, as a replacement for <emphasis role=\"pkg\">sysvinit</emphasis>, and one of the tasks launched by <command>upstart</command> is to launch the scripts written for traditional systems, especially those from the <emphasis role=\"pkg\">sysv-rc</emphasis> package."
msgid "The <command>upstart</command> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, was present in Debian <emphasis role=\"distribution\">Jessie</emphasis>, but was not the default; it came, in fact, as a replacement for <emphasis role=\"pkg\">sysvinit</emphasis>, and one of the tasks launched by <command>upstart</command> was to launch the scripts written for traditional systems, especially those from the <emphasis role=\"pkg\">sysv-rc</emphasis> package."
msgstr "سیستم <command>upstart</command> هنوز به خوبی در دبیان مورد آزمون قرار نگرفته است. این سیستم، رویدادگرا است: اسکریپت‌های راه‌انداز دیگر بر اساس ترتیب سابق اجرا نمی‌شوند بلکه در پاسخ به رویدادهایی که وضعیت سیستم را تغییر می‌دهند مانند اتمام یک اسکریپت دیگر که به آن وابسته هستند. این سیستم، که توسط اوبونتو آغاز گردید، در دبیان <emphasis role=\"distribution\">Jessie</emphasis> موجود است، اما گزینه پیش‌فرض آن نیست؛ در حقیقت، به عنوان جایگزینی برای <emphasis role=\"pkg\">sysvinit</emphasis> مطرح می‌شود و یکی از وظایف <command>upstart</command> اجرای اسکریپت‌های نوشته شده برای سیستم‌های قدیمی‌تر است، به خصوص آن‌هایی که به بسته <emphasis role=\"pkg\">sysv-rc</emphasis> تعلق دارند."

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">openrc</emphasis></secondary>"
msgstr "<primary>ورود</primary><secondary>ورود از راه‌دور</secondary>"

msgid "<command>openrc</command> is a dependency based service manager. It was originally written for the Gentoo project, but it aims at being platform agnostic. It maintains compatibility with the System V init system and provides support for booting, changing runlevels, starting and stopping services (in parallel), and shutting down."
msgstr ""

#, fuzzy
#| msgid "There are also other systems and other operating modes, such as <command>runit</command> or <command>minit</command>, but they are relatively specialized and not widespread."
msgid "There are also other systems and other operating modes, such as <command>file-rc</command>, <command>runit</command>, or <command>minit</command>, but some of them are relatively specialized and not widespread."
msgstr "سیستم‌های راه‌انداز دیگری مانند <command>runit</command> یا <command>minit</command> وجود دارند، اما بسیار خاص منظوره طراحی شده‌اند و از این رو عمومیت ندارند."

msgid "Boot sequence of a computer running Linux with systemd"
msgstr "ترتیب اجرای عملیات راه‌اندازی در لینوکس به همراه systemd"

msgid "<emphasis>SPECIFIC CASE</emphasis> Booting from the network"
msgstr "<emphasis>مورد خاص</emphasis> راه‌اندازی از طریق شبکه"

#, fuzzy
#| msgid "In some configurations, the BIOS may be configured not to execute the MBR, but to seek its equivalent on the network, making it possible to build computers without a hard drive, or which are completely reinstalled on each boot. This option is not available on all hardware and it generally requires an appropriate combination of BIOS and network card."
msgid "In some configurations, the system may be configured not to execute code from the physical hardware, but to seek its equivalent on the network, making it possible to build computers without a hard drive, or which are completely reinstalled on each boot. This option is not available on all hardware and it generally requires an appropriate combination of firmware and network card."
msgstr "در برخی پیکربندی‌ها، BIOS طوری تنظیم می‌شود که نه تنها به دنبال MBR باشد، بلکه معادل آن را از روی شبکه پیدا کند، که اینکار امکان راه‌اندازی رایانه‌های بدون هارد درایو را فراهم می‌کند یا آن‌هایی که به طور کامل در هر مرتبه راه‌اندازی از نو نصب می‌گردند. این گزینه در تمام سخت‌افزارها موجود نیست و به یک ترکیب مناسب از BIOS و کارت شبکه نیاز دارد."

msgid "Booting from the network can be used to launch the <command>debian-installer</command> or FAI (see <xref linkend=\"sect.installation-methods\" />)."
msgstr "راه‌اندازی از طریق شبکه می‌تواند به اجرای <command>debian-installer</command> یا FAI (قسمت <xref linkend=\"sect.installation-methods\" /> را مشاهده کنید) ختم گردد."

msgid "<emphasis>BACK TO BASICS</emphasis> The process, a program instance"
msgstr "<emphasis>بازگشت به مقدمات</emphasis> فرآیند، نمونه یک برنامه"

msgid "<primary>process</primary>"
msgstr "<primary>فرآیند</primary>"

#, fuzzy
#| msgid "A process is the representation in memory of a running program. It includes all of the information necessary for the proper execution of the software (the code itself, but also the data that it has in memory, the list of files that it has opened, the network connections it has established, etc.). A single program may be instantiated into several processes, not necessarily running under different user IDs."
msgid "A process is the representation of a running program in memory. It includes all of the information necessary for the proper execution of the software (the code itself, but also the data that it has in memory, the list of files that it has opened, the network connections it has established, etc.). A single program may be instantiated into several processes, not necessarily running under different user IDs."
msgstr "یک فرآیند نماد اجرایی یک برنامه داخل حافظه است. شامل تمام اطلاعات لازم برای اجرای صحیح نرم‌افزار می‌باشد (کد برنامه، به همراه داده‌هایی که حافظه اشغال کرده‌اند، فهرست فایل‌هایی که باز کرده است، اتصلات شبکه‌ای که برقرار کرده است و از این قبیل). یک برنامه می‌تواند شامل چندین فرآیند باشد، که الزاما توسط شناسه کاربری‌های متفاوت اجرا نمی‌شوند."

msgid "<emphasis>SECURITY</emphasis> Using a shell as <command>init</command> to gain root rights"
msgstr "<emphasis>امنیت</emphasis> استفاده از پوسته‌ای مانند <command>init</command> به منظور دسترسی به مجوزهای root"

msgid "By convention, the first process that is booted is the <command>init</command> program (which is a symbolic link to <filename>/lib/systemd/systemd</filename> by default). However, it is possible to pass an <literal>init</literal> option to the kernel indicating a different program."
msgstr "بر اساس قرارداد، اولین برنامه‌ای که اجرا می‌شود <command>init</command> نام دارد (که یک پیوند نمادین به فایل <filename>/lib/systemd/systemd</filename> است). اگرچه، امکان ارسال گزینه <literal>init</literal> به کرنل با نام برنامه‌ای دیگر وجود دارد."

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "Any person who is able to access the computer can press the <keycap>Reset</keycap> button, and thus reboot it. Then, at the bootloader's prompt, it is possible to pass the <literal>init=/bin/sh</literal> option to the kernel to gain root access without knowing the administrator's password."
msgstr "هر فردی که قابلیت دسترسی به رایانه را دارد می‌تواند دکمه <keycap>Reset</keycap> را فشار دهد و آن را راه‌اندازی مجدد نماید. آنگاه در صفحه راه‌اندازسیستم، امکان ارسال گزینه <literal>init=/bin/sh</literal> به کرنل جهت دسترسی به حساب کاربری root بدون گذرواژه فراهم می‌آید."

msgid "To prevent this, you can protect the bootloader itself with a password. You might also think about protecting access to the BIOS (a password protection mechanism is almost always available), without which a malicious intruder could still boot the machine on a removable media containing its own Linux system, which they could then use to access data on the computer's hard drives."
msgstr "برای جلوگیری از آن، می‌توانید راه‌اندازسیستم را با یک گذرواژه محافظت کنید. همچنین ممکن است بخواهید از BIOS نیز مراقبت کنید (یک مکانیزم محافظت با گذرواژه همیشه موجود است)، که بدون آن یک عامل نفوذی می‌تواند به سادگی سیستم را از طریق یک حافظه جانبی که شامل سیستم لینوکس خودش است راه‌اندازی کند، که از طریق آن می‌تواند به اطلاعات موجود روی هارد درایوها دسترسی داشته باشد."

#, fuzzy
#| msgid "Finally, be aware that most BIOS have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…"
msgid "Finally, be aware that most BIOS/EFI implementations have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…"
msgstr "در نهایت، آگاه باشید که اکثر BIOSها یک گذرواژه متداول دارند. به منظور عیب‌یابی برای افرادی که گذرواژه خود را فراموش می‌کنند، این گذزواژه‌ها عمومی بوده و در اینترنت موجود هستند (جستجوی عبارت “generic BIOS passwords” در یک موتور جستجو). تمام این عملیات محافظتی به منظور مانع شدن از دسترسی غیرمجاز به سیستم است. هیچ روش شناخته‌شده‌ای به منظور محافظت از رایانه وجود ندارد مادامی که مهاجم بتواند به آن دسترسی فیزیکی داشته باشد؛ آن‌ها می‌توانند هارد درایو را از جای خود کنده و با خود ببرند، یا حتی کل ماشین فیزیکی را بدزدند، یا جافظه BIOS را به منظور از بین رفتن گذرواژه پاک کنند."

#, fuzzy
#| msgid "Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> pairs grouped between <literal>[<replaceable>section</replaceable>]</literal> headers. Unit files are stored under <filename>/lib/systemd/system/</filename> and <filename>/etc/systemd/system/</filename>; they come in several flavours, but we will focus on “services” and “targets” here."
msgid "Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> pairs grouped between <literal>[<replaceable>section</replaceable>]</literal> headers. Unit files are stored under <filename>/lib/systemd/system/</filename> and <filename>/etc/systemd/system/</filename>; they come in several flavors, but we will focus on “services” and “targets” here."
msgstr "... فرآیندهای بسیاری را اجرا می‌کند، که مسئول راه‌اندازی سیستم هستند: صفحه‌کلید، درایورها، فایل‌سیستم‌ها، شبکه، سرویس‌ها. این عملیات را هنگامی که کل سیستم را تحت نظر دارد اجرا می‌کند و به بررسی پیش‌نیازهای هر یک می‌پردازد. هر جزء توسط یک “unit file” توضیح داده می‌شود (بعضی وقت‌ها بیشتر)؛ شیوه نگارش آن بر اساس قالب شناخته‌شده “*.ini files“ است، به همراه جفت مقادیر <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> که در بین سرآیندهای <literal>[<replaceable>section</replaceable>]</literal> گروه‌بندی شده‌اند. این فایل‌ها در مسیر <filename>/lib/systemd/system/</filename> و <filename>/etc/systemd/system/</filename> ذخیره‌سازی شده‌اند؛ آن‌ها به شیوه‌های گوناگونی وجود دارند که در اینجا به بررسی “سرویس‌ها” و “اهداف” می‌پردازیم."

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.service</filename> file</secondary>"
msgstr "<primary>مدیر</primary><secondary>مدیر نمایش</secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/systemd/system/</filename></secondary><see><command>systemd</command></see>"
msgstr ""

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>service</primary><secondary><filename>ssh.service</filename></secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

#, fuzzy
#| msgid "A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:"
msgid "A systemd “<filename>.service</filename> file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:"
msgstr "یک “فایل سرویس” از systemd به یک فرآیند قابل مدیریت توسط آن را توضیح می‌دهد. تقریبا همان اطلاعات اسکریپت‌های قدیمی init را دارا هستند اما به شیوه‌ای نوین و مختصر بیان شده است. systemd عمده فعالیت‌های تکراری را بر عهده می‌گیرد (آغاز و پایان یک فرآیند، بررسی وضعیت آن، گزارش‌گیری، بررسی مجوزها و از این قبیل) و فایل سرویس تنها لازم دارد موارد خاص آن فرآیند را بیان کند. برای نمونه، در اینجا نمونه‌ای از فایل سرویس مربوط به SSH را می‌بینیم:"

#, fuzzy
#| msgid ""
#| "[Unit]\n"
#| "Description=OpenBSD Secure Shell server\n"
#| "After=network.target auditd.service\n"
#| "ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
#| "\n"
#| "[Service]\n"
#| "EnvironmentFile=-/etc/default/ssh\n"
#| "ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
#| "ExecReload=/bin/kill -HUP $MAINPID\n"
#| "KillMode=process\n"
#| "Restart=on-failure\n"
#| "\n"
#| "[Install]\n"
#| "WantedBy=multi-user.target\n"
#| "Alias=sshd.service"
msgid ""
"[Unit]\n"
"Description=OpenBSD Secure Shell server\n"
"Documentation=man:sshd(8) man:sshd_config(5)\n"
"After=network.target auditd.service\n"
"ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
"\n"
"[Service]\n"
"EnvironmentFile=-/etc/default/ssh\n"
"ExecStartPre=/usr/sbin/sshd -t\n"
"ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
"ExecReload=/usr/sbin/sshd -t\n"
"ExecReload=/bin/kill -HUP $MAINPID\n"
"KillMode=process\n"
"Restart=on-failure\n"
"RestartPreventExitStatus=255\n"
"Type=notify\n"
"RuntimeDirectory=sshd\n"
"RuntimeDirectoryMode=0755\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target\n"
"Alias=sshd.service"
msgstr ""
"[Unit]\n"
"Description=OpenBSD Secure Shell server\n"
"After=network.target auditd.service\n"
"ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
"\n"
"[Service]\n"
"EnvironmentFile=-/etc/default/ssh\n"
"ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
"ExecReload=/bin/kill -HUP $MAINPID\n"
"KillMode=process\n"
"Restart=on-failure\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target\n"
"Alias=sshd.service"

msgid "The <literal>[Unit]</literal> section contains generic information about the service, like its description and manual page resources, as well as relations (dependency and order) to other services. The <literal>[Service]</literal> part contains the declarations related to the service execution (starting, stopping, killing, restarting), directories and configuration file(s) used. The last section, <literal>[Install]</literal>, again carries generic information into which targets to install the service and, in this case, the alias that can be used instead of the service name. As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed. The syntax of these files is fully described in several manual pages (e.g. <citerefentry><refentrytitle>systemd.service</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>systemd.unit</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>systemd.exec</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, etc.)."
msgstr ""

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.target</filename> file</secondary>"
msgstr "<primary>مدیر</primary><secondary>مدیر نمایش</secondary>"

#, fuzzy
#| msgid "A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <literal>local-fs.target</literal>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <literal>network-online.target</literal> and <literal>sound.target</literal>. The dependencies of a target can be listed either within the target file (in the <literal>Requires=</literal> line), or using a symbolic link to a service file in the <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> directory. For instance, <filename>/etc/systemd/system/printer.target.wants/</filename> contains a link to <filename>/lib/systemd/system/cups.service</filename>; systemd will therefore ensure CUPS is running in order to reach <literal>printer.target</literal>."
msgid "A systemd “<filename>.target</filename> file” describes a state of the system where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the pre-defined targets is <literal>local-fs.target</literal>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <literal>network-online.target</literal> and <literal>sound.target</literal> (for a full list of special targets see <citerefentry><refentrytitle>systemd.special</refentrytitle> <manvolnum>7</manvolnum></citerefentry>). The dependencies of a target can be listed either within the target file (in the <literal>Requires=</literal> line), or using a symbolic link to a service file in the <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> directory. For instance, <filename>/etc/systemd/system/printer.target.wants/</filename> contains a link to <filename>/lib/systemd/system/cups.service</filename>; systemd will therefore ensure CUPS is running in order to reach <literal>printer.target</literal>."
msgstr "یک “فایل هدف” از systemd به تشریح وضعیت یک سیستم می‌پردازد، که در آن مجموعه‌ای از سرویس‌ها اعمال می‌شوند. این فایل می‌تواند به عنوان معادل قدیمی runlevel فرض شود. یکی از اهداف <literal>local-fs.target</literal> است؛ زمانی که محقق گردد، باقی سیستم می‌توانند تصور کنند که تمام فایل‌سیستم‌های محلی متصل شده و قابل دسترس هستند. سایر اهداف شامل <literal>network-online.target</literal> و <literal>sound.target</literal> می‌شوند. وابستگی‌های یک هدف می‌توانند درون فایل آن نوشته شوند (در خط <literal>Requires=</literal>) یا از یک پیوند نمادین به یک فایل سرویس در دایرکتوری <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> استفاده شوند. برای نمونه، <filename>/etc/systemd/system/printer.target.wants/</filename> شامل پیوندی به <filename>/lib/systemd/system/cups.service</filename> است؛ systemd اطمینان می‌یابد که برای دسترسی به <literal>printer.target</literal> ابتدا CUPS باید اجرا گردد."

msgid "Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component."
msgstr "از آنجا که فایل‌های واحد بر خلاف اسکریپت‌ها یا برنامه‌ها جنبه بیانی دارند، به طور مستقیم قابل اجرا نیستند و تنها توسط systemd تفسیر می‌گردند؛ برخی ابزارهای جانبی این امکان را به مدیرسیستم می‌دهند که به صورت تعاملی با systemd برخورد کرده و هر یک از اجزای آن را مدیریت کنند."

msgid "<primary><command>systemd</command></primary><secondary><command>systemctl</command></secondary><see><command>systemctl</command></see>"
msgstr ""

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>status</literal></secondary>"
msgstr "<primary>مالک</primary><secondary>کاربر</secondary>"

msgid "The first such utility is <command>systemctl</command>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <command>systemctl status</command> gives a better view of the services, as well as the related processes. If given the name of a service (as in <command>systemctl status ntp.service</command>), it returns even more details, as well as the last few log lines related to the service (more on that later)."
msgstr "اولین ابزار در این زمینه <command>systemctl</command> نام دارد. زمانی که بدون هیچ پارامتری اجرا گردد، به فهرست کردن تمام فایل‌های واحد شناخته‌شده برای systemd می‌پردازد (به جز آن‌هایی که غیرفعال شده‌اند) به همراه وضعیت هر کدام. <command>systemctl status</command> دید مناسب‌تری از سرویس‌ها را ارائه می‌دهد، به همراه فرآیندهای مربوط به هر کدام. اگر نام یک سرویس نیز داده شود (مانند <command>systemctl status ntp.service</command>) جزئیات بیشتری نیز نمایش داده می‌شود به همراه آخرین خطوط گزارش مرتبط با آن (که بعدا به آن می‌رسیم)."

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>start</literal></secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>stop</literal></secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

#, fuzzy
#| msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>reload</literal></secondary>"
msgstr "<primary>ماژول‌ها</primary><secondary>ماژول‌های کرنل</secondary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>restart</literal></secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

msgid "Starting a service by hand is a simple matter of running <command>systemctl start <replaceable>servicename</replaceable>.service</command>. As one can guess, stopping the service is done with <command>systemctl stop <replaceable>servicename</replaceable>.service</command>; other subcommands include <command>reload</command> and <command>restart</command>."
msgstr "شروع یک سرویس به صورت دستی به سادگی اجرای دستور <command>systemctl start <replaceable>servicename</replaceable>.service</command> است. همانطور که حدس زدید، توقف سرویس با استفاده از <command>systemctl stop <replaceable>servicename</replaceable>.service</command> صورت می‌گیرد؛ سایر دستورات زیر-مجموعه عبارتند از <command>reload</command> و <command>restart</command>."

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>enable</literal></secondary>"
msgstr "<primary>کلاینت</primary><secondary>معماری کلاینت/سرور</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>disable</literal></secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>is-enabled</literal></secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

msgid "To control whether a service is active (i.e. whether it will get started automatically on boot), use <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (or <command>disable</command>). <command>is-enabled</command> allows checking the status of the service."
msgstr "به منظور اطلاع از فعال‌بودن یک سرویس (خواه در زمان راه‌اندازی سیستم اجرا شده باشد یا خیر) از دستور <command>systemctl enable <replaceable>servicename</replaceable>.service</command> استفاده کنید (یا <command>disable</command>). <command>is-enabled</command> برای بررسی وضعیت سرویس بکار می‌رود."

msgid "<primary><command>systemd</command></primary><secondary><command>journald</command></secondary><see><command>journald</command></see>"
msgstr ""

msgid "<primary><command>systemd</command></primary><secondary><command>journalctl</command></secondary><see><command>journalctl</command></see>"
msgstr ""

#, fuzzy
#| msgid "<primary><command>atd</command></primary>"
msgid "<primary><command>journald</command></primary>"
msgstr "<primary><command>atd</command></primary>"

#, fuzzy
#| msgid "<primary><command>rsyslogd</command></primary>"
msgid "<primary><command>syslogd</command></primary>"
msgstr "<primary><command>rsyslogd</command></primary>"

#, fuzzy
#| msgid "<primary><command>at</command></primary>"
msgid "<primary><command>journalctl</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "An interesting feature of systemd is that it includes a logging component named <command>journald</command>. It comes as a complement to more traditional logging systems such as <command>syslogd</command>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <command>journalctl</command> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:"
msgid "An interesting feature of systemd is that it includes a logging component named <command>journald</command>. It comes as a complement to more traditional logging systems such as <command>syslogd</command>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialization sequence. The messages can be displayed later on, with a little help from the <command>journalctl</command> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:"
msgstr "یک ویژگی جالب از systemd افزودن یک جزء به نام <command>journald</command> است. به عنوان یک مکمل برای سیستم‌های گزارش‌گیری قدیمی‌تر مانند <command>syslogd</command> به حساب می‌آید که ویژگی‌های جالبی مانند افزودن یک پیوند رسمی بین سرویس و پیام‌هایی که تولید می‌کند یا قابلیت دریافت پیام‌های خطای تولید شده توسط ترتیب اولیه آن‌ها را شامل می‌شود. پیام‌ها در ادامه می‌توانند نمایش داده شوند، با اندکی کمک از دستور <command>journalctl</command>. بدون هیچ پارامتری، به تشریخ تمام پیام‌های لاگ که از راه‌اندازی سیستم دریافت کرده است می‌پردازد؛ البته به این شکل کمتر استفاده می‌شود. در اکثر موارد، به همراه شناسه یک سرویس بکار می‌رود:"

msgid ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"

msgid "Another useful command-line flag is <command>-f</command>, which instructs <command>journalctl</command> to keep displaying new messages as they are emitted (much in the manner of <command>tail -f <replaceable>file</replaceable></command>)."
msgstr "گزینه جالب دیگر در خط-فرمان <command>-f</command> است که به <command>journalctl</command> می‌گوید به نمایش پیام‌های جدید اضافه‌شده به انتهای فایل بپردازد (مانند عملکردی که <command>tail -f <replaceable>file</replaceable></command> دارد)."

msgid "If a service doesn't seem to be working as expected, the first step to solve the problem is to check that the service is actually running with <command>systemctl status</command>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:"
msgstr "اگر سرویس عملکرد مورد نظر را نداشته باشد، اولین مرحله عیب‌یابی این است که بدانیم آیا سرویس اجرا شده است یا خیر با استفاده از دستور <command>systemctl status</command>؛ اگر اجرا نشده بود و پیام‌های دستور اول به عیب‌یابی مشکل کمکی نکرد، به بررسی گزارش‌های تهیه شده توسط journald مرتبط با آن سرویس بپردازید. برای نمونه، تصور کنید که سرویس SSH کار نمی‌کند:"

msgid ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"

msgid "After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running."
msgstr "پس از بررسی وضعیت سرویس (failed)، به بررسی فایل‌های گزارش پرداختیم؛ آن‌ها نشان دادند که یک خطا در فایل پیکربندی وجود دارد. پس از ویرایش فایل پیکربندی و اصلاح خطا، سرویس را راه‌اندازی مجدد کردیم و دیدیم که به درستی کار می‌کند."

msgid "<emphasis>GOING FURTHER</emphasis> Other types of unit files"
msgstr "<emphasis>مطالعه بیشتر</emphasis> سایر انواع فایل‌های واحد"

msgid "We have only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we will only list a few here:"
msgstr "در این قسمت به ساده‌ترین قابلیت‌های systemd اشاره کردیم. اما ویژگی‌های جالب دیگری را نیز ارائه می‌دهد که در اینجا فقط برخی از آن‌ها را نام می‌بریم:"

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.socket</filename> file</secondary>"
msgstr "<primary>مدیر</primary><secondary>مدیر نمایش</secondary>"

#, fuzzy
#| msgid "socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <command>inetd</command>. See <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgid "socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <command>inetd</command>. See <citerefentry><refentrytitle>systemd.socket</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."
msgstr "فعال‌سازی سوکت: یک فایل واحد “سوکت” می‌تواند به منظور شرح یک شبکه یا سوکت یونیکس که توسط systemd مدیریت می‌شود بکار رود؛ این بدان معناست که سوکت توسط systemd ایجاد می‌شود و سرویس حقیقی تنها زمانی که درخواستی برای آن مطرح گردد آغاز می‌شود. این عملکرد نزدیک به <command>inetd</command> است. <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry> را مشاهده کنید."

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.timer</filename> file</secondary>"
msgstr "<primary>مدیر</primary><secondary>مدیر نمایش</secondary>"

#, fuzzy
#| msgid "timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <command>cron</command> features. See <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgid "timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <command>cron</command> features. See <citerefentry><refentrytitle>systemd.timer</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."
msgstr "زمانسنج‌ها: یک فایل واحد “زمانسنج” وقایعی را شرح می‌دهد که در یک بازه زمانی ثابت یا زمان‌های مشخص تکرار می‌شوند؛ زمانی که یک سرویس به چنین زمانسنجی متصل گردد، فعالیت مرتبط با آن هنگام واکنش زمانسنج آغاز می‌گردد. این عملکرد نزدیک به <command>cron</command> است. <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry> را مشاهده کنید."

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.network</filename> file</secondary>"
msgstr "<primary>مدیر</primary><secondary>مدیر نمایش</secondary>"

#, fuzzy
#| msgid "network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up."
msgid "network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up. See <citerefentry><refentrytitle>systemd.network</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."
msgstr "شبکه: یک فایل واحد “شبکه“ به توضیح یک رابط شبکه می‌پردازد که امکان پیکربندی چنین رابطی را فراهم آورده و همچنین بیان می‌کند کدام سرویس وابسته به این رابط خواهد بود."

msgid "The System V init system"
msgstr "سیستم راه‌انداز System V"

#, fuzzy
#| msgid "The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <filename>/etc/inittab</filename> file. The first program that is executed (which corresponds to the <emphasis>sysinit</emphasis> step) is <command>/etc/init.d/rcS</command>, a script that executes all of the programs in the <filename>/etc/rcS.d/</filename> directory. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>"
msgid "The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <filename>/etc/inittab</filename> file. The first program that is executed (which corresponds to the <emphasis>sysinit</emphasis> step) is <command>/etc/init.d/rcS</command>, a script that executes all of the programs in the <filename>/etc/rcS.d/</filename> directory."
msgstr "سیستم راه‌انداز System V (که به اختصار init می‌نامیم) چندین فرآیند را اجرا می‌کند، که دستورالعمل‌های آن در فایل <filename>/etc/inittab</filename> آمده است. اولین برنامه‌ای که اجرا می‌شود (که معادل با گام <emphasis>sysinit</emphasis> است) برابر با <command>/etc/init.d/rcS</command> است، اسکریپتی که سایر برنامه‌های موجود در دایرکتوری <filename>/etc/rcS.d/</filename> را اجرا می‌کند. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/init.d/rcS</filename></secondary><seealso><emphasis role=\"pkg\">sysv-rc</emphasis></seealso>"
msgstr ""

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rcS.d/</filename></secondary><seealso><emphasis role=\"pkg\">sysv-rc</emphasis></seealso>"
msgstr ""

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>rcS</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>rcS.d</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

msgid "Among these, you will find successively programs in charge of:"
msgstr "در میان آن‌ها، برنامه‌های پی‌در‌پی مرتبطی پیدا خواهید کرد:"

msgid "configuring the console's keyboard;"
msgstr "پیکربندی صفحه‌کلید کنسول؛"

msgid "loading drivers: most of the kernel modules are loaded by the kernel itself as the hardware is detected; extra drivers are then loaded automatically when the corresponding modules are listed in <filename>/etc/modules</filename>;"
msgstr "بارگیری درایورها: اکثر ماژول‌های کرنل توسط خودش هنگام شناسایی سخت‌افزار بارگیری می‌شوند؛ درایورهای اضافی به صورت خودکار زمانی که ماژول مربوطه در فایل <filename>/etc/modules</filename> قرار گیرد بارگیری می‌شوند."

#, fuzzy
#| msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modules</filename></secondary>"
msgstr "<primary>ماژول‌ها</primary><secondary>ماژول‌های کرنل</secondary>"

msgid "checking the integrity of filesystems;"
msgstr "بررسی جامعیت فایل‌سیستم‌ها؛"

msgid "mounting local partitions;"
msgstr "متصل‌کردن پارتیشن‌های محلی؛"

msgid "configuring the network;"
msgstr "پیکربندی شبکه؛"

msgid "mounting network filesystems (NFS)."
msgstr "متصل‌کردن فایل‌سیستم‌های شبکه یا NFS."

msgid "<emphasis>BACK TO BASICS</emphasis> Kernel modules and options"
msgstr "<emphasis>بازگشت به مقدمات</emphasis> ماژول‌های کرنل و گزینه‌های آن‌ها"

msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgstr "<primary>ماژول‌ها</primary><secondary>ماژول‌های کرنل</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>kernel</primary><secondary>modules</secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "<primary>kernel</primary><secondary>modules</secondary><tertiary>load</tertiary><seealso><command>modprobe</command></seealso>"
msgstr ""

msgid "<primary>kernel</primary><secondary>modules</secondary><tertiary>options</tertiary><seealso><command>modinfo</command></seealso>"
msgstr ""

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modprobe.d</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

#, fuzzy
#| msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modules-load.d/</filename></secondary>"
msgstr "<primary>ماژول‌ها</primary><secondary>ماژول‌های کرنل</secondary>"

#, fuzzy
#| msgid "Kernel modules also have options that can be configured by putting some files in <filename>/etc/modprobe.d/</filename>. These options are defined with directives like this: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. Several options can be specified with a single directive if necessary."
msgid "You have already learned that kernel modules can be loaded during the start of the system by adding them to <filename>/etc/modules</filename> or a file below <filename>/etc/modules-load.d/</filename>. But modules can also have options that can be configured by putting some files in <filename>/etc/modprobe.d/</filename>. These options are defined with directives like this: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. Several options can be specified with a single directive if necessary."
msgstr "ماژول‌های کرنل دارای گزینه‌هایی هستند که می‌توانند با قرار گرفتن در مسیر <filename>/etc/modprobe.d/</filename> پیکربندی شوند. این گزینه‌ها با دستوراتی این چنین تعریف می‌شوند: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. چندین گزینه در صورت لزوم می‌توانند تنها با یک دستور تعریف شوند."

#, fuzzy
#| msgid "These configuration files are intended for <command>modprobe</command> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). This program is provided by the <emphasis role=\"pkg\">kmod</emphasis> package."
msgid "These configuration files are intended for <command>modprobe</command> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). To list all options of a module use the <command>modinfo -p <replaceable>module</replaceable></command> command. Both programs are provided by the <emphasis role=\"pkg\">kmod</emphasis> package together with other tools to handle modules."
msgstr "این فایل‌های پیکربندی برای <command>modprobe</command> در نظر گرفته شده‌اند - برنامه‌ای که یک ماژول کرنل به همراه وابستگی‌هایش را بارگیری می‌کند (ماژول‌ها می‌توانند یکدیگر را فراخوانی کنند). این برنامه توسط بسته <emphasis role=\"pkg\">kmod</emphasis> ارائه می‌شود."

msgid "<primary><command>modprobe</command></primary>"
msgstr "<primary><command>modprobe</command></primary>"

#, fuzzy
#| msgid "<primary><command>diff</command></primary>"
msgid "<primary><command>modinfo</command></primary>"
msgstr "<primary><command>diff</command></primary>"

msgid "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"

msgid "Having learned about systemd, services and targets can use the <filename>modprobe@<replaceable>module</replaceable>.service</filename> to load kernel modules they depend on."
msgstr ""

#, fuzzy
#| msgid "<primary>server</primary><secondary>client/server architecture</secondary>"
msgid "<primary>service</primary><secondary><filename>modprobe@<replaceable>module</replaceable>.service</filename></secondary>"
msgstr "<primary>سرور</primary><secondary>معماری کلاینت/سرور</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/init.d/rc</filename></secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rcX.d/</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

#, fuzzy
#| msgid "<primary><command>inetd</command></primary>"
msgid "<primary><command>insserv</command></primary>"
msgstr "<primary><command>inetd</command></primary>"

msgid "After this stage, <command>init</command> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <command>/etc/init.d/rc 2</command>, a script that starts all services which are listed in <filename>/etc/rc2.d/</filename> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <command>insserv</command>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <command>init</command> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <command>rsyslog</command>, or port assignment with <command>portmap</command>) are started first, followed by standard services and the graphical interface (<command>gdm3</command>)."
msgstr "پس از این گام، <command>init</command> وارد می‌شود و برنامه‌های فعال‌شده در runlevel پیش‌فرض (که معمولا شماره ۲ است) را آغاز می‌کند. به اجرای <command>/etc/init.d/rc 2</command> می‌پردازد، اسکریپتی که تمام سرویس‌های موجود در <filename>/etc/rc2.d/</filename> که با حرف “S” شروع می‌شوند را آغاز می‌کند. عدد دو رقمی که بعد از نام هر سرویس قرار دارد ترتیب اجرای آن‌ها را مشخص می‌کند، اما امروزه سیستم راه‌انداز پیش‌فرض از <command>insserv</command> به این منظور استفاده می‌کند، که تمام مراحل را با توجه به وابستگی‌های بین اسکریپت‌ها زمان‌بندی می‌کند. هر اسکریپت راه‌انداز شرایط مربوط به خود جهت اَغاز یا پایان سرویس را توصیف می‌کند (برای نمونه، اگر باید قبل یا بعد از یک سرویس دیگر آغاز گردد)؛ <command>init</command> سپس به اجرای آن‌ها با توجه به شرایط موجود می‌پردازد. بنابراین شماره‌گذاری ایستا که در اسکریپت‌ها استفاده می‌شد دیگر به حساب نمی‌آید (اما آن‌ها باید نامی که با “S” شروع می‌شود به همراه عدد دو رقمی و نام حقیقی سرویس را به همراه داشته باشند). در حالت کلی، سرویس‌های پایه (مانند گزارش‌گیری با <command>rsyslog</command> یا تخصیص پورت با <command>portmap</command>) در ابتدا آعاز می‌گردند به همراه سرویس‌های استاندارد و رابط گرافیکی (<command>gdm3</command>)."

msgid "This dependency-based boot system makes it possible to automate re-numbering, which could be rather tedious if it had to be done manually, and it limits the risks of human error, since scheduling is conducted according to the parameters that are indicated. Another benefit is that services can be started in parallel when they are independent from one another, which can accelerate the boot process."
msgstr "این سیستم راه‌انداز مبتنی بر وابستگی‌ها امکان شماره‌گذاری مجدد را فراهم می‌کند، کاری که در حالت دستی دشواری‌های فراوانی دارد و امکان خطای انسانی را کاهش می‌دهد چرا که زمان‌بندی مختص به پارامترهای مشخص شده می‌باشد. مزیت دیگر آن این است که سرویس‌ها می‌توانند به صورت موازی آغاز شوند زمانی که به یکدیگر وابسته نیستند، که این امر به فرآیند راه‌اندازی سرعت می‌بخشد."

msgid "<primary>runlevel</primary>"
msgstr "<primary>runlevel</primary>"

msgid "<primary>level, runlevel</primary>"
msgstr "<primary>سطح، سطح‌اجرایی</primary>"

#, fuzzy
#| msgid "<primary><command>telnet</command></primary>"
msgid "<primary><command>telinit</command></primary>"
msgstr "<primary><command>telnet</command></primary>"

msgid "<command>init</command> distinguishes several runlevels, so it can switch from one to another with the <command>telinit <replaceable>new-level</replaceable></command> command. Immediately, <command>init</command> executes <command>/etc/init.d/rc</command> again with the new runlevel. This script will then start the missing services and stop those that are no longer desired. To do this, it refers to the content of the <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (where <replaceable>X</replaceable> represents the new runlevel). Scripts starting with “S” (as in “Start”) are services to be started; those starting with “K” (as in “Kill”) are the services to be stopped. The script does not start any service that was already active in the previous runlevel."
msgstr "... قابلیت شناسایی چندین runlevel را دارد، پس می‌تواند بین آن‌ها با استفاده از دستور <command>telinit <replaceable>new-level</replaceable></command> جابجا شود. بلافاصله، <command>init</command> به اجرای <command>/etc/init.d/rc</command> با runlevel جدید می‌پردازد. این اسکریپت به اجرای سرویس‌های مفقود و توقف آن‌هایی که دیگر مورد نیاز نیستند می‌پردازد. به این منظور، به محتوای موجود در مسیر <filename>/etc/rc<replaceable>X</replaceable>.d</filename> ارجاع می‌کند (که <replaceable>X</replaceable> نشان‌دهنده runlevel جدید است). اسکریپت‌هایی که با “S” شروع می‌شوند (به معنای “Start”) سرویس‌هایی هستند که باید آغاز گردند؛ آن‌هایی که با “K” شروع می‌شوند (به معنای “Kill”) سرویس‌هایی هستند که باید متوقف گردند. اسکریپت به اجرای سرویس فعال در runlevel قبلی نمی‌پردازد."

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>System V init</primary><secondary>runlevels</secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

msgid "By default, System V init in Debian uses four different runlevels:"
msgstr "به صورت پیش‌فرض، سیستم راه‌انداز System V در دبیان از چهار runlevel متفاوت استفاده می‌کند:"

msgid "Level 0 is only used temporarily, while the computer is powering down. As such, it only contains many “K” scripts."
msgstr "سطح ۰ هنگام خاموش شدن رایانه به صورت موقتی استفاده می‌شود. به همین دلیل شامل بسیاری اسکریپت‌های “K” است."

msgid "Level 1, also known as single-user mode, corresponds to the system in degraded mode; it includes only basic services, and is intended for maintenance operations where interactions with ordinary users are not desired."
msgstr "سطح ۱، که به نام حالت تک-کاربره نیز شناخته می‌شود، مطابق با سیستم در حالت عیب‌یابی است؛ تنها شامل سرویس‌های پایه است و مناسب عملیات عیب‌یابی است که تعامل با کاربران در آن مد نظر نباشد."

msgid "Level 2 is the level for normal operation, which includes networking services, a graphical interface, user logins, etc."
msgstr "سطح ۲ برای عملکرد نرمال استفاده می‌شود که شامل سرویس‌های شبکه، رابط گرافیکی، ورود کاربر و از این قبیل است."

msgid "Level 6 is similar to level 0, except that it is used during the shutdown phase that precedes a reboot."
msgstr "سطح ۶ که به سطح ۰ مشابه است تنها با این تفاوت که برای حالت راه‌اندازی مجدد رایانه استفاده می‌گردد."

msgid "Other levels exist, especially 3 to 5. By default they are configured to operate the same way as level 2, but the administrator can modify them (by adding or deleting scripts in the corresponding <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories) to adapt them to particular needs."
msgstr "سطح‌های دیگری نیز وجود دارند، به خصوص ۳ تا ۵. به صورت پیش‌فرض آن‌ها مانند سطح ۲ عمل می‌کنند، اما مدیرسیستم می‌تواند آن‌ها را تغییر دهد (با افزودن یا حذف اسکریپت‌هایی در دایرکتوری <filename>/etc/rc<replaceable>X</replaceable>.d</filename>) تا آن‌ها را برای نیازهای خاص سازگار سازد."

msgid "Boot sequence of a computer running Linux with System V init"
msgstr "ترتیب اجرای عملیات راه‌اندازی در لینوکس به همراه System V"

msgid "<primary>initialization script</primary>"
msgstr "<primary>اسکریپت راه‌اندازی</primary>"

msgid "<primary><command>update-rc.d</command></primary>"
msgstr "<primary><command>update-rc.d</command></primary>"

#, fuzzy
#| msgid "<primary><command>cron</command></primary>"
msgid "<primary><command>rcconf</command></primary>"
msgstr "<primary><command>cron</command></primary>"

#, fuzzy
#| msgid "All the scripts contained in the various <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories are really only symbolic links — created upon package installation by the <command>update-rc.d</command> program — pointing to the actual scripts which are stored in <filename>/etc/init.d/</filename>. The administrator can fine tune the services available in each runlevel by re-running <command>update-rc.d</command> with adjusted parameters. The <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <literal>remove</literal> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <command>update-rc.d</command> has a somewhat convoluted interface, you may prefer using <command>rcconf</command> (from the <emphasis role=\"pkg\">rcconf</emphasis> package) which provides a more user-friendly interface."
msgid "All the scripts contained in the various <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories are really only symbolic links — created upon package installation by the <command>update-rc.d</command> program — pointing to the actual scripts which are stored in <filename>/etc/init.d/</filename>. The administrator can fine tune the services available in each runlevel by re-running <command>update-rc.d</command> with adjusted parameters. The <citerefentry><refentrytitle>update-rc.d</refentrytitle> <manvolnum>1</manvolnum></citerefentry> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <literal>remove</literal> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <command>update-rc.d</command> has a somewhat convoluted interface, you may prefer using <command>rcconf</command> (from the <emphasis role=\"pkg\">rcconf</emphasis> package) which provides a more user-friendly interface."
msgstr "تمام اسکریپت‌های موجود در دایرکتوری‌های <filename>/etc/rc<replaceable>X</replaceable>.d</filename> تنها پیوندهای نمادین هستند - که توسط برنامه <command>update-rc.d</command> هنگام نصب یک بسته ایجاد می‌گردند - که به اسکریپت‌های اصلی ذخیره‌شده در <filename>/etc/init.d/</filename> اشاره می‌کنند. مدیرسیستم می‌تواند به بهینه‌سازی سرویس‌های موجود در هر runlevel با اجرای دستور <command>update-rc.d</command> به همراه پارامترهای لازم بپردازد. صفحه راهنمای <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> به تشریح شیوه استفاده از آن پرداخته است. به یاد داشته باشید که حذف پیوندهای نمادین (با پارامتر <literal>remove</literal>) روش خوبی برای غیرفعال‌کردن یک سرویس نیست. در عوض باید طوری پیکربندی کنید که در runlevel مورد نظر اجرا نشود (به صورتی که فراخوانی‌های مربوطه به آن از runlevel قبلی متوقف گردند). از آنجا که <command>update-rc.d</command> خود دارای رابط جداگانه‌ای است ممکن است بخواهید از <command>rcconf</command> استفاده کنید (از بسته <emphasis role=\"pkg\">rcconf</emphasis>) که رابط کاربری بهتری فراهم کرده است."

msgid "<emphasis>DEBIAN POLICY</emphasis> Restarting services"
msgstr "<emphasis>خط‌مشی دبیان</emphasis> راه‌اندازی‌مجدد سرویس‌ها"

msgid "<primary><command>invoke-rc.d</command></primary>"
msgstr "<primary><command>invoke-rc.d</command></primary>"

msgid "<primary>service</primary><secondary>restart</secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

msgid "<primary>restarting services</primary>"
msgstr "<primary>راه‌اندازی‌مجدد سرویس‌ها</primary>"

msgid "The maintainer scripts for Debian packages will sometimes restart certain services to ensure their availability or get them to take certain options into account. The command that controls a service — <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> — doesn't take runlevel into consideration, assumes (wrongly) that the service is currently being used, and may thus initiate incorrect operations (starting a service that was deliberately stopped, or stopping a service that is already stopped, etc.). Debian therefore introduced the <command>invoke-rc.d</command> program: this program must be used by maintainer scripts to run services initialization scripts and it will only execute the necessary commands. Note that, contrary to common usage, the <filename>.d</filename> suffix is used here in a program name, and not in a directory."
msgstr "اسکریپت‌های پیکربندی برای بسته‌های دبیان بعضی وقت‌ها اقدام به راه‌اندازی‌مجدد سرویس‌ها به منظور در دسترس بودن آن‌ها ای افزودن برخی گزینه‌های خاص به آن‌ها می‌کنند. دستوری که سرویس را کنترل می‌کند - <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> - runlevel را به حساب نمی‌آورد، تصور می‌کند (به صورت اشتباه) که سرویس هم اکنون استفاده شده است و از این رو عملیات اشتباهی را رقم می‌زند (آغاز سرویسی که به عمد متوقف شده بود، یا پایان سرویسی که هم اکنون متوقف است). به این منظور دبیان برنامه <command>invoke-rc.d</command> را معرفی کرد: این برنامه باید توسط اسکریپت‌های پیکربندی به منظور اجرای سرویس‌های اسکریپت‌های راه‌انداز و اجرای دستورات لازم استفاده گردد. نکته اینکه، بر خلاف استفاده متداول آن، پسوند <filename>.d</filename> در اینجا در نام یک برنامه بکار رفته است و نه یک دایرکتوری."

msgid "Finally, <command>init</command> starts control programs for various virtual consoles (<command>getty</command>). It displays a prompt, waiting for a username, then executes <command>login <replaceable>user</replaceable></command> to initiate a session."
msgstr "در نهایت، <command>init</command> به اجرای برنامه‌های کنترلی مرتبط با کنسول‌های مجازی (<command>getty</command>) می‌پردازد. یک صفحه خالی که نام‌کاربری را درخواست می‌کند نمایش می‌یابد، سپس برای برپایی یک نشست به اجرای <command>login <replaceable>user</replaceable></command> می‌پردازد."

msgid "<primary><command>getty</command></primary>"
msgstr "<primary><command>getty</command></primary>"

#, fuzzy
#| msgid "<primary>server</primary><secondary>client/server architecture</secondary>"
msgid "<primary>service</primary><secondary><filename>getty@.service</filename></secondary>"
msgstr "<primary>سرور</primary><secondary>معماری کلاینت/سرور</secondary>"

msgid "<emphasis>VOCABULARY</emphasis> Console and terminal"
msgstr "<emphasis>واژگان</emphasis> کنسول و ترمینال"

#, fuzzy
#| msgid "<primary>inode</primary>"
msgid "<primary>console</primary>"
msgstr "<primary>inode</primary>"

#, fuzzy
#| msgid "<primary>permissions</primary>"
msgid "<primary>terminal</primary>"
msgstr "<primary>مجوزها</primary>"

msgid "The first computers were usually separated into several, very large parts: the storage enclosure and the central processing unit were separate from the peripheral devices used by the operators to control them. These were part of a separate furniture, the “console”. This term was retained, but its meaning has changed. It has become more or less synonymous with “terminal”, being a keyboard and a screen."
msgstr "اولین رایانه‌ها به قسمت‌های بسیار بزرگی تقسیم شده بودند: فضای ذخیره‌سازی و واحد پردازش مرکری از دستگا‌ه‌های جانبی که توسط اپراتورها استفاده می‌شدند جدا بودند. این‌ها قسمتی از یک چیدمان جداگانه بودند یعنی “کنسول”. این عبارت اکنون حفظ شده ولی معنای آن تغییر یافته است. بیشتر با “ترمینال” مترادف است که به معنای صفحه‌کلید و نمایشگر است."

msgid "With the development of computers, operating systems have offered several virtual consoles to allow for several independent sessions at the same time, even if there is only one keyboard and screen. Most GNU/Linux systems offer six virtual consoles (in text mode), accessible by typing the key combinations <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> through <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>."
msgstr "با توسعه رایانه‌ها، سیستم‌عامل‌ها امکان استفاده از چندین کنسول مجازی که توسط چندین نشست جداگانه اجرا می‌شوند را فراهم آوردند، حتی اگر یک صفحه‌کلید و نمایشگر وجود داشته باشد. اکثر سیستم‌های گنو/لینوکس دارای شش کنسول مجازی هستند (در حالت متنی) که از طریق کلید‌های <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> تا <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo> قابل دسترس می‌باشند."

#, fuzzy
#| msgid "By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical X11 session (such as <command>xterm</command>, <command>gnome-terminal</command> or <command>konsole</command>)."
msgid "By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical session (such as <command>xterm</command>, <command>gnome-terminal</command> or <command>konsole</command>)."
msgstr "عبارت‌های “کنسول” و “ترمینال” می‌توانند به یک شبیه‌ساز ترمینال در محیط گرافی X11 اشاره کنند (مانند <command>xterm</command>، <command>gnome-terminal</command> یا <command>konsole</command>)."

msgid "Remote Login"
msgstr "دسترسی از راه‌دور"

msgid "It is essential for an administrator to be able to connect to a computer remotely. Servers, confined in their own room, are rarely equipped with permanent keyboards and monitors — but they are connected to the network."
msgstr "اتصال به یک رایانه از راه‌دور برای مدیرسیستم یک امر ضروری است. سرورها، که در اتاق‌های جداگانه‌ای بدون صفحه‌کلید و نمایشگر قرار می‌گیرند - به شبکه متصل هستند."

msgid "<emphasis>BACK TO BASICS</emphasis> Client, server"
msgstr "<emphasis>بازگشت به مقدمات</emphasis> معماری کلاینت، سرور"

msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>کلاینت</primary><secondary>معماری کلاینت/سرور</secondary>"

msgid "<primary>server</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>سرور</primary><secondary>معماری کلاینت/سرور</secondary>"

msgid "A system where several processes communicate with each other is often described with the “client/server” metaphor. The server is the program that takes requests coming from a client and executes them. It is the client that controls operations, the server doesn't take any initiative of its own."
msgstr "سیستمی که در آن چندین فرآیند با یکدیگر در حال برقراری ارتباط هستند استعاره از “client/server” دارد. سرور برنامه‌ای است که به درخواست‌های دریافتی از کلایت پاسخ می‌دهد. این کلاینت است که عملیات را کنترل می‌کند، سرور هیچ عملیاتی را خود آعاز نمی‌کند."

msgid "<primary>login</primary><secondary>remote login</secondary>"
msgstr "<primary>ورود</primary><secondary>ورود از راه‌دور</secondary>"

msgid "<primary>remote login</primary>"
msgstr "<primary>ورود از راه‌دور</primary>"

msgid "Secure Remote Login: SSH"
msgstr "ورود امن از راه‌دور: SSH"

msgid "<primary>SSH</primary>"
msgstr "<primary>SSH</primary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>server</primary><secondary>SSH</secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

#, fuzzy
#| msgid "<primary><command>rsh</command></primary>"
msgid "<primary><command>ssh</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>Secure Shell</primary><seealso>SSH</seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

msgid "The <emphasis>SSH</emphasis> (Secure SHell) protocol was designed with security and reliability in mind. Connections using SSH are secure: the partner is authenticated and all data exchanges are encrypted."
msgstr "پروتکل <emphasis>SSH</emphasis> یا Secure SHell با توجه به اصول امنیتی و قابلیت اطمینان طراجی شده است. ارتباطاتی که از SSH استفاده می‌کنند امن هستند: طرف مقابل احراز هویت شده و تمام اطلاعات به صورت رمزگذاری شده ارسال می‌شوند."

msgid "<emphasis>CULTURE</emphasis> Telnet and RSH are obsolete"
msgstr "<emphasis>فرهنگ</emphasis> منسوخ شدن استفاده Telnet و RSH"

msgid "<primary><command>telnet</command></primary>"
msgstr "<primary><command>telnet</command></primary>"

msgid "<primary><command>rsh</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

msgid "Before SSH, <emphasis>Telnet</emphasis> and <emphasis>RSH</emphasis> were the main tools used to login remotely. They are now largely obsolete and should no longer be used even if Debian still provides them."
msgstr "قبل از SSH، <emphasis>Telnet</emphasis> و <emphasis>RSH</emphasis> دو ابزار اصلی برای ارتباط راه‌دور بودند. اکنون این ابزارها منسوخ شده و با وجود فراهم بودن در دبیان نباید به این منظور استفاده گردند."

msgid "<emphasis>VOCABULARY</emphasis> Authentication, encryption"
msgstr "<emphasis>واژگان</emphasis> احراز هویت، رمزنگاری"

#, fuzzy
#| msgid "When you need to give a client the ability to conduct or trigger actions on a server, security is important. You must ensure the identity of the client; this is authentication. This identity usually consists of a password that must be kept secret, or any other client could get the password. This is the purpose of encryption, which is a form of encoding that allows two systems to communicate confidential information on a public channel while protecting it from being readable to others."
msgid "When you need to give a client the ability to conduct or trigger actions on a server, security is important. You must ensure the identity of the client; this is <emphasis>authentication</emphasis>. This identity usually consists of a password or passphrase that must be kept secret, or any other client could it. This is the purpose of <emphasis>encryption</emphasis>, which is a form of encoding that allows two systems to communicate confidential information on a public channel while protecting it from being readable to others."
msgstr "زمانی که می‌خواهید از طریق یک کلاینت قابلیت اجرای برخی دستورات در سرور را داشته باشید، امنیت به میان می‌آید. باید هویت کلاینت را مشخص کنید؛ این کار احراز هویت نام دارد. این شناسایی معمولا شامل یک گذرواژه می‌باشد که باید به صورت خصوصی نگهداری شود، در غیر اینصورت هر کلاینت می‌تواند به آن وصل شود. این همان هدف رمزنگاری است، که شیوه‌ای به صورت رمزگذاری برای سیستم‌ها است تا بتوانند اطلاعات بین خود را از طریق یک کانال عمومی ناامن رد و بدل کنند."

msgid "Authentication and encryption are often mentioned together, both because they are frequently used together, and because they are usually implemented with similar mathematical concepts."
msgstr "احرازهویت و رمزنگاری معمولا با یکدیگر بکار می‌روند، از آنجا که کاربرد مشابهی دارند و از آنجا که از مفاهیم مشترک ریاضی استفاده می‌کنند."

msgid "<primary><command>scp</command></primary>"
msgstr "<primary><command>scp</command></primary>"

msgid "SSH also offers two file transfer services. <command>scp</command> is a command line tool that can be used like <command>cp</command>, except that any path to another machine is prefixed with the machine's name, followed by a colon."
msgstr "SSH همچنین تو سرویس انتقال فایل را ارائه می‌دهد. <command>scp</command> یک ابزار خط فرمان است که عملکردی مشابه <command>cp</command> دارد، به جز مسیرهای خارج از یک رایانه که باید ابتدا نام رایانه به همراه دو نقطه آورده شود."

msgid "<computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput>"
msgstr "<computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput>"

msgid "<primary><command>sftp</command></primary>"
msgstr "<primary><command>sftp</command></primary>"

msgid "<command>sftp</command> is an interactive command, similar to <command>ftp</command>. In a single session, <command>sftp</command> can transfer several files, and it is possible to manipulate remote files with it (delete, rename, change permissions, etc.)."
msgstr "<command>sftp</command> یک دستور تعاملی مشابه <command>ftp</command> است. در یک نشست واحد، <command>sftp</command> می‌تواند چندین فایل را منتقل کند و امکان ایجاد تغییرات در فایل‌های راه‌دور نیز وجود دارد (حذف، تغییر نام، تغییر مجوزها و از این قبیل)."

#, fuzzy
#| msgid "<primary>tunnel (SSH)</primary><seealso>VPN</seealso>"
msgid "<primary>OpenSSH</primary><seealso>SSH</seealso>"
msgstr "<primary>تونل (SSH)</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><secondary>VNC</secondary>"
msgid "<primary>SSH</primary><secondary>OpenSSH</secondary>"
msgstr "<primary>تونل SSH</primary><secondary>VNC</secondary>"

msgid "Debian uses OpenSSH, a free version of SSH maintained by the <command>OpenBSD</command> project (a free operating system based on the BSD kernel, focused on security) and fork of the original SSH software developed by the SSH Communications Security Corp company, of Finland. This company initially developed SSH as free software, but eventually decided to continue its development under a proprietary license. The OpenBSD project then created OpenSSH to maintain a free version of SSH."
msgstr "دبیان از OpenSSH، یک نسخه آزاد از SSH که توسط پروژه <command>OpenBSD</command> مدیریت می‌شود (یک سیستم عامل آزاد مبتنی بر کرنل BSD با تمرکز بر امنیت) و انشعاب نسخه اصلی نرم‌افزار SSH که توسط شرکت SSH Communications Security Corp در فنلاند اداره می‌شد، استفاده می‌کند. این شرکت در ابتدا SSH را به عنوان نرم‌افزار آزاد منتشر کرد، اما در ادامه مسیر تصمیم گرفت تا توسعه آن را تحت یک مجوز انحصاری انجام دهد. پروژه OpenBSD با ایجاد OpenSSH تصمیم گرفت یا یک نسخه آزاد از آن ارائه دهد."

msgid "<emphasis>BACK TO BASICS</emphasis> <foreignphrase>Fork</foreignphrase>"
msgstr "<emphasis>بازگشت به مقدمات</emphasis> <foreignphrase>Fork</foreignphrase>"

msgid "<primary>fork</primary>"
msgstr "<primary>انشعاب</primary>"

msgid "A “fork”, in the software field, means a new project that starts as a clone of an existing project, and that will compete with it. From there on, both software will usually quickly diverge in terms of new developments. A fork is often the result of disagreements within the development team."
msgstr "یک “انشعاب”، در حوزه نرم‌افزار، به معنای پروژه جدیدی بر اساس پروژه فعلی است که با آن رقابت می‌کند. از آن زمان به بعد، هر دو نرم‌افزار رویکردهای متفاوتی در نسخه‌های جدید دارند. یک انشعاب معمولا ناشی از عدم تفاقق بین اعضای یک تیم توسعه نرم‌افزار است."

msgid "The option to fork a project is a direct result of the very nature of free software; a fork is a healthy event when it enables the continuation of a project as free software (for example in case of license changes). A fork arising from technical or personal disagreements is often a waste of human resources; another resolution would be preferable. Mergers of two projects that previously went through a prior fork are not unheard of."
msgstr "گزینه انشعاب برای یک پروژه از طبیعت نرم‌افزار آزاد نشات می‌گیرد؛ یک انشعاب رویدادی حیات بخش برای ادامه توسعه نرم‌افزار با فلسفه آزاد است (برای نمونه در مورد تغییر مجوز). انشعابی که از مسائل فنی یا شخصی نشات می‌گیرد معمولا به اتلاف منابع انسانی می‌انجامد؛ در این رابطه رویکرد دیگری ترجیح داده می‌شود. افرادی که دو پروژه متفاوت را که سابق بر این تحت یک عنوان فعالیت می‌کرد، راهبری می‌کنند با سابقه آن آشنا هستند."

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">openssh-client</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">openssh-server</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

#, fuzzy
#| msgid "OpenSSH is split into two packages: the client part is in the <emphasis role=\"pkg\">openssh-client</emphasis> package, and the server is in the <emphasis role=\"pkg\">openssh-server</emphasis> package. The <emphasis role=\"pkg\">ssh</emphasis> meta-package depends on both parts and facilitates installation of both (<command>apt install ssh</command>)."
msgid "OpenSSH is split into two packages: the client part is in the <emphasis role=\"pkg\">openssh-client</emphasis> package, and the server is in the <emphasis role=\"pkg\">openssh-server</emphasis> package. The <emphasis role=\"pkg\">ssh</emphasis> meta-package depends on both parts and facilitates installation of both (<command>apt install ssh</command>), while the <emphasis role=\"pkg\">task-ssh-server</emphasis>, often chosen during the initial installation, depends on the server package only."
msgstr "OpenSSH به دو بسته تقسیم شده است: بخش مربوط به کلاینت در بسته <emphasis role=\"pkg\">openssh-client</emphasis> و بخش مربوط به سرور در بسته <emphasis role=\"pkg\">openssh-server</emphasis> قرار دارد. بسته <emphasis role=\"pkg\">ssh</emphasis> به هر دو آن‌ها وابسته بوده و عملیات نصب آن‌ها را انجام می‌دهد (<command>apt install ssh</command>)."

msgid "Key-Based Authentication"
msgstr "احرازهویت کلید-محور"

#, fuzzy
#| msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgid "<primary>SSH</primary><secondary>key creation</secondary>"
msgstr "<primary>گزارش</primary><secondary>فورواردکردن</secondary>"

msgid "Each time someone logs in over SSH, the remote server asks for a password to authenticate the user. This can be problematic if you want to automate a connection, or if you use a tool that requires frequent connections over SSH. This is why SSH offers a key-based authentication system."
msgstr "با هر بار ورود از طریق SSH، سرور راه‌دور درخواست یک گذرواژه برای احزارهویت کاربر می‌کند. این می‌تواند در صورت خودکارسازی ارتباط یا استفاده از ابزاری که نیاز به ارتباط مداوم با سرور دارد، مشکل‌ساز گردد. به همین دلیل است که SSH سیستم احرازهویت کلید-محور را فراهم کرده است."

#, fuzzy
#| msgid "<primary><command>rsync</command></primary>"
msgid "<primary><command>ssh-keygen</command></primary>"
msgstr "<primary><command>rsync</command></primary>"

#, fuzzy
#| msgid "<primary><command>acpid</command></primary>"
msgid "<primary><command>ssh-copy-id</command></primary>"
msgstr "<primary><command>acpid</command></primary>"

msgid "The user generates a key pair on the client machine with <command>ssh-keygen -t rsa</command>; the so generated public key is stored in <filename>~/.ssh/id_rsa.pub</filename>, while the corresponding private key is stored in <filename>~/.ssh/id_rsa</filename>. The user can then use <command>ssh-copy-id <replaceable>server</replaceable></command> to add their public key to the <filename>~/.ssh/authorized_keys</filename> file on the server, or, if SSH access hasn't been enabled yet, they have to ask the administrator to add their key manually."
msgstr ""

#, fuzzy
#| msgid "<primary>logs</primary><secondary>dispatching</secondary>"
msgid "<primary>SSH</primary><secondary>passphrase cache</secondary>"
msgstr "<primary>گزارش‌ها</primary><secondary>مخابره‌کردن</secondary>"

#, fuzzy
#| msgid "<primary>link</primary><secondary>hard link</secondary>"
msgid "<primary>SSH</primary><secondary>passwordless</secondary>"
msgstr "<primary>پیوند</primary><secondary>پیوند سخت</secondary>"

#, fuzzy
#| msgid "<primary>logs</primary><secondary>dispatching</secondary>"
msgid "<primary>SSH</primary><secondary>authentication agent</secondary>"
msgstr "<primary>گزارش‌ها</primary><secondary>مخابره‌کردن</secondary>"

#, fuzzy
#| msgid "<primary><command>at</command></primary>"
msgid "<primary><command>ssh-agent</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "<primary>booting</primary><secondary>the system</secondary>"
msgid "<primary>X.org</primary><secondary><filename>/etc/X11/Xsession.options</filename></secondary>"
msgstr "<primary>راه‌اندازی</primary><secondary>سیستم</secondary>"

#, fuzzy
#| msgid "The user generates a key pair on the client machine with <command>ssh-keygen -t rsa</command>; the public key is stored in <filename>~/.ssh/id_rsa.pub</filename>, while the corresponding private key is stored in <filename>~/.ssh/id_rsa</filename>. The user then uses <command>ssh-copy-id <replaceable>server</replaceable></command> to add their public key to the <filename>~/.ssh/authorized_keys</filename> file on the server. If the private key was not protected with a “passphrase” at the time of its creation, all subsequent logins on the server will work without a password. Otherwise, the private key must be decrypted each time by entering the passphrase. Fortunately, <command>ssh-agent</command> allows us to keep private keys in memory to not have to regularly re-enter the password. For this, you simply use <command>ssh-add</command> (once per work session) provided that the session is already associated with a functional instance of <command>ssh-agent</command>. Debian activates it by default in graphical sessions, but this can be deactivated by changing <filename>/etc/X11/Xsession.options</filename>. For a console session, you can manually start it with <command>eval $(ssh-agent)</command>."
msgid "If the private key was not protected with a “passphrase” at the time of its creation, all subsequent logins on the server will work without a password. Otherwise, the private key must be decrypted each time by entering the passphrase. Fortunately, <command>ssh-agent</command> allows us to keep private keys in memory to not have to regularly re-enter the password. For this, you simply use <command>ssh-add</command> (once per work session) provided that the session is already associated with a functional instance of <command>ssh-agent</command>. Debian activates it by default in graphical sessions, but this can be deactivated by changing <filename>/etc/X11/Xsession.options</filename> and commenting out <literal>use-ssh-agent</literal>. For a console session, you can manually start the agent with <command>eval $(ssh-agent)</command>."
msgstr "کاربر در رایانه خود اقدام به ایجاد یک جفت کلید با استفاده از دستور <command>ssh-keygen -t rsa</command> می‌کند؛ کلید عمومی در فایل <filename>~/.ssh/id_rsa.pub</filename> و کلید خصوصی در فایل <filename>~/.ssh/id_rsa</filename> ذخیره می‌شوند. کاربر با اجرای دستور <command>ssh-copy-id <replaceable>server</replaceable></command> کلید عمومی خود را به انتهای فایل <filename>~/.ssh/authorized_keys</filename> موجود در سرور اضافه می‌کند. اگر کلید خصوصی در زمان تولید خود با استفاده از “گذزواژه” محافظت نشده باشد، تمام ورودهای جداگانه به سرور بدون درخواست گذرواژه کار خواهند کرد. در غیر اینصورت، کلید خصوصی در هر مرتبه ورود به سرور نیاز به رمزگشایی با استفاده از گذرواژه مربوطه دارد. خوشبختانه، <command>ssh-agent</command> امکان نگهداری کلید خصوصی در حافظه را به منظور دسترسی آسان‌تر فراهم می‌کند. به این منظور، کافی است <command>ssh-add</command> را (برای هر نشست جداگانه) با یک نسخه کامل <command>ssh-agent</command> بکار می‌برید. دبیان این کار را در نشست‌های گرافیکی به صورت خودکار انجام می‌دهد اما می‌توانید با تغییر در <filename>/etc/X11/Xsession.options</filename> آن را غیرفعال کنید. برای یک نشست کنسول، می‌توانید آن را به صورت دستی و با <command>eval $(ssh-agent)</command> آغاز کنید."

msgid "<emphasis>SECURITY</emphasis> Protection of the private key"
msgstr "<emphasis>امنیت</emphasis> محافظت از کلید خصوصی"

#, fuzzy
#| msgid "<primary>mask</primary><secondary>rights mask</secondary>"
msgid "<primary>SSH</primary><secondary>private key</secondary>"
msgstr "<primary>ماسک</primary><secondary>دسترسی‌های ماسک</secondary>"

msgid "Whoever has the private key can login on the account thus configured. This is why access to the private key is protected by a “passphrase”. Someone who acquires a copy of a private key file (for example, <filename>~/.ssh/id_rsa</filename>) still has to know this phrase in order to be able to use it. This additional protection is not, however, impregnable, and if you think that this file has been compromised, it is best to disable that key on the computers in which it has been installed (by removing it from the <filename>authorized_keys</filename> files) and replacing it with a newly generated key."
msgstr "هر کسی که به کلید خصوصی دسترسی داشته باشد با حساب کاربری مربوط به آن می‌تواند وارد شود. به همین دلیل است که دسترسی به کلید خصوصی از طریق یک “گذزواژه” محافظت می‌شود. کسی که یک رونوشت از کلید خصوصی می‌گیرد (برای نمونه، <filename>~/.ssh/id_rsa</filename>) هنوز باید به گذرواژه مخصوص آن دسترسی داشته باشد. این لایه حفاظتی اضافی نیز، اگرچه، رسوخ‌ناپذیر نیست و اگر فکر می‌کنید که کلید خصوصی شما آشکار شده است بهتر است تا مجوز دسترسی به آن روی رایانه‌های سرور را از بین ببرید (با حفظ کردن آن از فایل <filename>authorized_keys</filename>) و آن را با یک کلید جدید جایگزین کنید."

msgid "<emphasis>CULTURE</emphasis> OpenSSL flaw in Debian <emphasis role=\"distribution\">Etch</emphasis>"
msgstr "<emphasis>فرهنگ</emphasis> نقص OpenSSL در دبیان <emphasis role=\"distribution\">Etch</emphasis>"

#, fuzzy
#| msgid "The OpenSSL library, as initially provided in Debian <emphasis role=\"distribution\">Etch</emphasis>, had a serious problem in its random number generator (RNG). Indeed, the Debian maintainer had made a change so that applications using it would no longer generate warnings when analyzed by memory testing tools like <command>valgrind</command>. Unfortunately, this change also meant that the RNG was employing only one source of entropy corresponding to the process number (PID) whose 32,000 possible values do not offer enough randomness. <ulink type=\"block\" url=\"http://www.debian.org/security/2008/dsa-1571\" />"
msgid "The OpenSSL library, as initially provided in Debian <emphasis role=\"distribution\">Etch</emphasis>, had a serious problem in its random number generator (RNG). Indeed, the Debian maintainer had made a change so that applications using it would no longer generate warnings when analyzed by memory testing tools like <command>valgrind</command>. Unfortunately, this change also meant that the RNG was employing only one source of entropy corresponding to the process number (PID) whose 32,000 possible values do not offer enough randomness. <ulink type=\"block\" url=\"https://www.debian.org/security/2008/dsa-1571\" />"
msgstr "کتابخانه OpenSSL، که ابتدا در دبیان <emphasis role=\"distribution\">Etch</emphasis> ارائه شد، یک مشکل اساسی در تولیدکننده عدد تصادفی (RNG) خود داشت. در واقع، نگهدارنده بسته تغییر کوچکی ایجاد کرده بود تا برنامه‌هایی که از آن استفاده می‌کنند اقدام به تولید اخطارهای خاصی زمانی که از ابزار آزمون حافظه مانند <command>valgrind</command> استفاده می‌شود، نکنند. متاسفانه، این تغییر به معنای این بود که RNG تنها از یک منبع آنتروپی متناظر با شماره فرآیند (PID) که ۳۲،۰۰۰ مقدار آن برای تولید عدد تصادفی کافی نبود، استفاده می‌کرد. <ulink type=\"block\" url=\"http://www.debian.org/security/2008/dsa-1571\" />"

#, fuzzy
#| msgid "<primary><command>rsh</command></primary>"
msgid "<primary><command>ssh-vulnkey</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">openssh-blacklist</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"

msgid "Specifically, whenever OpenSSL was used to generate a key, it always produced a key within a known set of hundreds of thousands of keys (32,000 multiplied by a small number of key lengths). This affected SSH keys, SSL keys, and X.509 certificates used by numerous applications, such as OpenVPN. A cracker had only to try all of the keys to gain unauthorized access. To reduce the impact of the problem, the SSH daemon was modified to refuse problematic keys that are listed in the <emphasis role=\"pkg\">openssh-blacklist</emphasis> and <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis> packages. Additionally, the <command>ssh-vulnkey</command> command allows identification of possibly compromised keys in the system."
msgstr "به خصوص، زمانی که OpenSSL برای تولید یک کلید استفاده می‌شد، همیشه کلیدی بین محدوده مشخصی از آن‌ها تولید می‌کرد (۳۲،۰۰۰ ضرب در تعداد کمی از طول کلید‌ها). این عملکرد روی کلیدهای SSH، کلیدهای SSL و گواهینامه‌های X.509 که توسط بسیاری برنامه‌ها مانند OpenVPN استفاده می‌شدند، تاثیر گذاشت. یک نفوذگر تنها می‌بایست تمام کلید‌های موجود در آن بازه را جهت دسترسی به سیستم پیدا کند. برای کاهش تاثیر این مشکل، فرآیند پس‌زمینه SSH طوری تغییر یافت تا کلیدهای دردسرساز فهرست شده در بسته‌های <emphasis role=\"pkg\">openssh-blacklist</emphasis> و <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis> را رد کند. علاوه بر این، دستور <command>ssh-vulnkey</command> امکان شناسایی کلیدهای آشکارشده در سیستم را فراهم می‌کرد."

msgid "A more thorough analysis of this incident brings to light that it is the result of multiple (small) problems, both within the OpenSSL project and with the Debian package maintainer. A widely used library like OpenSSL should — without modifications — not generate warnings when tested by <command>valgrind</command>. Furthermore, the code (especially the parts as sensitive as the RNG) should be better commented to prevent such errors. On Debian's side, the maintainer wanted to validate the modifications with the OpenSSL developers, but simply explained the modifications without providing the corresponding patch to review and failed to mention his role within Debian. Finally, the maintenance choices were sub-optimal: the changes made to the original code were not clearly documented; all the modifications were effectively stored in a Subversion repository, but they ended up all lumped into one single patch during creation of the source package."
msgstr "تحلیل بیشتر روی این موضوع نشان داد که مشکلات کوچک بیشتری در پروژه OpenSSL و نگهدارنده بسته دبیان آن وجود داشت. کتابخانه بزرگی مانند OpenSSL - بدون تغییر - نباید پس از آزمون با <command>valgrind</command> پیام‌های اخطار صادر کند. علاوه بر این، کد (به خصوص قسمت حساسی مانند RNG) باید با توضیحات بهتری از بروز چنین خطایی پیشگیری کند. در طرف دبیان، نگهدارنده بسته قصد داشت تا تغییرات مورد نظر خود را با توسعه‌دهندگان اصلی OpenSSL سازگار سازد، اما بدون ارايه فایل وصله مناسب و در جریان گذاشتن تیم اصلی از تغییرات انجام گرفته خارج از مسئولیت‌های پروژه دبیان اقدام کرد. در نهایت، راه‌حل‌های پیشنهادی خیلی بهینه نبودند: تغییرات ایجاد شده در کد اصلی به خوبی مستند نشده بود؛ تمام تغییرات در یک مخزن Subversion ذخیره شده بودند اما هنگام ایجاد بسته اصلی تنها به تولید یک فایل وصله انجامید."

#, fuzzy
#| msgid "It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type=\"block\" url=\"http://sources.debian.net\" />"
msgid "It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type=\"block\" url=\"https://sources.debian.org\" />"
msgstr "در چنین شرایطی جستجو برای معیارهای درست به منظور جلوگیری از وقوع چنین رخدادهایی دشوار است. درسی که از این مورد می‌توان گرفت این است که کوچکترین تغییر مورد نظر از طریق دبیان باید به توسعه‌دهندگان اصلی اطلاع داده شده، به خوبی مستندسازی گردد و به صورت عمومی انتشار یابد. با این دید بود که قالب بسته‌های سورس جدید (“3.0 (quilt)”) و وب‌سرویس دبیان برای این منظور بوجود آمدند. <ulink type=\"block\" url=\"http://sources.debian.net\" />"

#, fuzzy
#| msgid "Key-Based Authentication"
msgid "Cert-Based Authentication"
msgstr "احرازهویت کلید-محور"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>SSH</primary><secondary>signed key</secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

#, fuzzy
#| msgid "<primary>booting</primary><secondary>the system</secondary>"
msgid "<primary>SSH</primary><secondary><literal>TrustedUserCAKeys</literal></secondary>"
msgstr "<primary>راه‌اندازی</primary><secondary>سیستم</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>SSH</primary><secondary><literal>HostCertificate</literal></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/ssh/sshd_config</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/ssh/known_hosts</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "SSH keys cannot just be protected by a password (or not). An often unknown feature is that they can also be signed via certificate, both the host as well as the client keys. This approach comes with several advantages. Instead of maintaining an <filename>authorized_keys</filename> file per user as described in the previous section, the SSH server can be configured to trust all client keys signed by the same certificate (see also <xref linkend=\"sect.easy-rsa\" />) by using the <literal>TrustedUserCAKeys</literal> and <literal>HostCertificate</literal> directives in <filename>/etc/ssh/sshd_config</filename>."
msgstr ""

msgid ""
"\n"
"TrustedUserCAKeys /etc/ssh/ssh_users_ca.pub\n"
"\n"
"HostKey /etc/ssh/ssh_host_ecdsa_key\n"
"HostCertificate /etc/ssh/ssh_host_ecdsa_key-cert.pub"
msgstr ""

msgid "Vice-versa the clients can also be configured to trust the host key signed by the same authority, making it easier to maintain the <filename>known_hosts</filename> file (even system wide via <filename>/etc/ssh/known_hosts</filename>)."
msgstr ""

msgid "@cert-authority *.falcot.com ssh-rsa AAAA[..]"
msgstr ""

msgid "Both, public key and certificate authentication, can be used alongside each other."
msgstr ""

msgid "Using Remote X11 Applications"
msgstr "استفاده راه‌دور از برنامه‌های X11"

#, fuzzy
#| msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgid "<primary>SSH</primary><secondary><literal>X11Forwarding</literal></secondary>"
msgstr "<primary>گزارش</primary><secondary>فورواردکردن</secondary>"

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary>SSH</primary><secondary><literal>remote graphical applications</literal></secondary>"
msgstr "<primary>ورود</primary><secondary>ورود از راه‌دور</secondary>"

#, fuzzy
#| msgid "<primary>remote graphical desktop</primary>"
msgid "<primary>remote graphical application</primary>"
msgstr "<primary>میزکار گرافیکی راه‌دور</primary>"

#, fuzzy
#| msgid "<primary>desktop, remote graphical desktop</primary>"
msgid "<primary>application, remote graphical application</primary>"
msgstr "<primary>میزکار، میزکار گرافیکی راه‌دور</primary>"

msgid "The SSH protocol allows forwarding of graphical data (“X11” session, from the name of the most widespread graphical system in Unix); the server then keeps a dedicated channel for those data. Specifically, a graphical program executed remotely can be displayed on the X.org server of the local screen, and the whole session (input and display) will be secure. Since this feature allows remote applications to interfere with the local system, it is disabled by default. You can enable it by specifying <literal>X11Forwarding yes</literal> in the server configuration file (<filename>/etc/ssh/sshd_config</filename>). Finally, the user must also request it by adding the <literal>-X</literal> option to the <command>ssh</command> command-line."
msgstr "پروتکل SSH امکان فوروارد کردن داده‌های گرافیکی را می‌دهد (نشست “X11”، که از نام متداول‌ترین سیستم گرافیکی یونیکس گرفته شده است)؛ سرور یک کانال اختصاصی برای آن در نظر می‌گیرد. به خصوص، یک برنامه گرافیکی که از راه‌دور اجرا می‌شود می‌تواند روی سرور X.org سیستم محلی نمایش یابد و تمام نشست جاری (ورودی و نمایش) امن خواهد بود. از آنجا که این سیستم اجازه تداخل برنامه‌های راه‌دور با سیستم محلی را می‌دهد، به صورت پیش‌فرض غیرفعال است. می‌توانید با مشخص کردن <literal>X11Forwarding yes</literal> در فایل پیکربندی سرور (<filename>/etc/ssh/sshd_config</filename>) آن را فعال کنید. در نهایت، کاربر نیز هنگام درخواست <command>ssh</command> باید گزینه <literal>-X</literal> را بیان کند."

#, fuzzy
#| msgid "<emphasis>GOING FURTHER</emphasis> Defining quotas with a script"
msgid "<emphasis>GOING FURTHER</emphasis> Magic cookies in .Xauthority"
msgstr "<emphasis>مطالعه بیشتر</emphasis> تعیین سهمیه‌بندی با اسکریپت"

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>.Xauthority</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

#, fuzzy
#| msgid "<primary><command>at</command></primary>"
msgid "<primary><command>xauth</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "<primary>inode</primary>"
msgid "<primary>magic cookie</primary>"
msgstr "<primary>inode</primary>"

msgid "When a user connects via SSH and starts a remote X11 session, a so-called <emphasis>magic cookie</emphasis> is created and stored in the <filename>.Xauthority</filename> file in the user's home directory that initiated the connection. This cookie is used by <command>xauth</command> to authenticate the user during the X session. If the user impersonates another user on the system, e.g. using <command>su</command> or <command>sudo</command>, then the cookie is not copied automatically to the target user and the X server will refuse to start graphical applications under the target user's context. You will have to copy the magic cookie into the target user's home directory (by exporting and re-importing the cookie via <command>xauth</command>) to allow another user to start graphical programs as well during the X session."
msgstr ""

msgid "Creating Encrypted Tunnels with Port Forwarding"
msgstr "ایجاد تونل‌های رمزگذاری شده با پورت فورواردینگ"

msgid "<primary>port forwarding</primary>"
msgstr "<primary>پورت فورواردینگ</primary>"

#, fuzzy
#| msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgid "<primary>SSH</primary><secondary>port forwarding</secondary>"
msgstr "<primary>گزارش</primary><secondary>فورواردکردن</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>SSH</primary><secondary>tunnel</secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "Its <literal>-R</literal> and <literal>-L</literal> options allow <command>ssh</command> to create “encrypted tunnels” between two machines, securely forwarding a local TCP port (see sidebar <xref linkend=\"sidebar.tcp-udp\" />) to a remote machine or vice versa."
msgstr "گزینه‌های <literal>-R</literal> و <literal>-L</literal> به <command>ssh</command> امکان ایجاد “تونل‌های رمزگذاری‌شده” بین دو رایانه را می‌دهند، که به تبع آن یک پورت TCP محلی (قسمت <xref linkend=\"sidebar.tcp-udp\" /> را مشاهده کنید) به شیوه‌ای امن می‌تواند به یک ماشین راه‌دور فوروارد شود یا بر عکس."

msgid "<emphasis>VOCABULARY</emphasis> Tunnel"
msgstr "<emphasis>واژگان</emphasis> تونل"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>tunnel</primary><secondary>SSH</secondary><seealso>VPN</seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>SSH</primary><secondary>tunnel</secondary><seealso>VPN</seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

msgid "The Internet, and most LANs that are connected to it, operate in packet mode and not in connected mode, meaning that a packet issued from one computer to another is going to be stopped at several intermediary routers to find its way to its destination. You can still simulate a connected operation where the stream is encapsulated in normal IP packets. These packets follow their usual route, but the stream is reconstructed unchanged at the destination. We call this a “tunnel”, analogous to a road tunnel in which vehicles drive directly from the entrance (input) to the exit (output) without encountering any intersections, as opposed to a path on the surface that would involve intersections and changing direction."
msgstr "اینترنت، و اکثر شبکه‌های محلی متصل به آن، در حالت بسته‌ای کار می‌کنند نه متصل، به این معنی که بسته ارسال شده از یک رایانه در مسیر خود چندین رایانه دیگر (مسیریاب) را طی می‌کند تا در نهایت به مقصد برسد. می‌توانید عملیات اتصال را طوری شبیه‌سازی کنید که در آن جریان داده در بسته‌های نرمال IP ذخیره شده باشد. این بسته‌ها از مسیرهای خود طبعیت می‌کنند، اما جریان داده در انتهای مسیر بدون تغییر باقی می‌ماند. ما به این فرآیند یک “تونل” می‌گوییم، مشابه با یک تونل در دنیای واقعی که در آن خودروها از سمت ورودی (input) به خروجی (output) حرکت می‌کنند بدون اینکه مسیرشان تغییر کند، بر خلاف یک مسیر معمولی که ممکن است شامل تقاطع‌های متفاوت باشد."

msgid "You can use this opportunity to add encryption to the tunnel: the stream that flows through it is then unrecognizable from the outside, but it is returned in decrypted form at the exit of the tunnel."
msgstr "از این موقعیت برای افزودن رمزنگاری به تونل می‌توانید استفاده کنید: با اینکار جریان داده‌ای که از تونل می‌گذرد غیر قابل تشخیص از خارج آن است اما در انتهای تونل به شیوه رمزگشایی شده قرار می‌گیرد."

msgid "<command>ssh -L 8000:server:25 intermediary</command> establishes an SSH session with the <replaceable>intermediary</replaceable> host and listens to local port 8000 (see <xref linkend=\"figure.ssh-L\" />). For any connection established on this port, <command>ssh</command> will initiate a connection from the <replaceable>intermediary</replaceable> computer to port 25 on the <replaceable>server</replaceable>, and will bind both connections together."
msgstr "دستور <command>ssh -L 8000:server:25 intermediary</command> یک نشست SSH با میزان <replaceable>intermediary</replaceable> برقرار کرده و به پورت محلی ۸۰۰۰ گوش می‌دهد (<xref linkend=\"figure.ssh-L\" /> را مشاهده کنید). برای هر ارتباطی که روی این پورت برقرار شود، <command>ssh</command> یک ارتباط میانی از رایانه <replaceable>intermediary</replaceable> با پورت ۲۵ روی <replaceable>server</replaceable> برقرار کرده و هر دو ارتباط را به یکدیگر متصل می‌کند."

msgid "<command>ssh -R 8000:server:25 intermediary</command> also establishes an SSH session to the <replaceable>intermediary</replaceable> computer, but it is on this machine that <command>ssh</command> listens to port 8000 (see <xref linkend=\"figure.ssh-R\" />). Any connection established on this port will cause <command>ssh</command> to open a connection from the local machine on to port 25 of the <replaceable>server</replaceable>, and to bind both connections together."
msgstr "دستور <command>ssh -R 8000:server:25 intermediary</command> نیز یک نشست SSH با رایانه <replaceable>intermediary</replaceable> برقرار می‌کند، اما روی این رایانه است که <command>ssh</command> به پورت ۸۰۰۰ (<xref linkend=\"figure.ssh-R\" /> را مشاهده کنید) گوش می‌دهد. هر ارتباطی که روی این پورت برقرار شود <command>ssh</command> یک ارتباط با پورت ۲۵ <replaceable>server</replaceable> برقرار کرده و هر دو ارتباط را به یکدیگر متصل می‌کند."

msgid "In both cases, connections are made to port 25 on the <replaceable>server</replaceable> host, which pass through the SSH tunnel established between the local machine and the <replaceable>intermediary</replaceable> machine. In the first case, the entrance to the tunnel is local port 8000, and the data move towards the <replaceable>intermediary</replaceable> machine before being directed to the <replaceable>server</replaceable> on the “public” network. In the second case, the input and output in the tunnel are reversed; the entrance is port 8000 on the <replaceable>intermediary</replaceable> machine, the output is on the local host, and the data are then directed to the <replaceable>server</replaceable>. In practice, the server is usually either the local machine or the intermediary. That way SSH secures the connection from one end to the other."
msgstr "در هر دو مورد، ارتباطات با پورت ۲۵ میزان <replaceable>server</replaceable> برقرار شد، که جریان داده آن از طریق تونل SSH بین سیستم محلی و سیستم <replaceable>intermediary</replaceable> می‌گذرد. در مورد اول، ورودی تونل پورت ۸۰۰۰ محلی است و داده قبل از اینکه به <replaceable>server</replaceable> در شبکه “عمومی” برسد از طریق رایانه <replaceable>intermediary</replaceable> می‌گذرد. در مورد دوم، ورودی و خروجی تونل برعکس شده است؛ ورودی پورت ۸۰۰۰ از رایانه <replaceable>intermediary</replaceable> است و خروجی روی سیستم محلی قرار دارد و جریان داده به این شکل به <replaceable>server</replaceable> هدایت می‌شود. در عمل، سرور همان سیستم محلی یا میانی است. به این شیوه SSH می‌تواند ارتباط امنی بین هر دو رایانه برقرار کند."

msgid "Forwarding a local port with SSH"
msgstr "فوروارد کردن یک پورت محلی با SSH"

msgid "Forwarding a remote port with SSH"
msgstr "فوروارد کردن یک پورت راه‌دور با SSH"

msgid "Using Remote Graphical Desktops"
msgstr "استفاده از میزکارهای گرافیکی راه‌دور"

msgid "VNC (Virtual Network Computing) allows remote access to graphical desktops."
msgstr "VNC یا Virtual Network Computing اجازه دسترسی راه‌دور به میزکارهای گرافیکی را می‌دهد."

msgid "<primary>VNC</primary>"
msgstr "<primary>VNC</primary>"

#, fuzzy
#| msgid "<primary>Virtual Network Computing</primary>"
msgid "<primary>Virtual Network Computing</primary><seealso>VNC</seealso>"
msgstr "<primary>Virtual Network Computing</primary>"

msgid "<primary>graphical desktop</primary><secondary>remote</secondary>"
msgstr "<primary>میزکار گرافیکی</primary><secondary>راه‌دور</secondary>"

msgid "<primary>remote graphical desktop</primary>"
msgstr "<primary>میزکار گرافیکی راه‌دور</primary>"

msgid "<primary>desktop, remote graphical desktop</primary>"
msgstr "<primary>میزکار، میزکار گرافیکی راه‌دور</primary>"

msgid "This tool is mostly used for technical assistance; the administrator can see the errors that the user is facing, and show them the correct course of action without having to stand by them."
msgstr "این ابزار بیشتر برای راهنمایی فنی استفاده می‌شود؛ مدیرسیستم می‌تواند خطاهایی را ببیند که کاربر با آن مواجه است و به آن‌ها شیوه حل مساله را آموزش دهد."

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary>VNC</primary><secondary>server</secondary>"
msgstr "<primary>مالک</primary><secondary>کاربر</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>server</primary><secondary>VNC</secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">vino</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">krfb</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">krfb</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">krfb</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">tightvncserver</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">tigervnc-standalone-server</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

#, fuzzy
#| msgid "First, the user must authorize sharing their session. The GNOME graphical desktop environment in <emphasis role=\"distribution\">Jessie</emphasis> includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). KDE still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon."
msgid "First, the user must authorize sharing their session. The GNOME graphical desktop environment includes that option via <menuchoice> <guimenu>Settings</guimenu> <guimenuitem>Sharing</guimenuitem> </menuchoice> (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). For this to work <emphasis role=\"pkg\">network-manager</emphasis> must be managing the network used (e.g. enable the <literal>managed</literal> mode for devices handled by <emphasis role=\"pkg\">ifupdown</emphasis> in <filename>/etc/NetworkManager/NetworkManager.conf</filename>). KDE Plasma still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> or <command>tightvncserver</command> commands (from the Debian packages of the same name) or <command>tigervncserver</command> (<emphasis role=\"pkg\">tigervnc-standalone-server</emphasis>) serve the same purpose and provide the <emphasis role=\"pkg\">vnc-server</emphasis> virtual package; you can make either of them available to the user with an explicit menu or desktop entry."
msgstr "ابتدا، کاربر باید اجازه اشتراک نشست خود را صادر کند. میزکار گرافیکی GNOME در <emphasis role=\"distribution\">Jessie</emphasis> این گزینه را در پنل پیکربندی خود شامل می‌شود (برخلاف نسخه‌های قبلی دبیان که کاربر می‌بایست بسته <command>vino</command> را نصب و اجرا کند). KDE هنوز به بسته <command>krfb</command> جهت اشتراک نشست فعلی با VNC نیاز دارد. برای سایر میزکارهای گرافیکی، دستور <command>x11vnc</command> (در بسته دبیان با همین نام) هدف مشابهی را دنبال می‌کند؛ می‌توانید آن را با استفاده از یک نماد گرافیکی در اختیار کاربر قرار دهید."

#, fuzzy
#| msgid "<primary>link</primary><secondary>hard link</secondary>"
msgid "<primary>VNC</primary><secondary>client</secondary>"
msgstr "<primary>پیوند</primary><secondary>پیوند سخت</secondary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">krdc</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">xtightvncviewer</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">tigervnc-viewer</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"

#, fuzzy
#| msgid "When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while KDE includes <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xvnc4viewer</command> in the Debian package of the same name. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed."
msgid "When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while the KDE project provides <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xtightvncviewer</command> from the homonym package or <command>xtigervncviewer</command> from the <emphasis role=\"pkg\">tigervnc-viewer</emphasis> Debian package. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed."
msgstr "زمانی که نشست گرافیکی توسط VNC آماده شود، مدیرسیستم باید با استفاده از یک کلاینت VNC به آن متصل شود. GNOME از <command>vinagre</command> و <command>remmina</command> به این منظور استفاده می‌کند در حالی که ابزار KDE شامل <command>krdc</command> است (در منوی <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). سایر کلاینت‌های VNC نیز وجود دارند که در خط فرمان عمل می‌کنند مانند <command>xvnc4viewer</command> در بسته دبیان با همین نام. زمانی که ارتباط برقرار شود، مدیرسیستم می‌بیند که مشکل از کجاست، به صورت راه‌دور آن را عیب‌یابی کرده و به کاربر شیوه حل مساله را می‌آموزد."

msgid "<emphasis>SECURITY</emphasis> VNC over SSH"
msgstr "<emphasis>امنیت</emphasis> VNC همراه با SSH"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><secondary>VNC</secondary>"
msgid "<primary>tunnel</primary><secondary>VNC</secondary>"
msgstr "<primary>تونل SSH</primary><secondary>VNC</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>SSH</primary><secondary>tunnel</secondary><tertiary>VNC</tertiary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

#, fuzzy
#| msgid "<primary><command>init</command></primary>"
msgid "<primary><command>vncviewer</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "If you want to connect by VNC, and you don't want your data sent in clear text on the network, it is possible to encapsulate the data in an SSH tunnel (see <xref linkend=\"sect.ssh-port-forwarding\" />). You simply have to know that VNC uses port 5900 by default for the first screen (called “localhost:0”), 5901 for the second (called “localhost:1”), etc."
msgstr "اگر قصد استفاده از VNC در حالت امن و رمزنگاری شده را دارید، امکان ذخیره‌سازی داده در یک تونل SSH وجود دارد (<xref linkend=\"sect.ssh-port-forwarding\" /> را مشاهده کنید). تنها کافی است بدانید که VNC به صورت پیش‌فرض از پورت ۵۹۰۰ برای نمایشگر اول (که “localhost:0” خوانده می‌شود)، ۵۹۰۱ برای نمایشگر دوم (که “localhost:1” خوانده می‌شود) و به همین ترتیب استفاده می‌کند."

msgid "The <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> command creates a tunnel between local port 5901 in the localhost interface and port 5900 of the <replaceable>machine</replaceable> host. The first “localhost” restricts SSH to listening to only that interface on the local machine. The second “localhost” indicates the interface on the remote machine which will receive the network traffic entering in “localhost:5901”. Thus <command>vncviewer localhost:1</command> will connect the VNC client to the remote screen, even though you indicate the name of the local machine."
msgstr "دستور <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> یک تونل بین پورت ۵۹۰۱ محلی در رابط شبکه localhost و پورت ۵۹۰۰ از میزبان <replaceable>machine</replaceable> ایجاد می‌کند. اولین “localhost” به SSH می‌گوید که تنها روی این رابط شبکه از رایانه محلی متمرکز باشد. دومین “localhost” نشان‌دهنده رابط شبکه رایانه راه‌دور است که ترافیک دریافتی را از طریق “localhost:5901” می‌فرستد. بنابراین <command>vncviewer localhost:1</command> کلایت VNC را به نمایشگر راه‌دور متصل کرده، با اینکه نام رایانه محلی را ذکر کرده‌اید."

msgid "When the VNC session is closed, remember to close the tunnel by also quitting the corresponding SSH session."
msgstr "زمانی که نشست VNC به پایان رسید به یاد داشته باشید که باید نشست SSH مربوط به آن را نیز خاتمه دهید."

msgid "<emphasis>BACK TO BASICS</emphasis> Display manager"
msgstr "<emphasis>بازگشت به مقدمات</emphasis> مدیر نمایش"

msgid "<primary><command>gdm3</command></primary>"
msgstr "<primary><command>gdm3</command></primary>"

msgid "<primary><command>kdm</command></primary>"
msgstr "<primary><command>kdm</command></primary>"

msgid "<primary><command>xdm</command></primary>"
msgstr "<primary><command>xdm</command></primary>"

msgid "<primary><command>lightdm</command></primary>"
msgstr "<primary><command>lightdm</command></primary>"

msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgstr "<primary>مدیر</primary><secondary>مدیر نمایش</secondary>"

msgid "<primary>display manager</primary>"
msgstr "<primary>مدیر نمایش</primary>"

#, fuzzy
#| msgid "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, and <command>xdm</command> are Display Managers. They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session."
msgid "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, and <command>xdm</command> are Display Managers (they all provide the <emphasis role=\"pkg\">x-display-manager</emphasis> meta package). They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session."
msgstr "<command>gdm</command>، <command>kdm</command>، <command>xdm</command> و <command>lightdm</command> مدیر نمایش هستند. آن‌ها وظیفه کنترل کردن رابط گرافیکی بعد از راه‌اندازی اولیه سیستم به منظور فراهم کردن صفحه ورودی برای کاربر را به عهده دارند. زمانی که کاربر وارد سیستم شود برنامه‌ای را اجرا می‌کنند که میزکار گرافیکی را فراهم می‌آورد."

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/gdm3/daemon.conf</filename></secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/inetd.conf</filename></secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

msgid "Managing Rights"
msgstr "مدیریت دسترسی"

msgid "<primary>permissions</primary>"
msgstr "<primary>مجوزها</primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>rights</primary><seealso>permissions</seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>device</primary><secondary>files</secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "Linux is definitely a multi-user system, so it is necessary to provide a permission system to control the set of authorized operations on files and directories, which includes all the system resources and devices (on a Unix system, any device is represented by a file or directory). This principle is common to all Unix systems, but a reminder is always useful, especially as there are some interesting and relatively unknown advanced uses."
msgstr "لینوکس بدون شک یک سیستم چندکاربره حقیقی است، پس فراهم کردن یک سیستم محوز برای کنترل عملیات مورد مجاز روی فایل‌ها و دایرکتوری‌ها، که شامل تمام منابع و دستگاه‌های سیستم می‌شود، امری لازم و ضروری است (در یک سیستم یونیکس، هر دستگاهی توسط یک فایل یا دایرکتوری مشحص می‌گردد). این اصل درباره تمام سیستم‌های یونیکس صدق می‌کند، اما ذکر این نکته مفید است که کاربردهای پیشرفته دیگری نیز برای این منظور وجود دارند."

#, fuzzy
#| msgid "Permissions"
msgid "Owners and Permissions"
msgstr "مجوزها"

msgid "<primary>user</primary><secondary>owner</secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "<primary>group</primary><secondary>owner</secondary>"
msgstr "<primary>گروه</primary><secondary>مالک</secondary>"

msgid "<primary>owner</primary><secondary>user</secondary>"
msgstr "<primary>مالک</primary><secondary>کاربر</secondary>"

msgid "<primary>owner</primary><secondary>group</secondary>"
msgstr "<primary>مالک</primary><secondary>گروه</secondary>"

msgid "Each file or directory has specific permissions for three categories of users:"
msgstr "هر فایل یا دایرکتوری شامل مجوزهای مشخصی برای سه گروه از کاربران است:"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary>permissions</primary><secondary><literal>u</literal></secondary>"
msgstr "<primary>مالک</primary><secondary>کاربر</secondary>"

msgid "its owner (symbolized by <literal>u</literal> as in “user”);"
msgstr "مالک آن (که با حرف <literal>u</literal> از کلمه “user” نمایش می‌یابد)؛"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>permissions</primary><secondary><literal>g</literal></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "its owner group (symbolized by <literal>g</literal> as in “group”), representing all the members of the group;"
msgstr "گروه مالک آن (که با حرف <literal>g</literal> از کلمه “group” نمایش می‌یابد) که بیانگر تمام اعضای آن گروه است؛"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>permissions</primary><secondary><literal>o</literal></secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "the others (symbolized by <literal>o</literal> as in “other”)."
msgstr "دیگران (که با حرف <literal>o</literal> از کلمه “other” نمایش می‌یابد)."

#, fuzzy
#| msgid "Three types of rights can be combined:"
msgid "Three basic types of rights can be combined:"
msgstr "سه نوع دسترسی قابل ترکیب هستند:"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>permissions</primary><secondary><literal>r</literal></secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

msgid "reading (symbolized by <literal>r</literal> as in “read”);"
msgstr "خواندن (که با خرف <literal>r</literal> از کلمه “read” نمایش می‌یابد)؛"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>permissions</primary><secondary><literal>w</literal></secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "writing (or modifying, symbolized by <literal>w</literal> as in “write”);"
msgstr "نوشتن یا تغییردادن (که با حرف <literal>w</literal> از کلمه “write” نمایش می‌یابد)."

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>permissions</primary><secondary><literal>x</literal></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "executing (symbolized by <literal>x</literal> as in “eXecute”)."
msgstr "اجرا کردن (که با حرف <literal>x</literal> از کلمه “eXecute” نمایش می‌یابد)."

msgid "<primary>read, right</primary>"
msgstr "<primary>خواندن، دسترسی</primary>"

msgid "<primary>write, right</primary>"
msgstr "<primary>نوشتن، دسترسی</primary>"

msgid "<primary>modification, right</primary>"
msgstr "<primary>تغییردادن، دسترسی</primary>"

msgid "<primary>execution, right</primary>"
msgstr "<primary>اجراکردن، دسترسی</primary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>permissions</primary><secondary>read</secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>permissions</primary><secondary>write</secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary>permissions</primary><secondary>execute</secondary>"
msgstr "<primary>مالک</primary><secondary>کاربر</secondary>"

msgid "In the case of a file, these rights are easily understood: read access allows reading the content (including copying), write access allows changing it, and execute access allows you to run it (which will only work if it is a program)."
msgstr "در مورد یک فایل این دسترسی‌ها به سادگی قابل درک هستند: دسترسی خواندن اجازه خواندن محتوا را می‌دهد (از جمله رونوشت گرفتن)، دسترسی نوشتن اجازه تغییر آن را می‌دهد و دسترسی اجراکردن اجازه اجرای فایل را می‌دهد (که در صورت برنامه بودن معنی دارد)."

msgid "<emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables"
msgstr "<emphasis>امنیت</emphasis> برنامه‌های اجرایی <literal>setuid</literal> و <literal>setgid</literal>"

#, fuzzy
#| msgid "<emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables"
msgid "<primary>permissions</primary><secondary><literal>setuid</literal></secondary><seealso><literal>setuid</literal></seealso>"
msgstr "<emphasis>امنیت</emphasis> برنامه‌های اجرایی <literal>setuid</literal> و <literal>setgid</literal>"

#, fuzzy
#| msgid "<emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables"
msgid "<primary>permissions</primary><secondary><literal>setgid</literal></secondary><seealso><literal>setgid</literal></seealso>"
msgstr "<emphasis>امنیت</emphasis> برنامه‌های اجرایی <literal>setuid</literal> و <literal>setgid</literal>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>permissions</primary><secondary><literal>s</literal></secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

#, fuzzy
#| msgid "Two particular rights are relevant to executable files: <literal>setuid</literal> and <literal>setgid</literal> (symbolized with the letter “s”). Note that we frequently speak of “bit”, since each of these boolean values can be represented by a 0 or a 1. These two rights allow any user to execute the program with the rights of the owner or the group, respectively. This mechanism grants access to features requiring higher level permissions than those you would usually have."
msgid "Two particular rights are relevant to executable files: <literal>setuid</literal> and <literal>setgid</literal> (symbolized with the letter “s”). Note that we frequently speak of “bit”, since each of these Boolean values can be represented by a 0 or a 1. These two rights allow any user to execute the program with the rights of its owner or its group, respectively. This mechanism grants access to features requiring higher level permissions than those you would usually have."
msgstr "دو دسترسی مشحص مربوط به فایل‌های اجرایی هستند: <literal>setuid</literal> و <literal>setgid</literal> (که با حرف “s” نمایش می‌یابند). نکته اینکه با اغلب از “بیت” صحبت می‌کنیم، چرا که هر یک از این مقادیر می‌توانند با ۰ یا ۱ نمایش داده شوند. این دو دسترسی اجازه اجرا برنامه توسط هر کاربری که مالک آن مالک گروه آن باشد را می‌دهند. این مکانیزم اجازه دسترسی بالاتر به قابلیت‌هایی را می‌دهد که ممکن است خارج از محدوده اختیارات کاربر باشد."

msgid "<primary><literal>setuid</literal>, right</primary>"
msgstr "<primary><literal>setuid</literal>دسترسی، </primary>"

msgid "<primary><literal>setgid</literal>, right</primary>"
msgstr "<primary><literal>setgid</literal>دسترسی، </primary>"

msgid "Since a <literal>setuid</literal> root program is systematically run under the super-user identity, it is very important to ensure it is secure and reliable. Indeed, a user who would manage to subvert it to call a command of their choice could then impersonate the root user and have all rights on the system."
msgstr "از آنجا که یک برنامه <literal>setuid</literal> تحت نظارت کاربر root اجرا می‌شود، امنیت و پایداری آن از اهمیت بالایی برخوردار است. در حقیقت، کاربری که قصد استفاده از آن را دارد می‌تواند با دسترسی root به کل سیستم اشراف داشته باشد."

#, fuzzy
#| msgid "<primary><command>scp</command></primary>"
msgid "<primary><command>su</command></primary>"
msgstr "<primary><command>scp</command></primary>"

#, fuzzy
#| msgid "<primary><command>scp</command></primary>"
msgid "<primary><command>sudo</command></primary>"
msgstr "<primary><command>scp</command></primary>"

#, fuzzy
#| msgid "<primary><command>rsh</command></primary>"
msgid "<primary><command>runuser</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

msgid "If you require running a program under a different user or if a program requires higher permissions, the <command>sudo</command>, <command>su</command>, or <command>runuser</command> commands are usually better choices than using these bits (see <xref linkend=\"sect.sharing-admin-rights\" />)."
msgstr ""

msgid "A directory is handled differently. Read access gives the right to consult the list of its entries (files and directories), write access allows creating or deleting files, and execute access allows crossing through it (especially to go there with the <command>cd</command> command). Being able to cross through a directory without being able to read it gives permission to access the entries therein that are known by name, but not to find them if you do not know their existence or their exact name."
msgstr "یک دایرکتوری به شیوه متفاوتی مدیریت می‌شود. دسترسی خواندن اجازه فهرست‌گیری از محتوای آن را می‌دهد (فایل‌ها و دایرکتوری‌ها)، دسترسی نوشتن اجازه ایجاد یا حذف فایل‌ها را می‌دهد و دسترسی اجرا کردن اجازه عبور و مرور از دایرکتوری را می‌دهد (به خصوص هنگام استفاده از دستور <command>cd</command>). توانایی عبور از یک دایرکتوری بدون آنکه قادر باشیم محتوای آن را بخوانیم اجازه دسترسی به موارد شناخته شده در آن را می‌دهد، اما در صورتی که نام یا محل فایل را ندانیم نمی‌توان آن‌ها را پیدا کرد."

msgid "<emphasis>SECURITY</emphasis> <literal>setgid</literal> directory and <emphasis>sticky bit</emphasis>"
msgstr "<emphasis>امنیت</emphasis> دایرکتوری <literal>setgid</literal> همراه با <emphasis>sticky bit</emphasis>"

msgid "<primary><literal>setgid</literal> directory</primary>"
msgstr "<primary><literal>setgid</literal> دایرکتوری</primary>"

msgid "The <literal>setgid</literal> bit also applies to directories. Any newly-created item in such directories is automatically assigned the owner group of the parent directory, instead of inheriting the creator's main group as usual. This setup avoids the user having to change its main group (with the <command>newgrp</command> command) when working in a file tree shared between several users of the same dedicated group."
msgstr "بیت <literal>setgid</literal> همچنین بر دایرکتوری نیز اعمال می‌شود. هر محتوای جدیدی که داخل آن ایجاد گردد بجای آنکه گروه اصلی کاربر ایجادکننده را شامل شود به صورت خودکار گروه مالک دایرکتوری والد را به ارث می‌برد. این گروه از تغییر نام گروه اصلی توسط کاربر جلوگیری می‌کند (با دستور <command>newgrp</command>) زمانی که در یک ساختار درختی از فایل‌های اشتراکی بین کاربران یک گروه استفاده شود."

#, fuzzy
#| msgid "<primary><command>chgrp</command></primary>"
msgid "<primary><command>newgrp</command></primary>"
msgstr "<primary><command>chgrp</command></primary>"

msgid "<primary>sticky bit</primary>"
msgstr "<primary>بیت چسبنده</primary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>permissions</primary><secondary><literal>t</literal></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "The “sticky” bit (symbolized by the letter “t”) is a permission that is only useful in directories. It is especially used for temporary directories where everybody has write access (such as <filename>/tmp/</filename>): it restricts deletion of files so that only their owner (or the owner of the parent directory) can do it. Lacking this, everyone could delete other users' files in <filename>/tmp/</filename>."
msgstr "بیت “چسبنده” (که با حرف “t” نمایش می‌یابد) نوعی مجوز است که تنها در دایرکتوری‌ها بکار می‌رود. به طور مخصوص در دایرکتوری‌های موقتی استفاده می‌شود که همگان دسترسی نوشتن داشته باشند (مانند <filename>/tmp/</filename>): از حذف فایل‌ها جلوگیری می‌کند به صورتی که تنها مالک فایل (یا مالک دایرکتوری والد) قادر به انجام آن باشد. بدون این ویژگی، هر کسی می‌تواند محتوای موجود در <filename>/tmp/</filename> را حذف کند."

msgid "Three commands control the permissions associated with a file:"
msgstr "سه دستور وجود دارند که مجوزهای مربوط به یک فایل را کنترل می‌کنند:"

msgid "<primary><command>chown</command></primary>"
msgstr "<primary><command>chown</command></primary>"

msgid "<command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command> changes the owner of the file;"
msgstr "<command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command> مالک فایل را تغییر می‌دهد؛"

msgid "<primary><command>chgrp</command></primary>"
msgstr "<primary><command>chgrp</command></primary>"

msgid "<command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command> alters the owner group;"
msgstr "<command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command> گروه مالک را تغییر می‌دهد؛"

msgid "<primary><command>chmod</command></primary>"
msgstr "<primary><command>chmod</command></primary>"

msgid "<command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command> changes the permissions for the file."
msgstr "<command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command> مجوزهای مربوط به فایل را تغییر می‌دهد."

#, fuzzy
#| msgid "<primary>octal representation of rights</primary>"
msgid "<primary>symbolic representation of rights</primary>"
msgstr "<primary>نمایش عددی دسترسی‌ها</primary>"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgid "<primary>rights</primary><secondary>symbolic representation</secondary>"
msgstr "<primary>دسترسی‌ها</primary><secondary>نمایش عددی</secondary>"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgid "<primary>permissions</primary><secondary>symbolic representation</secondary>"
msgstr "<primary>دسترسی‌ها</primary><secondary>نمایش عددی</secondary>"

msgid "There are two ways of presenting rights. Among them, the symbolic representation is probably the easiest to understand and remember. It involves the letter symbols mentioned above. You can define rights for each category of users (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), by setting them explicitly (with <literal>=</literal>), by adding (<literal>+</literal>), or subtracting (<literal>-</literal>). Thus the <literal>u=rwx,g+rw,o-r</literal> formula gives the owner read, write, and execute rights, adds read and write rights for the owner group, and removes read rights for other users. Rights not altered by the addition or subtraction in such a command remain unmodified. The letter <literal>a</literal>, for “all”, covers all three categories of users, so that <literal>a=rx</literal> grants all three categories the same rights (read and execute, but not write)."
msgstr "دو روش برای ارائه دسترسی‌ها وجود دارد. از میان آن‌ها، شیوه نمادین به سادگی فرا گرفته و آموخته می‌شود. این شیوه شامل حروف نمادین ذکر شده در بالا هستند. می‌توانید برای هر دسته‌بندی از کاربران (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>) دسترسی تعیین کنید با تنظیم آن‌ها به صورت انفرادی (با <literal>=</literal>)، با افزودن (<literal>+</literal>) یا کاستن (<literal>-</literal>). بنابراین فرمول <literal>u=rwx,g+rw,o-r</literal> به مالک فایل دسترسی خواندن، نوشتن و اجراکردن، به گروه مالک دسترسی خواندن و نوشتن و دسترسی خواندن را از سایر افراد می‌گیرد. دسترسی‌هایی که در چنین دستوری ذکر نشده باشند بدون تغییر باقی می‌مانند. حرف <literal>a</literal>، به معنی “all”، تمام دسته‌بندی‌های کاربران را شامل می‌شود. بنابراین، <literal>a=rx</literal> به سه دسته‌بندی موجود تمام دسترسی‌ها را (خواندن و اجراکردن، ولی نه نوشتن) می‌دهد."

msgid "<primary>octal representation of rights</primary>"
msgstr "<primary>نمایش عددی دسترسی‌ها</primary>"

msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgstr "<primary>دسترسی‌ها</primary><secondary>نمایش عددی</secondary>"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgid "<primary>permissions</primary><secondary>octal representation</secondary>"
msgstr "<primary>دسترسی‌ها</primary><secondary>نمایش عددی</secondary>"

msgid "The (octal) numeric representation associates each right with a value: 4 for read, 2 for write, and 1 for execute. We associate each combination of rights with the sum of the figures. Each value is then assigned to different categories of users by putting them end to end in the usual order (owner, group, others)."
msgstr "نمایش عددی (اوکتال) هر دسترسی را به یک عدد نسبت می‌دهد: ۴ برای خواندن، ۲ برای نوشتن و ۱ برای اجراکردن. ترکیب دسترسی‌های یک گروه را با جمع اعداد آن به دست می‌آوریم. هر مقدار به دسته‌بندی‌های مختلف کاربران نسبت داده می‌شود درست به همان ترتیبی که قرار دارند (مالک، گروه و دیگران)."

#, fuzzy
#| msgid "For instance, the <command>chmod 754 <replaceable>file</replaceable></command> command will set the following rights: read, write and execute for the owner (since 7 = 4 + 2 + 1); read and execute for the group (since 5 = 4 + 1); read-only for others. The <literal>0</literal> means no rights; thus <command>chmod 600 <replaceable>file</replaceable></command> allows for read/write rights for the owner, and no rights for anyone else. The most frequent right combinations are <literal>755</literal> for executable files and directories, and <literal>644</literal> for data files."
msgid "For instance, the <command>chmod 754 <replaceable>file</replaceable></command> command will set the following rights: read, write and execute for the owner (since 7 = 4 + 2 + 1); read and execute for the group (since 5 = 4 + 1); read-only for others. The <literal>0</literal> (zero) means no rights; thus <command>chmod 600 <replaceable>file</replaceable></command> allows for read/write rights for the owner, and no rights for anyone else. The most frequent right combinations are <literal>755</literal> for executable files and directories, and <literal>644</literal> for data files."
msgstr "برای نمونه، دستور <command>chmod 754 <replaceable>file</replaceable></command> دسترسی‌های زیر را تنظیم می‌کند: خواندن، نوشتن و اجراکردن برای مالک (چرا که ۷ = ۴ + ۲ + ۱)؛ خواندن و اجراکردن برای گروه (چرا که ۵ = ۴ + ۱)؛ خواندن برای دیگران. عدد <literal>0</literal> یعنی دسترسی وجود ندارد؛ بنابراین دستور <command>chmod 600 <replaceable>file</replaceable></command> اجازه دسترسی خواندن و نوشتن را به مالک می‌دهد و هیچ دسترسی دیگری را شامل نمی‌شود. متداول‌ترین دسترسی‌های موجود عبارتند از <literal>755</literal> برای فایل‌ها و دایرکتوری‌های قابل اجرا و <literal>644</literal> برای فایل‌های داده‌ای."

#, fuzzy
#| msgid "<primary><literal>setuid</literal>, right</primary>"
msgid "<primary><literal>setuid</literal></primary>"
msgstr "<primary><literal>setuid</literal>دسترسی، </primary>"

#, fuzzy
#| msgid "<primary><literal>setgid</literal>, right</primary>"
msgid "<primary><literal>setgid</literal></primary>"
msgstr "<primary><literal>setgid</literal>دسترسی، </primary>"

msgid "To represent special rights, you can prefix a fourth digit to this number according to the same principle, where the <literal>setuid</literal>, <literal>setgid</literal> and <literal>sticky</literal> bits are 4, 2 and 1, respectively. <command>chmod 4754</command> will associate the <literal>setuid</literal> bit with the previously described rights."
msgstr "برای نمایش دسترسی‌های ویژه، می‌توانید یک عدد چهارم نیز به قبل از آن اضافه کنید که بیت‌های <literal>setuid</literal>، <literal>setgid</literal> و <literal>sticky</literal> به ترتیب نشانگر ۴ و ۲ و ۱ هستند. دستور <command>chmod 4754</command> بیت <literal>setuid</literal> را به همراه دسترسی‌های موجود اضافه می‌کند."

msgid "Note that the use of octal notation only allows to set all the rights at once on a file; you cannot use it to simply add a new right, such as read access for the group owner, since you must take into account the existing rights and compute the new corresponding numerical value."
msgstr "نکته اینکه استفاده از شیوه عددی برای تنظیم تمام دسترسی‌ها بکار می‌رود؛ پس نمی‌توانید از آن برای افزودن تنها یک دسترسی، مانند دسترسی خواندن برای گروه مالک، استفاده کنید چرا که باید تمام دسترسی‌های موجود و اعداد مربوط به آن‌ها را نیز به حساب بیاورید."

msgid "<emphasis>TIP</emphasis> Recursive operation"
msgstr "<emphasis>نکته</emphasis> عملیات بازگشتی"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgid "<primary>permissions</primary><secondary>recursive operation</secondary>"
msgstr "<primary>دسترسی‌ها</primary><secondary>نمایش عددی</secondary>"

msgid "Sometimes we have to change rights for an entire file tree. All the commands above have a <literal>-R</literal> option to operate recursively in sub-directories."
msgstr "بعضی وقت‌ها باید دسترسی‌های تمام درخت فایل را تغییر دهیم. تمام دستورات بالا شامل گزینه <literal>-R</literal> هستند که امکان عملیات بازگشتی روی دایرکتوری‌ها را فراهم می‌آورد."

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>permissions</primary><secondary><literal>X</literal></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

#, fuzzy
#| msgid "The distinction between directories and files sometimes causes problems with recursive operations. That is why the “X” letter has been introduced in the symbolic representation of rights. It represents a right to execute which applies only to directories (and not to files lacking this right). Thus, <command>chmod -R a+X <replaceable>directory</replaceable></command> will only add execute rights for all categories of users (<literal>a</literal>) for all of the sub-directories and files for which at least one category of user (even if their sole owner) already has execute rights."
msgid "The distinction between directories and files sometimes causes problems with recursive operations. That is why the “<literal>X</literal>” letter has been introduced in the symbolic representation of rights. It also represents the right to execute, but it applies differently to directories and files."
msgstr "تفاوت بین فایل‌ها و دایرکتوری‌ها بعضی وقت‌ها برای عملیات بازگشتی مشکل آفرین می‌شود. به همین دلیل است که حرف “X” را در شیوه نمادین دسترسی‌ها معرفی کردیم. این حرف نشانگر اجرای یک دسترسی تنها روی دایرکتوری‌ها است (و نه فایل‌هایی که فاقد این دسترسی هستند). بنابراین، دستور <command>chmod -R a+X <replaceable>directory</replaceable></command> تنها دسترسی اجراکردن را برای تمام دسته‌بندی کاربران (<literal>a</literal>) برای تمام دایرکتوری‌های فرزند و فایل‌هایی که حداقل یک دسته‌بندی از کاربر (حتی برای مالک انحصاری آن‌ها) هم‌اکنون دسترسی اجراکردن را داشته باشد، بکار می‌رود."

msgid "For directories it adds executable permissions to the chosen user(s). For files, it adds the executable bit <emphasis>only</emphasis> if at least one of the users (owner, group, or others) already has executable permissions. Let's demonstrate it, because this bit can be confusing:"
msgstr ""

msgid ""
"<computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rw-r--r-- 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  <computeroutput>$ </computeroutput><userinput>chmod u+X test.txt</userinput>\n"
"  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rw-r--r-- 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  <computeroutput>$ </computeroutput><userinput>chmod o+x test.txt</userinput>\n"
"  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rw-r--r-x 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  <computeroutput>$ </computeroutput><userinput>chmod u+X test.txt</userinput>\n"
"  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rwxr--r-x 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  "
msgstr ""

msgid "The example shows a typical file with its default permissions: its owner can read and write it, the owner's group and all other users can read it. The next operation (<literal>u+X</literal>) won't add executable permissions for the owner of the file, because permissions to execute have not been assigned. The operation has no effect on the file. Next we assign execute rights for \"other\" users and repeat the operation. This time it is successful, because at least one user group already had executable permissions."
msgstr ""

msgid "It is a misconception that this bit will only affect directories. If files and directories have mixed permissions, it is often a good idea to use the <command>find</command> command to locate the targets you want to operate on."
msgstr ""

#, fuzzy
#| msgid "<emphasis>TIP</emphasis> Changing the user and group"
msgid "<emphasis>TIP</emphasis> Changing the user and group together"
msgstr "<emphasis>نکته</emphasis> تغییر کاربر و گروه"

#, fuzzy
#| msgid "Frequently you want to change the group of a file at the same time that you change the owner. The <command>chown</command> command has a special syntax for that: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>"
msgid "Frequently you want to change the group of a file at the same time that you change the owner. The <command>chown</command> command has a special syntax for that: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>. This syntax can also be used to recursively (<literal>-R</literal>) change the ownership of a whole directory."
msgstr "بسیار پیش می‌آید که می‌خواهید به طور همزمان گروه و کاربر یک فایل را تغییر دهید. دستور <command>chown</command> یک شیوه بخصوص برای اینکار دارد: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>"

msgid "<emphasis>GOING FURTHER</emphasis> <command>umask</command>"
msgstr "<emphasis>مطالعه بیشتر</emphasis> <command>umask</command>"

#, fuzzy
#| msgid "<primary><command>at</command></primary>"
msgid "<primary><command>umask</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "When an application creates a file, it assigns indicative permissions, knowing that the system automatically removes certain rights, given by the command <command>umask</command>. Enter <command>umask</command> in a shell; you will see a mask such as <computeroutput>0022</computeroutput>. This is simply an octal representation of the rights to be systematically removed (in this case, the write right for the group and other users)."
msgid "When an application creates a file, it assigns indicative permissions, knowing that the system automatically removes certain rights, given by the command <command>umask</command>. Enter <command>umask</command> in a shell; you will see a mask such as <computeroutput>0022</computeroutput>. This is simply an octal representation of the rights to be systematically removed. In this case, the write right for the group and other users: With the above umask value, the default for directories <literal>777</literal> becomes <literal>755</literal> and the default permissions for files <literal>666</literal> become <literal>644</literal>."
msgstr "زمانی که یک برنامه اقدام به ایجاد فایل می‌کند، به آن دسترسی‌های مشخصی اعطا می‌کند، با اینکه می‌داند سیستم به صورت خودکار و با استفاده از <command>umask</command> دسترسی‌ها اضافی را از بین می‌برد. <command>umask</command> را در یک پوسته اجرا کنید؛ یک ماسک به صورت <computeroutput>0022</computeroutput> را می‌بینید. این عدد نشانگر دسترسی‌هایی است که باید حذف گردند (در این مورد، دسترسی نوشتن برای گروه و سایر کاربران)."

msgid "<primary>rights</primary><secondary>mask</secondary>"
msgstr "<primary>دسترسی‌ها</primary><secondary>ماسک</secondary>"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>mask</secondary>"
msgid "<primary>permissions</primary><secondary>umask</secondary>"
msgstr "<primary>دسترسی‌ها</primary><secondary>ماسک</secondary>"

msgid "<primary>mask</primary><secondary>rights mask</secondary>"
msgstr "<primary>ماسک</primary><secondary>دسترسی‌های ماسک</secondary>"

#, fuzzy
#| msgid "All these details are documented in the <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgid "The system's default value is handled by <citerefentry><refentrytitle>pam_umask</refentrytitle> <manvolnum>8</manvolnum></citerefentry> and <filename>/etc/login.defs</filename>."
msgstr "تمام این جزئیات در صفحه راهنمای <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> مستندسازی شده‌اند."

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/login.defs</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

#, fuzzy
#| msgid "If you give it a new octal value, the <command>umask</command> command modifies the mask. Used in a shell initialization file (for example, <filename>~/.bash_profile</filename>), it will effectively change the default mask for your work sessions."
msgid "If you give it a new octal value, the <command>umask</command> command modifies the mask. Used in a shell initialization file (for example, <filename>~/.bashrc</filename> or <filename>~/.profile</filename>), it will effectively change the default mask for your work sessions."
msgstr "اگر عدد اوکتال دیگری به آن نسبت دهید، دستور <command>umask</command> اقدام به تغییر ماسک می‌کند. اگر اینکار را در یک فایل راه‌انداز پوسته ثبت کنید (برای نمونه، <filename>~/.bash_profile</filename>)، ماسک پیش‌فرض برای نشست‌های کاری شما را تغییر می‌دهد."

msgid "ACLs - Access Control Lists"
msgstr ""

#, fuzzy
#| msgid "<primary>ACPI</primary>"
msgid "<primary>ACL</primary>"
msgstr "<primary>ACPI</primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>Access Control List</primary><see>ACL</see>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">acl</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"

msgid "Many filesystems, e.g. Btrfs, Ext3, Ext4, JFS, XFS, etc., support the use of Access Control Lists (ACLs). These extend the basic features of file ownership and permission, described in the previous section, and allow for a more fine-grained control of each (file) object. For example: A user wants to share a file with another user and that user should only be able to read the file, but not write or change it."
msgstr ""

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/fstab</filename></secondary>"
msgstr "<primary>مدیر</primary><secondary>مدیر نمایش</secondary>"

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary>ACL</primary><secondary><literal>acl</literal></secondary>"
msgstr "<primary>کلاینت</primary><secondary>معماری کلاینت/سرور</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>ACL</primary><secondary><literal>noacl</literal></secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "For some of the filesystems, the usage of ACLs is enabled by default (e.g. Btrfs, Ext3, Ext4). For other filesystems or older systems it must be enabled using the <literal>acl</literal> mount option - either in the <command>mount</command> command directly or in <filename>/etc/fstab</filename>. In the same way the usage of ACLs can be disabled by using the <literal>noacl</literal> mount option. For Ext* filesystems one can also use the <command>tune2fs -o [no]acl /dev/<replaceable>device</replaceable></command> command to enable/disable the usage of ACLs by default. The default values for each filesystem can usually be found in their homonym manual pages in section 5 (<citerefentry><refentrytitle><replaceable>filesystem</replaceable></refentrytitle> <manvolnum>5</manvolnum></citerefentry>) or in <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry>."
msgstr ""

msgid "After enabling ACLs, permissions can be set using the <citerefentry><refentrytitle>setfacl</refentrytitle> <manvolnum>1</manvolnum></citerefentry> command, while <citerefentry><refentrytitle>getfacl</refentrytitle> <manvolnum>1</manvolnum></citerefentry> allows one to retrieve the ACLs for a given object or path. These commands are part of the <emphasis role=\"pkg\">acl</emphasis> package. With <command>setfacl</command> one can also configure newly created files or directories to inherit permissions from the parent directory. It is important to note that ACLs are processed in their order and that an earlier entry that fits the situation has precedence over later entries."
msgstr ""

msgid "If a file has ACLs set, the output of the <command>ls -l</command> command will show a plus-sign after the traditional permissions. When using ACLs, the <command>chmod</command> command behaves slightly different, and <command>umask</command> might be ignored. The extensive documentation, e.g. <citerefentry><refentrytitle>acl</refentrytitle> <manvolnum>5</manvolnum></citerefentry> contains more information."
msgstr ""

msgid "Administration Interfaces"
msgstr "رابط‌های مدیریتی"

msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

msgid "<primary>administration, interfaces</primary>"
msgstr "<primary>مدیریتی، رابط‌ها</primary>"

msgid "Using a graphical interface for administration is interesting in various circumstances. An administrator does not necessarily know all the configuration details for all their services, and doesn't always have the time to go seeking out the documentation on the matter. A graphical interface for administration can thus accelerate the deployment of a new service. It can also simplify the setup of services which are hard to configure."
msgstr "استفاده از یک رابط گرافیکی برای مدیریت سیستم گزینه جالبی در بسیاری موارد به حساب می‌آید. یک مدیرسیستم الزاما تمام جزئیات پیکربندی تمام سرویس‌ها را نمی‌داند، همیشه نیز زمان کافی برای بررسی مستندات مورد نیاز خود ندارد. یک رابط گرافیکی برای انجام امور مدیریتی می‌تواند زمان برپایی یک سرویس جدید را کاهش دهد. همچنین می‌تواند فرآیند برپایی سرویس‌هایی که دشوار هستند را تسهیل بخشد."

msgid "Such an interface is only an aid, and not an end in itself. In all cases, the administrator must master its behavior in order to understand and work around any potential problem."
msgstr "چنین رابطی یک ابزار میانی به حساب می‌آید، اما گزینه نهایی نیست. در تمام موارد، مدیرسیستم باید با جنبه‌های گوناگون آن آشنا باشد تا بتواند مشکلات را به راحتی عیب‌زدایی کند."

msgid "Since no interface is perfect, you may be tempted to try several solutions. This is to be avoided as much as possible, since different tools are sometimes incompatible in their work methods. Even if they all aim to be very flexible and try to adopt the configuration file as a single reference, they are not always able to integrate external changes."
msgstr "از آنجا که هیچ رابط گرافیکی کاملی وجود ندارد، ممکن است بخواهید گزینه‌های مختلفی را امتحان کنید. البته اینکار تا آنجا که ممکن است نباید انجام شود، چرا که رابط‌های گوناگون شیوه‌هایی متفاوتی را برای حل مساله بیان می‌کنند. حتی اگر در انجام امور خیلی انعطاف‌پذیر باشند و به فایل پیکربندی به عنوان منبع نگاه کنند، همیشه نمی‌توانند تغییرات خارجی اعمال شده روی آن را مدیریت کنند."

msgid "Administrating on a Web Interface: <command>webmin</command>"
msgstr "مدیریت سیستم با استفاده از یک رابط تحت-وب: <command>webmin</command>"

msgid "<primary><emphasis>webmin</emphasis></primary>"
msgstr "<primary><emphasis>webmin</emphasis></primary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary>administration, interfaces</primary><secondary><emphasis>webmin</emphasis></secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

msgid "This is, without a doubt, one of the most successful administration interfaces. It is a modular system managed through a web browser, covering a wide array of areas and tools. Furthermore, it is internationalized and available in many languages."
msgstr "این گزینه، بودن شک، یکی از موفق‌ترین رابط‌های مدیریتی سیستم به شمار می‌رود. یک سیستم ماژولار است که از طریق مرورگر مدیریت می‌گردد که قسمت اعظمی از تنظیمات و ابزارها را شامل می‌شود. علاوه بر این، قابلیت چند زبانه بودن دارد که می‌تواند در هر زبانی استفاده گردد."

msgid "Webmin dashboard"
msgstr ""

#, fuzzy
#| msgid "Sadly, <command>webmin</command> is no longer part of Debian. Its Debian maintainer — Jaldhar H. Vyas — removed the packages he created because he no longer had the time required to maintain them at an acceptable quality level. Nobody has officially taken over, so <emphasis role=\"distribution\">Jessie</emphasis> does not have the <command>webmin</command> package."
msgid "Sadly, <command>webmin</command> is no longer part of Debian. Its Debian maintainer removed the packages created because they no longer had the time required to maintain them at an acceptable quality level. Nobody has officially taken over, so Debian does not provide the <command>webmin</command> package."
msgstr "متاسفانه، <command>webmin</command> دیگر بخشی از دبیان نیست. مدیربسته دبیان آن - Jaldhar H. Vyas - بسته‌های تولیدشده خود را به دلیل اینکه زمان کافی برای بهبود عملکرد و کیفیت آن را نداشت حذف کرد. تا کنون هیچکس به صورت رسمی توسعه آن را قبول نکرده است، بنابراین <emphasis role=\"distribution\">Jessie</emphasis> شامل بسته‌ای به نام <command>webmin</command> نیست."

msgid "There is, however, an unofficial package distributed on the <literal>webmin.com</literal> website. Contrary to the original Debian packages, this package is monolithic; all of its configuration modules are installed and activated by default, even if the corresponding service is not installed on the machine."
msgstr "اگرچه، یک بسته غیررسمی روی وبسایت <literal>webmin.com</literal> موجود است. برخلاف بسته‌های اصلی دبیان، این بسته ساختاری یکپارچه دارد؛ تمام ماژول‌های پیکربندی آن به صورت پیش‌فرض نصب و فعال می‌شوند، با اینکه ممکن است سرویس متناظر با آن‌ها روی سیستم موجود نباشد."

msgid "<emphasis>SECURITY</emphasis> Changing the root password"
msgstr "<emphasis>امنیت</emphasis> تغییر گذرواژه root"

#, fuzzy
#| msgid "On the first login, identification is conducted with the root username and its usual password. It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the root password for the server will not be involved, even if this confers important administrative rights to the machine."
msgid "On the first login, identification is conducted with the root username and its usual password (or any user's login credentials which belongs to the <literal>sudo</literal> group). It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the server's user accounts will not be involved, even if this confers important administrative rights to the machine."
msgstr "در اولین ورود، احراز هویت با استفاده از حساب کاربری root و گذرواژه آن صورت می‌گیرد. توصیه می‌شود که در اولین فرصت گذرواژه <command>webmin</command> تغییر یابد، چرا که در زمان نفوذ به سیستم، گذرواژه حساب کاربری root سیستم درگیر نشود، حتی اگر باعث اعطاکردن دسترسی‌های مهم به سیستم شده باشد."

#, fuzzy
#| msgid "Beware! Since <command>webmin</command> has so many features, a malicious user accessing it could compromise the security of the entire system. In general, interfaces of this kind are not recommended for important systems with strong security constraints (firewall, sensitive servers, etc.)."
msgid "Beware! Since <command>webmin</command> has so many features, a malicious user accessing it could compromise the security of the entire system. In general, interfaces of this kind are not recommended for important systems with strong security constraints (firewall, sensitive servers, etc.), and they are not recommended to be exposed to the public either."
msgstr "آگاه باشید! از آنجا که <command>webmin</command> شامل ویژگی‌های بسیاری است، یک کاربر خرابکار می‌تواند امنیت کل سیستم را از بین ببرد. در حالت عمومی، رابط‌های گرافیکی از این دست گزینه‌های مناسبی برای سیستم‌های مهم با مدل‌های امنیت پیشرفته نیستند (دیوارآتش، سرورهای حساس و از این قبیل)."

msgid "Webmin is used through a web interface, but it does not require Apache to be installed. Essentially, this software has its own integrated mini web server. This server listens by default on port 10000 and accepts secure HTTP connections."
msgstr "Webmin از طریق یک رابط وب استفاده می‌شود، اما برای استفاده نیاز به سرور آپاچی ندارد. در حقیقت، این نرم‌افزار یک وب‌سرور کوچک مخصوص به خود را دارد. این سرور به صورت پیش‌فرض به پورت ۱۰۰۰۰ گوش می‌دهد و درخواست‌های امن HTTP را می‌پذیرد."

msgid "Included modules cover a wide variety of services, among which:"
msgstr "ماژول‌های داخل آن شامل سرویس‌های بسیار متنوعی هستند، از جمله:"

#, fuzzy
#| msgid "all base services: creation of users and groups, management of <filename>crontab</filename> files, init scripts, viewing of logs, etc."
msgid "all base services: creation of users and groups, management of <filename>crontab</filename> files, service scripts/files, viewing of logs, etc."
msgstr "تمام سرویس‌های پایه: ایجاد کاربران و گروه‌ها، مدیریت فایل‌های <filename>crontab</filename>، اسکریپت‌های راه‌انداز، مشاهده فایل‌های گزارش و از این قبیل."

msgid "bind: DNS server configuration (name service);"
msgstr "bind: پیکربندی سرور DNS (نام سرویس)؛"

msgid "postfix: SMTP server configuration (e-mail);"
msgstr "postfix: پیکربندی سرور SMTP (ایمیل)؛"

#, fuzzy
#| msgid "inetd: configuration of the <command>inetd</command> super-server;"
msgid "network services: configuration of the <command>xinetd</command> super-server;"
msgstr "inetd: پیکربندی ابر-سرور <command>inetd</command>؛"

#, fuzzy
#| msgid "quota: user quota management;"
msgid "disk quota: user quota management;"
msgstr "quota: مدیریت فضای دیسک کاربر؛"

msgid "dhcpd: DHCP server configuration;"
msgstr "dhcpd: پیکربندی سرور DHCP؛"

msgid "proftpd: FTP server configuration;"
msgstr "proftpd: پیکربندی سرور FTP؛"

msgid "samba: Samba file server configuration;"
msgstr "samba: پیکربندی سرور فایل Samba؛"

msgid "software: installation or removal of software from Debian packages and system updates."
msgstr "software: نصب و حذف نرم‌افزار از بسته‌های دبیان و بروزرسانی سیستم."

msgid "The administration interface is available in a web browser at <literal>https://localhost:10000</literal>. Beware! Not all the modules are directly usable. Sometimes they must be configured by specifying the locations of the corresponding configuration files and some executable files (program). Frequently the system will politely prompt you when it fails to activate a requested module."
msgstr "رابط مدیریتی توسط یک مرورگر وب از نشانی <literal>https://localhost:10000</literal> قابل دسترس است. آگاه باشید! تمام ماژول‌ها به طور مستقیم قابل استفاده نیستند. بعضی وقت‌ها نیاز است که مسیر فایل‌های پیکربندی و برنامه‌های اجرایی به خصوصی را برای آن‌ها مشخص کنید. معمولا سیستم هر گاه نتواند یک ماژول خواسته شده را فعال کند از شما به شکل محترمانه‌ای پرسش‌های خود را مطرح می‌کند."

msgid "<emphasis>ALTERNATIVE</emphasis> GNOME control center"
msgstr "<emphasis>جایگزین</emphasis> مرکز کنترل GNOME"

msgid "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"

msgid "The GNOME project also provides multiple administration interfaces that are usually accessible via the “Settings” entry in the user menu on the top right. <command>gnome-control-center</command> is the main program that brings them all together but many of the system wide configuration tools are effectively provided by other packages (<emphasis role=\"pkg\">accountsservice</emphasis>, <emphasis role=\"pkg\">system-config-printer</emphasis>, etc.). Although they are easy to use, these applications cover only a limited number of base services: user management, time configuration, network configuration, printer configuration, and so on."
msgstr "پروژه GNOME نیز چندین رابط مدیریتی که معمولا از گزینه “Settings” در منوی کاربری در سمت راست و بالای صفحه قرار دارد را ارائه می‌دهد. <command>gnome-control-center</command> برنامه اصلی است که تمام ابزار پیکربندی سیستم را در کنار یکدیگر جمع می‌کند اما این ابزار خود از بسته‌های گوناگونی آمده‌اند (<emphasis role=\"pkg\">accountsservice</emphasis>، <emphasis role=\"pkg\">system-config-printer</emphasis> و از این قبیل). اگرچه استفاده از آن‌ها ساده است، این برنامه‌ها تنها تعداد محدودی از سرویس‌های پایه را پوشش می‌دهند: مدیریت کاربر، پیکربندی زمان، پیکربندی شبکه، پیکربندی چاپگر و به همین ترتیب."

msgid "Configuring Packages: <command>debconf</command>"
msgstr "پیکربندی بسته‌ها: <command>debconf</command>"

#, fuzzy
#| msgid "<primary><command>dpkg-reconfigure</command></primary>"
msgid "<primary><command>debconf</command></primary><seealso><command>dpkg-reconfigure</command></seealso>"
msgstr "<primary><command>dpkg-reconfigure</command></primary>"

#, fuzzy
#| msgid "<primary><command>dpkg-reconfigure</command></primary>"
msgid "<primary><command>dpkg-reconfigure</command></primary><seealso><command>debconf</command></seealso>"
msgstr "<primary><command>dpkg-reconfigure</command></primary>"

#, fuzzy
#| msgid "Many packages are automatically configured after asking a few questions during installation through the Debconf tool. These packages can be reconfigured by running <command>dpkg-reconfigure <replaceable>package</replaceable></command>."
msgid "Many packages are automatically configured after asking a few questions during installation through the Debconf tool. These packages can be reconfigured by running <command>dpkg-reconfigure -p<replaceable>level</replaceable> <replaceable>package</replaceable></command>."
msgstr "بسیاری از بسته‌ها هنگام فرآیند نصب توسط ابزار Debconf پس از پرسیدن چند پرسش پیکربندی می‌شوند. این بسته‌ها مجدد می‌توانند با استفاده از دستور <command>dpkg-reconfigure <replaceable>package</replaceable></command> پیکربندی گردند."

msgid "For most cases, these settings are very simple; only a few important variables in the configuration file are changed. These variables are often grouped between two “demarcation” lines so that reconfiguration of the package only impacts the enclosed area. In other cases, reconfiguration will not change anything if the script detects a manual modification of the configuration file, in order to preserve these human interventions (because the script can't ensure that its own modifications will not disrupt the existing settings)."
msgstr "در اکثر موارد، این تنظیمات بسیار ساده هستند؛ تنها تعداد معدودی متغیر در فایل‌های پیکربندی تغییر می‌کنند. این متغیرها اغلب بین دو خط “علامت‌گذاری” می‌شوند تا پیکربندی مجدد بسته تنها در قسمت مربوطه اعمال شود. در سایر موارد، پیکربندی مجدد در صورت مشاهده تغییرات دستی در فایل‌های پیکربندی، هیچ تغییری را انجام نمی‌دهد (چرا که اسکریپت نمی‌تواند تشخیص دهد که تغییرات خود منجر به اختلال در سیستم موجود می‌گردد یا خیر)."

msgid "<emphasis>DEBIAN POLICY</emphasis> Preserving changes"
msgstr "<emphasis>خط‌مشی دبیان</emphasis> حفظ تغییرات"

#, fuzzy
#| msgid "<primary>backup</primary><secondary>copy</secondary>"
msgid "<primary>Debian Project</primary><secondary>policy</secondary>"
msgstr "<primary>پشتیبان</primary><secondary>رونوشت</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>configuration</primary><secondary>files</secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "The Debian Policy expressly stipulates that everything should be done to preserve manual changes made to a configuration file, so more and more scripts take precautions when editing configuration files. The general principle is simple: the script will only make changes if it knows the status of the configuration file, which is verified by comparing the checksum of the file against that of the last automatically generated file. If they are the same, the script is authorized to change the configuration file. Otherwise, it determines that the file has been changed and asks what action it should take (install the new file, save the old file, or try to integrate the new changes with the existing file). This precautionary principle has long been unique to Debian, but other distributions have gradually begun to embrace it."
msgstr "خط‌مشی دبیان بیان می‌کند که هر گونه تغییر دستی در فایل‌های پیکربندی باید حفظ شوند، بنابراین اسکریپت‌های بیشتری هنگام ویرایش این فایل‌ها به این اصل توجه می‌کنند. اصل عمومی ساده است: اسکریپت تنها زمانی تغییرات را اعمال می‌کند اگر از وضعیت فایل پیکربندی آگاه باشد، که این امر با بررسی checksum موجود از فایل با آخرین نسخه تولید شده آن صورت می‌گیرد. اگر یکی باشند آنگاه اسکریپت اقدام به تغییر فایل می‌نماید. در غیر اینصورت، تشخیص می‌دهد که فایل تغییر کرده و از کاربر می‌پرسد چه اقدامی باید صورت گیرد (استفاده از فایل جدید، ذخیره‌سازی فایل قدیم یا تلاش برای ادعام هر دو فایل). این اصل احتیاطی مدت طولانی است که در دبیان وجود دارد اما امروزه سایر توزیع‌ها نیز از آن بهره می‌برند."

msgid "<primary><command>ucf</command></primary>"
msgstr "<primary><command>ucf</command></primary>"

msgid "The <command>ucf</command> program (from the Debian package of the same name) can be used to implement such a behavior."
msgstr "برنامه <command>ucf</command> (از بسته دبیان با همین نام) می‌تواند برای پیاده‌سازی چنین عملکردی استفاده شود."

msgid "<command>syslog</command> System Events"
msgstr "<command>syslog</command> رویدادهای سیستمی"

msgid "<primary><command>rsyslogd</command></primary>"
msgstr "<primary><command>rsyslogd</command></primary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>file</primary><secondary>log file</secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

#, fuzzy
#| msgid "<primary>logs</primary><secondary>dispatching</secondary>"
msgid "<primary>log files</primary><secondary>dispatching</secondary>"
msgstr "<primary>گزارش‌ها</primary><secondary>مخابره‌کردن</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>log files</primary><seealso><filename>/var/log</filename></seealso>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "Principle and Mechanism"
msgstr "اصل و مکانیزم"

msgid "The <command>rsyslogd</command> daemon is responsible for collecting service messages coming from applications and the kernel, then dispatching them into log files (usually stored in the <filename>/var/log/</filename> directory). It obeys the <filename>/etc/rsyslog.conf</filename> configuration file."
msgstr "فرآیند پس‌زمینه <command>rsyslogd</command> مسئول دریافت پیام‌های ارسالی از کرنل و برنامه‌های مختلف است تا آن‌ها را به فایل‌های گزارش مخابره کند (که معمولا در دایرکتوری <filename>/var/log/</filename> ذخیره می‌شوند). این دستور از فایل پیکربندی <filename>/etc/rsyslog.conf</filename> تبعیت می‌کند."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rsyslog.conf</filename></secondary><see><command>rsyslogd</command></see>"
msgstr ""

msgid "Each log message is associated with an application subsystem (called “facility” in the documentation):"
msgstr "هر پیام گزارش متناسب با یک زیرسیستم از برنامه است (که در مستندات با نام “facility” شناخته می‌شود):"

#, fuzzy
#| msgid "<primary><command>rsyslogd</command></primary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>facility</secondary>"
msgstr "<primary><command>rsyslogd</command></primary>"

msgid "<literal>auth</literal> and <literal>authpriv</literal>: for authentication;"
msgstr "<literal>auth</literal> و <literal>authpriv</literal>: برای احراز هویت؛"

msgid "<literal>cron</literal>: comes from task scheduling services, <command>cron</command> and <command>atd</command>;"
msgstr "<literal>cron</literal>: که از سرویس‌های مدیریت وظیفه مانند <command>cron</command> و <command>atd</command> می‌آید؛"

msgid "<literal>daemon</literal>: affects a daemon without any special classification (DNS, NTP, etc.);"
msgstr "<literal>daemon</literal>: روی یک فرآیند پس‌زمینه بدون هیچ طبقه‌بندی خاصی تاثیر می‌گذارد (DNS، NTP و از این قبیل)؛"

msgid "<literal>ftp</literal>: concerns the FTP server;"
msgstr "<literal>ftp</literal>: مرتبط با سرور FTP؛"

msgid "<literal>kern</literal>: message coming from the kernel;"
msgstr "<literal>kern</literal>: پیامی که از کرنل می‌آید؛"

msgid "<literal>lpr</literal>: comes from the printing subsystem;"
msgstr "<literal>lpr</literal>: از زیرسیستم چاپ نشات می‌گیرد؛"

msgid "<literal>mail</literal>: comes from the e-mail subsystem;"
msgstr "<literal>mail</literal>: از زیرسیستم ایمیل نشات می‌گیرد؛"

msgid "<literal>news</literal>: Usenet subsystem message (especially from an NNTP — Network News Transfer Protocol — server that manages newsgroups);"
msgstr "<literal>news</literal>: پیام زیرسیستم Usenet (به خصوص از سمت یک سرور NTP - Network News Transfer Protocol - که گروه‌های خبری را مدیریت می‌کند)؛"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>Network News Transfer Protocol</primary><seealso>NNTP</seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

msgid "<literal>syslog</literal>: messages from the <command>syslogd</command> server, itself;"
msgstr "<literal>syslog</literal>: پیام‌هایی که از خود سرور <command>syslogd</command> می‌آیند؛"

msgid "<literal>user</literal>: user messages (generic);"
msgstr "<literal>user</literal>: پیام‌های کاربر (عمومی)؛"

msgid "<literal>uucp</literal>: messages from the UUCP server (Unix to Unix Copy Program, an old protocol notably used to distribute e-mail messages);"
msgstr "<literal>uucp</literal>:پیام‌های ارسالی از سرور UUCP (Unix to Unix Copy Program، یک پروتکل قدیمی برای انتقال پیام‌های ایمیل)؛"

msgid "<literal>local0</literal> to <literal>local7</literal>: reserved for local use."
msgstr "<literal>local0</literal> تا <literal>local7</literal>: رزرو شده برای استفاده محلی؛"

msgid "Each message is also associated with a priority level. Here is the list in decreasing order:"
msgstr "هر پیام همچنین با یک سطح اولویت نیز همراه است. اینجا فهرستی از آن‌ها به صورت کاهش درجه اهمیت قرار دارد:"

#, fuzzy
#| msgid "<primary><command>rsyslogd</command></primary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>priority</secondary>"
msgstr "<primary><command>rsyslogd</command></primary>"

msgid "<literal>emerg</literal>: “Help!” There is an emergency, the system is probably unusable."
msgstr "<literal>emerg</literal>: “کمک!” یک موقعیت اضطراری وجود دارد، سیستم به احتمال زیاد غیرقابل استفاده خواهد شد."

msgid "<literal>alert</literal>: hurry up, any delay can be dangerous, action must be taken immediately;"
msgstr "<literal>alert</literal>: عجله کن، هر تاخیری ممکن است خطرناک باشد، اقدام باید در اولین فرصت صورت گیرد؛"

msgid "<literal>crit</literal>: conditions are critical;"
msgstr "<literal>crit</literal>: شرایط بحرانی است؛"

msgid "<literal>err</literal>: error;"
msgstr "<literal>err</literal>: خطا؛"

msgid "<literal>warn</literal>: warning (potential error);"
msgstr "<literal>warn</literal>: هشدار (خطای احتمالی)؛"

msgid "<literal>notice</literal>: conditions are normal, but the message is important;"
msgstr "<literal>notice</literal>: شرایط عادی است، اما پیام حائز اهمیت است؛"

msgid "<literal>info</literal>: informative message;"
msgstr "<literal>info</literal>: پیام آگاهی‌رسان؛"

msgid "<literal>debug</literal>: debugging message."
msgstr "<literal>debug</literal>: پیام عیب‌زدایی؛"

msgid "The Configuration File"
msgstr "فایل پیکربندی"

msgid "<primary><command>rsyslogd</command></primary><secondary>configuration</secondary><seealso><filename>/etc/rsyslog.conf</filename></seealso>"
msgstr ""

#, fuzzy
#| msgid "The syntax of the <filename>/etc/rsyslog.conf</filename> file is detailed in the <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page, but there is also HTML documentation available in the <emphasis role=\"pkg\">rsyslog-doc</emphasis> package (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). The overall principle is to write “selector” and “action” pairs. The selector defines all relevant messages, and the actions describes how to deal with them."
msgid "The syntax of the <filename>/etc/rsyslog.conf</filename> file is detailed in the <citerefentry><refentrytitle>rsyslog.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page, but there is also HTML documentation available in the <emphasis role=\"pkg\">rsyslog-doc</emphasis> package (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). The overall principle is to write “selector” and “action” pairs. The selector defines all relevant messages, and the action describes how to deal with them."
msgstr "شیوه دستوری فایل <filename>/etc/rsyslog.conf</filename> در صفحه راهنما <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> آمده است، اما همچنین مستندات HTML آن در بسته <emphasis role=\"pkg\">rsyslog-doc</emphasis> نیز قرار دارد (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). اصل کبی نوشتن جفت‌های “selector” و “action” است. selector تمام پیام‌های مرتبط را انتخاب می‌کند و action می‌گوید چطور با آن‌ها برخورد شود."

msgid "Syntax of the Selector"
msgstr "شیوه دستوری انتخابگر"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>selector</secondary>"
msgstr "<primary>مالک</primary><secondary>کاربر</secondary>"

msgid "The selector is a semicolon-separated list of <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> pairs (example: <literal>auth.notice;mail.info</literal>). An asterisk may represent all subsystems or all priorities (examples: <literal>*.alert</literal> or <literal>mail.*</literal>). Several subsystems can be grouped, by separating them with a comma (example: <literal>auth,mail.info</literal>). The priority indicated also covers messages of equal or higher priority; thus <literal>auth.alert</literal> indicates the <literal>auth</literal> subsystem messages of <literal>alert</literal> or <literal>emerg</literal> priority. Prefixed with an exclamation point (!), it indicates the opposite, in other words the strictly lower priorities; <literal>auth.!notice</literal>, thus, indicates messages issued from <literal>auth</literal>, with <literal>info</literal> or <literal>debug</literal> priority. Prefixed with an equal sign (=), it corresponds to precisely and only the priority indicated (<literal>auth.=notice</literal> only concerns messages from <literal>auth</literal> with <literal>notice</literal> priority)."
msgstr "انتخابگر یک فهرست دوتایی از <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> است که با ; از هم جدا شده‌اند (نمونه: <literal>auth.notice;mail.info</literal>). یک * نشان‌دهنده کل زیرسیستم‌ها یا اولویت‌ها می‌باشد (نمونه: <literal>*.alert</literal> یا <literal>mail.*</literal>). چندین زیرسیستم با استفاده از , می‌توانند گروه‌بندی شوند (نمونه: <literal>auth,mail.info</literal>). اولویت مشخص شده شامل تمام پیام‌های با آن اولویت یا بالاتر می‌باشد؛ بنابراین <literal>auth.alert</literal> نشان‌دهنده زیرسیستم <literal>auth</literal> با اولویت <literal>alert</literal> یا <literal>emerg</literal> است. اگر با یک علامت ! پیشوند شود، نشانگر خلاف آن عمل است، به عبارت دیگر اولویت‌های پایین‌تر؛ <literal>auth.!notice</literal>، بنابراین نشان‌دهنده پیام‌های زیرسیستم <literal>auth</literal> با اولویت <literal>info</literal> یا <literal>debug</literal> است. اگر با = پیشوند شود، تنها همان اولویت مشخص شده را شامل می‌گردد (<literal>auth.=notice</literal> تنها شامل پیام‌های زیرسیستم <literal>auth</literal> با اولویت <literal>notice</literal> می‌باشد)."

msgid "Each element in the list on the selector overrides previous elements. It is thus possible to restrict a set or to exclude certain elements from it. For example, <literal>kern.info;kern.!err</literal> means messages from the kernel with priority between <literal>info</literal> and <literal>warn</literal>. The <literal>none</literal> priority indicates the empty set (no priorities), and may serve to exclude a subsystem from a set of messages. Thus, <literal>*.crit;kern.none</literal> indicates all the messages of priority equal to or higher than <literal>crit</literal> not coming from the kernel."
msgstr "هر عنصر موجود در فهرست selector عنصر قبلی را خنثی می‌کند. بنابراین امکان جداسازی یا محدودساختن برخی عناصر وجود دارد. برای نمونه، <literal>kern.info;kern.!err</literal> یعنی پیام‌های ارسالی کرنل با اولویت بین <literal>info</literal> و <literal>warn</literal>. اولویت <literal>none</literal> نشان‌دهنده مجموعه خالی است (بدون اولویت) و ممکن است برای خارج‌کردن یک زیرسیستم از مجموعه پیام‌ها بکار رود. پس، <literal>*.crit;kern.none</literal> یعنی تمام پیام‌های با اولویت برابر یا بزرگتر از <literal>crit</literal> که از کرنل نمی‌آیند."

msgid "Syntax of Actions"
msgstr "شیوه دستوری اقدامات"

#, fuzzy
#| msgid "<primary><command>rsyslogd</command></primary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>action</secondary>"
msgstr "<primary><command>rsyslogd</command></primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> The named pipe, a persistent pipe"
msgstr "<emphasis>بازگشت به مقدمات</emphasis> لوله نامگذاری شده، یک حالت پایدار"

msgid "<primary>named pipe</primary>"
msgstr "<primary>لوله نامگذاری شده</primary>"

#, fuzzy
#| msgid "<primary>backup</primary><secondary>on tape</secondary>"
msgid "<primary>pipe</primary><secondary>named pipe</secondary>"
msgstr "<primary>پشتیبان‌گیری</primary><secondary>روی نوار مغناطیسی</secondary>"

#, fuzzy
#| msgid "<primary><command>diff</command></primary>"
msgid "<primary><command>mkfifo</command></primary>"
msgstr "<primary><command>diff</command></primary>"

msgid "A named pipe is a particular type of file that operates like a traditional pipe (the pipe that you make with the “|” symbol on the command line), but via a file. This mechanism has the advantage of being able to relate two unrelated processes. Anything written to a named pipe blocks the process that writes until another process attempts to read the data written. This second process reads the data written by the first, which can then resume execution."
msgstr "یک لوله نامگذاری شده نوع مشخصی از فایل است که مانند یک لوله سنتی کار می‌کند (عملگری که با استفاده از نماد “|” ایجاد می‌کنید) اما از طریق یک فایل. این مکانیزم مزیت مرتبط کردن دو فرآیند نامربوط را دارا است. هر چیزی که به یک لوله نامگذاری شده ارسال شود فرآیند نوشتن را متوقف می‌کند تا زمانی که یک فرآیند دیگر تلاش  برای خواندن داده نوشته‌شده انجام دهد. این فرآیند دوم با خواندن داده توسط فرآیند اول که آن را نوشته است موجب ادامه عملیات اجرایی می‌گردد."

msgid "Such a file is created with the <command>mkfifo</command> command."
msgstr "چنین فایلی با استفاده از دستور <command>mkfifo</command> ایجاد می‌گردد."

msgid "The various possible actions are:"
msgstr "اقدامات ممکن عبارتند از:"

msgid "add the message to a file (example: <filename>/var/log/messages</filename>);"
msgstr "افزودن پیام به یک فایل (نمونه: <filename>/var/log/messages</filename>)؛"

msgid "send the message to a remote <command>syslog</command> server (example: <literal>@log.falcot.com</literal>);"
msgstr "ارسال پیام به یک سرور راه‌دور <command>syslog</command> (نمونه؛ <literal>@log.falcot.com</literal>)؛"

msgid "send the message to an existing named pipe (example: <literal>|/dev/xconsole</literal>);"
msgstr "ارسال پیام به یک لوله موجود نامگذاری شده (نمونه: <literal>|/dev/xconsole</literal>)؛"

msgid "send the message to one or more users, if they are logged in (example: <literal>root,rhertzog</literal>);"
msgstr "ارسال پیام به یک یا چند کاربر، اگر در سیستم حاضر باشند (نمونه: <literal>root,rhertzog</literal>)؛"

msgid "send the message to all logged in users (example: <literal>*</literal>);"
msgstr "ارسال پیام به تمام کاربران حاضر در سیستم (نمونه: <literal>*</literal>)؛"

msgid "write the message in a text console (example: <literal>/dev/tty8</literal>)."
msgstr "نوشتن پیام در یک کنسول متنی (نمونه: <literal>/dev/tty8</literal>)."

msgid "<emphasis>SECURITY</emphasis> Forwarding logs"
msgstr "<emphasis>امنیت</emphasis> فورواردکردن گزارش‌ها"

msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgstr "<primary>گزارش</primary><secondary>فورواردکردن</secondary>"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>server</secondary>"
msgstr "<primary>مالک</primary><secondary>کاربر</secondary>"

msgid "It is a good idea to record the most important logs on a separate machine (perhaps dedicated for this purpose), since this will prevent any possible intruder from removing traces of their intrusion (unless, of course, they also compromise this other server). Furthermore, in the event of a major problem (such as a kernel crash), you have the logs available on another machine, which increases your chances of determining the sequence of events that caused the crash."
msgstr "ایده خوبی است که مهم‌ترین گزارش‌ها را در یک سیستم جداگانه ثبت کنیم (که شاید برای همین منظور وجود داشته باشد)، چرا که اینکار احتمال خرابکاری نفوذگرهای احتمالی در از بین بردن رد پایشان را از بین می‌برد (مگر اینکه این سیستم جداگانه را نیز تحت نظر بگیرند). به علاوه، در زمان بروز یک مشکل بزرگ (مانند کرش کردن کرنل)، به گزارش‌ها در سیستم دوم دسترسی دارید که شانس شناسایی عوامل موجود در بروز حادثه را افزایش می‌دهد."

msgid "To accept log messages sent by other machines, you must reconfigure <emphasis>rsyslog</emphasis>: in practice, it is sufficient to activate the ready-for-use entries in <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> and <literal>$UDPServerRun 514</literal>)."
msgstr "برای پذیرش پیام‌های گزارش ارسال شده توسط سایر رایانه‌ها، باید <emphasis>rsyslog</emphasis> را پیکربندی مجدد کنید: در عمل، تنها کافی است قابلیت ready-for-use را در فایل <filename>/etc/rsyslog.conf</filename> فعال سازید (<literal>$ModLoad imudp</literal> و <literal>$UDPServerRun 514</literal>)."

msgid "The <command>inetd</command> Super-Server"
msgstr "ابر-سرور <command>inetd</command>"

msgid "Inetd (often called “Internet super-server”) is a server of servers. It executes rarely used servers on demand, so that they do not have to run continuously."
msgstr "Inetd (که اعلب “ابر-سرور اینترنت” خوانده می‌شود) یک سرور از سرورها است. سرورهای کم کاربرد را هر زمان نیاز باشد راه‌اندازی می‌کند، به صورتی که نیاز به اجرای مداوم و بی استفاده نداشته باشند."

#, fuzzy
#| msgid "<primary><command>inetd</command></primary>"
msgid "<primary><command>inetd</command></primary><seealso>super-server</seealso>"
msgstr "<primary><command>inetd</command></primary>"

msgid "<primary>super-server</primary>"
msgstr "<primary>ابر-سرور</primary>"

msgid "The <filename>/etc/inetd.conf</filename> file lists these servers and their usual ports. The <command>inetd</command> command listens to all of them; when it detects a connection to any such port, it executes the corresponding server program."
msgstr "فایل <filename>/etc/inetd.conf</filename> این سرورها و پورت‌های متداول را فهرست می‌کند. دستور <command>inetd</command> به تمام آن‌ها گوش کرده؛ زمانی که برقرای ارتباط با پورتی را شناسایی کند، برنامه سرور مربوط به آن را اجرا می‌کند."

#, fuzzy
#| msgid "<emphasis>DEBIAN POLICY</emphasis> Register a server in <filename>inetd.conf</filename>"
msgid "<emphasis>DEBIAN POLICY</emphasis> Register a server in <filename>/etc/inetd.conf</filename>"
msgstr "<emphasis>خط‌مشی دبیان</emphasis> ثبت‌کردن یک سرور در <filename>inetd.conf</filename>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/inetd.conf</filename></secondary><see><command>inetd</command></see>"
msgstr ""

#, fuzzy
#| msgid "<primary><command>update-rc.d</command></primary>"
msgid "<primary><command>update-inetd</command></primary><seealso>super-server</seealso>"
msgstr "<primary><command>update-rc.d</command></primary>"

msgid "<primary>super-server</primary><secondary>register new server</secondary><seealso><command>update-inetd</command></seealso>"
msgstr ""

msgid "Packages frequently want to register a new server in the <filename>/etc/inetd.conf</filename> file, but Debian Policy prohibits any package from modifying a configuration file that it doesn't own. This is why the <command>update-inetd</command> script (in the package with the same name) was created: It manages the configuration file, and other packages can thus use it to register a new server to the super-server's configuration."
msgstr "بسته‌ها به صورت متداول می‌خواهند که سرورهای جدید را در فایل <filename>/etc/inetd.conf</filename> اضافه کنند، اما خط‌مشی دبیان از تغییر فایل پیکربندی که متعلق به یک بسته نیست جلوگیری می‌نماید. به همین دلیل است که اسکریپت <command>update-inetd</command> (در بسته‌ای با همین نام) بوجود آمده است: این برنامه فایل پیکربندی را مدیریت کرده و به سایر بسته‌ها امکان ویرایش آن را فراهم می‌آورد."

msgid "Each significant line of the <filename>/etc/inetd.conf</filename> file describes a server through seven fields (separated by spaces):"
msgstr "هر خط مشخص در فایل <filename>/etc/inetd.conf</filename> بیانگر یک سرور با هفت فیلد است (که با فاصله از هم جدا شده‌اند)؛"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>super-server</primary><secondary>configuration</secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "The TCP or UDP port number, or the service name (which is mapped to a standard port number with the information contained in the <filename>/etc/services</filename> file)."
msgstr "شماره پورت TCP یا UDP، یا نام سرویس (که به یک پورت استاندارد بر اساس اطلاعات موجود در فایل <filename>/etc/services</filename> نگاشت شده است)."

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/services</filename></secondary>"
msgstr "<primary>کلاینت</primary><secondary>معماری کلاینت/سرور</secondary>"

msgid "The socket type: <literal>stream</literal> for a TCP connection, <literal>dgram</literal> for UDP datagrams."
msgstr "نوع سوکت: <literal>stream</literal> برای یک ارتباط TCP و <literal>dgram</literal> برای یک ارتباط UDP."

#, fuzzy
#| msgid "The protocol: <literal>tcp</literal> or <literal>udp</literal>."
msgid "The protocol: <literal>tcp</literal>, <literal>tcp6</literal>, <literal>udp</literal>, or <literal>udp6</literal>."
msgstr "پروتکل: <literal>tcp</literal> یا <literal>udp</literal>."

msgid "The options: two possible values: <literal>wait</literal> or <literal>nowait</literal>, to tell <command>inetd</command> whether it should wait or not for the end of the launched process before accepting another connection. For TCP connections, easily multiplexable, you can usually use <literal>nowait</literal>. For programs responding over UDP, you should use <literal>nowait</literal> only if the server is capable of managing several connections in parallel. You can suffix this field with a period, followed by the maximum number of connections authorized per minute (the default limit is 256)."
msgstr "گزینه‌ها: دو مقدار موجود <literal>wait</literal> یا <literal>nowait</literal> که به <command>inetd</command> می‌گوید آیا برای اتمام فرآیند اجرا شده صبر کند یا خیر. برای ارتباطات TCP، معمولا می‌توان از <literal>nowait</literal> استفاده کرد. برای برنامه‌هایی که به UDP پاسخ می‌دهند، تنها زمانی از <literal>nowait</literal> باید استفاده کنید که سرور قادر به مدیریت چندین ارتباط به صورت همزمان باشد. می‌توانید این فیلد را با استفاده از کاما پسوند کنید، به همراه حداکثر تعداد مجاز ارتباطات در دقیقه (حد پیش‌فرض برابر با ۲۵۶ است)."

#, fuzzy
#| msgid "The user name of the user under whose identity the server will run."
msgid "The user name of the user under whose identity the server will run. Optionally one can add the group too via <literal>user.group</literal> syntax."
msgstr "نام کاربری برای کاربری که تحت مجوزهای او سرور اجرا می‌شود."

msgid "The full path to the server program to execute."
msgstr "مسیر کامل برنامه سرور جهت اجرا شدن."

msgid "The arguments: this is a complete list of the program's arguments, including its own name (<literal>argv[0]</literal> in C)."
msgstr "آرگومان‌ها: این یک فهرست کامل از آرگومان‌های برنامه است، که شامل نام خود نیز می‌شود (<literal>argv[0]</literal> در زبان C)."

#, fuzzy
#| msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> and <emphasis role=\"pkg\">xinetd</emphasis>."
msgid "The following example illustrates some use-cases after installing <emphasis role=\"pkg\">talkd</emphasis>, <emphasis role=\"pkg\">nullidentd</emphasis> (<emphasis role=\"pkg\">ident-server</emphasis>), and <emphasis role=\"pkg\">fingerd</emphasis>:"
msgstr "با اینکه دبیان به صورت پیش‌فرض از <emphasis role=\"pkg\">openbsd-inetd</emphasis> استفاده می‌کند، گزینه‌های جایگزین دیگری نیز وجود دارند: می‌توان به <emphasis role=\"pkg\">inetutils-inetd</emphasis>، <emphasis role=\"pkg\">micro-inetd</emphasis>، <emphasis role=\"pkg\">rlinetd</emphasis> و <emphasis role=\"pkg\">xinetd</emphasis> اشاره کرد."

msgid "Excerpt from <filename>/etc/inetd.conf</filename>"
msgstr "چکیده‌ای از <filename>/etc/inetd.conf</filename>"

msgid ""
"#:BSD: Shell, login, exec and talk are BSD protocols.\n"
"talk   dgram   udp     wait    nobody.tty   /usr/sbin/in.talkd      in.talkd\n"
"ntalk  dgram   udp     wait    nobody.tty   /usr/sbin/in.ntalkd     in.ntalkd\n"
"\n"
"#:INFO: Info services\n"
"ident  stream  tcp     nowait  nobody       /usr/sbin/nullidentd    nullidentd\n"
"finger stream  tcp     nowait  nobody       /usr/sbin/tcpd          /usr/sbin/in.fingerd"
msgstr ""

msgid "<primary><command>tcpd</command></primary>"
msgstr "<primary><command>tcpd</command></primary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>super-server</primary><secondary>access limitation</secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

#, fuzzy
#| msgid "The <command>tcpd</command> program is frequently used in the <filename>/etc/inetd.conf</filename> file. It allows limiting incoming connections by applying access control rules, documented in the <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page, and which are configured in the <filename>/etc/hosts.allow</filename> and <filename>/etc/hosts.deny</filename> files. Once it has been determined that the connection is authorized, <command>tcpd</command> executes the real server (like <command>in.fingerd</command> in our example). It is worth noting that <command>tcpd</command> relies on the name under which it was invoked (that is the first argument, <literal>argv[0]</literal>) to identify the real program to run. So you should not start the arguments list with <literal>tcpd</literal> but with the program that must be wrapped."
msgid "The <command>tcpd</command> program is frequently used in the <filename>/etc/inetd.conf</filename> file. It allows limiting incoming connections by applying access control rules, documented in the <citerefentry><refentrytitle>hosts_access</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page, and which are configured in the <filename>/etc/hosts.allow</filename> and <filename>/etc/hosts.deny</filename> files. Once it has been determined that the connection is authorized, <command>tcpd</command> executes the real server (like <command>in.fingerd</command> in our example). It is worth noting that <command>tcpd</command> relies on the name under which it was invoked (that is the first argument, <literal>argv[0]</literal>) to identify the real program to run. So you should not start the arguments list with <literal>tcpd</literal> but with the program that must be wrapped."
msgstr "برنامه <command>tcpd</command> به طور متداول در فایل <filename>/etc/inetd.conf</filename> بکار رفته است. این برنامه امکان محدودسازی ارتباطات دریافتی را با اعمال کردن قواعد کنترل دسترسی فراهم می‌سازد که در صفحه راهنمای <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> مستندسازی شده و گزینه‌هایی که در فایل‌های <filename>/etc/hosts.allow</filename> و <filename>/etc/hosts.deny</filename> قرار گرفته است. زمانی که تشخیص دهد ارتباط دریافتی احرازهویت شده است، <command>tcpd</command> سرور حقیقی آن را اجرا می‌کند (مانند <command>in.fingerd</command> در نمونه بالا). شایان ذکر است که <command>tcpd</command> برای شناسایی برنامه مورد نظر جهت اجرا به نامی وابسته است که طی آن فراخوانی می‌شود (آرگومان اول، <literal>argv[0]</literal>). پس نباید فهرست آرگومان‌ها را با <literal>tcpd</literal> آغاز کنید بلکه با برنامه‌ای که قصد اجرای آن را دارد."

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/hosts.allow</filename></secondary>"
msgstr "<primary>ورود</primary><secondary>ورود از راه‌دور</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/hosts.deny</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "<emphasis>COMMUNITY</emphasis> Wietse Venema"
msgstr "<emphasis>جامعه کاربری</emphasis> Wietse Venema"

msgid "<primary>Wietse Venema</primary>"
msgstr "<primary>Wietse Venema</primary>"

msgid "<primary>Venema, Wietse</primary>"
msgstr "<primary>Venema, Wietse</primary>"

#, fuzzy
#| msgid "Wietse Venema, whose expertise in security has made him a renowned programmer, is the author of the <command>tcpd</command> program. He is also the main creator of Postfix, the modular e-mail server (SMTP, Simple Mail Transfer Protocol), designed to be safer and more reliable than <command>sendmail</command>, which features a long history of security vulnerabilities."
msgid "Wietse Venema, whose expertise in security has made him a renowned programmer, is the author of the <command>tcpd</command> program. He is also the main creator of Postfix, the modular e-mail server (SMTP, Simple Mail Transfer Protocol), designed to be safer and more reliable than <command>sendmail</command>, which features a long history of security vulnerabilities. We will have a closer look at this mail server in <xref linkend=\"sect.smtp-mail-server\" />."
msgstr "Wietse Venema، که تخصص بالایش در حوزه امنیت او را به یک برنامه‌نویس مشهور تبدیل کرده، خالق برنامه <command>tcpd</command> است. او همچنین خالق اصلی Postfix است، سرویس ایمیل انعطاف‌پذیر (SMTP یا Simple Main Transfer Protocol) که جایگزین امن‌تر و مناسب‌تر برنامه <command>sendmail</command> است که تاریخچه طولانی از آسیب‌پذیری‌های امنیتی را دارد."

msgid "<emphasis>ALTERNATIVE</emphasis> Other <command>inetd</command> commands"
msgstr "<emphasis>جایگزین</emphasis> سایر دستورات <command>inetd</command>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">inet-superserver</emphasis></primary><seealso>super-server</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">xinetd</emphasis></primary><seealso>super-server</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"

#, fuzzy
#| msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> and <emphasis role=\"pkg\">xinetd</emphasis>."
msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis>, and <emphasis role=\"pkg\">xinetd</emphasis>, which all provide the virtual package <emphasis role=\"pkg\">inet-superserver</emphasis>."
msgstr "با اینکه دبیان به صورت پیش‌فرض از <emphasis role=\"pkg\">openbsd-inetd</emphasis> استفاده می‌کند، گزینه‌های جایگزین دیگری نیز وجود دارند: می‌توان به <emphasis role=\"pkg\">inetutils-inetd</emphasis>، <emphasis role=\"pkg\">micro-inetd</emphasis>، <emphasis role=\"pkg\">rlinetd</emphasis> و <emphasis role=\"pkg\">xinetd</emphasis> اشاره کرد."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/xinetd.d/</filename></secondary><seealso><command>xinetd</command></seealso>"
msgstr ""

msgid "Most of these alternatives share the same configuration file <filename>/etc/inetd.conf</filename>."
msgstr ""

#, fuzzy
#| msgid "This last incarnation of a super-server offers very interesting possibilities. Most notably, its configuration can be split into several files (stored, of course, in the <filename>/etc/xinetd.d/</filename> directory), which can make an administrator's life easier."
msgid "This last incarnation of a super-server however, offers different syntax and very interesting possibilities. Most notably, its configuration can be split into several files (stored, of course, in the <filename>/etc/xinetd.d/</filename> directory), which can make an administrator's life easier. It is considered to be more powerful, but also more complex."
msgstr "این آخرین گزینه از ابر-سرورها قابلیت‌های جالبی را ارائه می‌دهد. مهم‌تر اینکه، پیکربندی آن می‌تواند از طریق چندین فایل در دایرکتوری <filename>/etc/xinetd.d/</filename> ایجاد شود، که این امر برای مدیرسیستم‌ها مزیت مهمی به حساب می‌آید."

#, fuzzy
#| msgid "Last but not least, it is even possible to emulate <command>inetd</command>'s behaviour with <command>systemd</command>'s socket-activation mechanism (see <xref linkend=\"sect.systemd\" />)."
msgid "Last but not least, it is even possible to emulate <command>inetd</command>'s behavior with <command>systemd</command>'s socket-activation mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "در نهایت، امکان شبیه‌سازی عملکرد <command>inetd</command> با استفاده از مکانیزم فعال‌سازی-سوکت در <command>systemd</command> وجود دارد (<xref linkend=\"sect.systemd\" /> را مشاهده کنید)."

msgid "Scheduling Tasks with <command>cron</command> and <command>atd</command>"
msgstr "زمان‌بندی وظیفه‌ها با <command>cron</command> و <command>atd</command>"

msgid "<primary><command>cron</command></primary>"
msgstr "<primary><command>cron</command></primary>"

msgid "<primary><command>atd</command></primary>"
msgstr "<primary><command>atd</command></primary>"

msgid "<primary>scheduled commands</primary>"
msgstr "<primary>دستورات زمان‌بندی</primary>"

msgid "<primary>command scheduling</primary>"
msgstr "<primary>زمان‌بندی دستور</primary>"

#, fuzzy
#| msgid "<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every day, every week, etc.); <command>atd</command> is that which deals with commands to be executed a single time, but at a specific moment in the future."
msgid "<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every hour, every day, every week, etc.). <command>atd</command> deals with commands to be executed a single time, but at a specific moment in the future."
msgstr "<command>cron</command> یک فرآیند پس‌زمینه برای اجرای دستورات تکراری و زمان‌بندی شده است (هر روز، هر هفته و از این قبیل)؛ <command>atd</command> اما تنها یک بار برنامه را در زمان مشخص اجرا می‌کند."

msgid "In a Unix system, many tasks are scheduled for regular execution:"
msgstr "در یک سیستم یونیکس، بسیاری از وظیفه‌ها برای اجرای مداوم زمان‌بندی می‌شوند:"

msgid "rotating the logs;"
msgstr "چرخش گزارش‌ها؛"

msgid "updating the database for the <command>locate</command> program;"
msgstr "بروزرسانی پایگاه‌داده برای برنامه <command>locate</command>؛"

msgid "back-ups;"
msgstr "پشتیبان‌گیری؛"

msgid "maintenance scripts (such as cleaning out temporary files)."
msgstr "اسکریپت‌های نگهداری (مانند پاکسازی فایل‌های موقت)."

#, fuzzy
#| msgid "<primary><command>cron</command></primary>"
msgid "<primary><command>crontab</command></primary>"
msgstr "<primary><command>cron</command></primary>"

msgid "By default, all users can schedule the execution of tasks. Each user has thus their own <emphasis>crontab</emphasis> in which they can record scheduled commands. It can be edited by running <command>crontab -e</command> (its content is stored in the <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> file)."
msgstr "به صورت پیش‌فرض، تمام کاربران می‌توانند برنامه‌های خود را زمان‌بندی کنند. هر کاربر فایل <emphasis>crontab</emphasis> مخصوص به خود را دارد که در آن می‌توانند برنامه‌ها را زمان‌بندی کنند. با استفاده از دستور <command>crontab -e</command> می‌توان آن را ویرایش کرد (محتویات آن در فایل <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> نگهداری می‌شود)."

msgid "<emphasis>SECURITY</emphasis> Restricting <command>cron</command> or <command>atd</command>"
msgstr "<emphasis>امنیت</emphasis> محدودسازی <command>cron</command> یا <command>atd</command>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/at.allow</filename></secondary><seealso><command>atd</command></seealso>"
msgstr ""

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/at.deny</filename></secondary><seealso><command>atd</command></seealso>"
msgstr ""

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.allow</filename></secondary><seealso><command>cron</command></seealso>"
msgstr ""

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.deny</filename></secondary><seealso><command>cron</command></seealso>"
msgstr ""

#, fuzzy
#| msgid "You can restrict access to <command>cron</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files."
msgid "You can restrict access to <command>crontab</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files (also described in their manual pages)."
msgstr "برای محدودسازی <command>cron</command> می‌توانید با ایجاد یک فایل دسترسی مجاز در <filename>/etc/cron.allow</filename> به فهرست‌سازی کاربرانی بپردازید که می‌توانند عملیات زمان‌بندی را انجام دهند. سایر کاربران به صورت خودکار از این قابلیت محروم خواهند شد. بر عکس این موضوع نیز صادق است، زمانی که می‌خواهید چند کاربر مشکل‌آفرین را از این ویژگی محروم کنید که می‌توانید فهرست آنان را در فایل <filename>/etc/cron.deny</filename> قرار دهید. همین قابلیت برای <command>atd</command> نیز موجود است توسط فایل‌های <filename>/etc/at.allow</filename> و <filename>/etc/at.deny</filename>."

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/crontab</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.d/</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "The root user has their own <emphasis>crontab</emphasis>, but can also use the <filename>/etc/crontab</filename> file, or write additional <emphasis>crontab</emphasis> files in the <filename>/etc/cron.d</filename> directory. These last two solutions have the advantage of being able to specify the user identity to use when executing the command."
msgstr "کاربر root <emphasis>crontab</emphasis> مخصوص به خود را دارد، اما می‌تواند از فایل <filename>/etc/crontab</filename> نیز استفاده کند یا فایل‌های اضافی در دایرکتوری <filename>/etc/cron.d</filename> قرار دهد. این دو گزینه آخر امکان مشخص کردن کاربر هنگام اجرای یک دستور به خصوص را بوجود می‌آورند."

msgid "The <emphasis>cron</emphasis> package includes by default some scheduled commands that execute:"
msgstr "بسته <emphasis>cron</emphasis> شامل چند دستور زمان‌بندی است که عبارتند از:"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.hourly/</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "programs in the <filename>/etc/cron.hourly/</filename> directory once per hour;"
msgstr "برنامه‌های موجود در <filename>/etc/cron.hourly/</filename> به صورت ساعتی اجرا می‌شوند؛"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.daily/</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "programs in <filename>/etc/cron.daily/</filename> once per day;"
msgstr "برنامه‌های موجود در <filename>/etc/cron.daily/</filename> به صورت روزانه اجرا می‌شوند؛"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.weekly/</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "programs in <filename>/etc/cron.weekly/</filename> once per week;"
msgstr "برنامه‌های موجود در <filename>/etc/cron.weekly/</filename> به صورت هفتگی اجرا می‌شوند؛"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.monthly/</filename></secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

msgid "programs in <filename>/etc/cron.monthly/</filename> once per month."
msgstr "برنامه‌های موجود در <filename>/etc/cron.monthly/</filename> به صورت ماهانه اجرا می‌شوند."

msgid "Many Debian packages rely on this service: by putting maintenance scripts in these directories, they ensure optimal operation of their services."
msgstr "بسیاری بسته‌های دبیان به این سرویس وابسته هستند: با قرار دادن اسکریپت‌های نگهداری در این دایرکتوری‌ها، آن‌ها عملکرد بهینه سرویس‌ها را رقم می‌زنند."

msgid "Format of a <filename>crontab</filename> File"
msgstr "قالب یک فایل <filename>crontab</filename>"

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>crontab</command></primary><secondary><filename>crontab</filename> file format</secondary>"
msgstr "<primary>مدیر</primary><secondary>مدیر نمایش</secondary>"

msgid "<emphasis>TIP</emphasis> Text shortcuts for <command>cron</command>"
msgstr "<emphasis>نکته</emphasis> میانبرهای متنی برای <command>cron</command>"

msgid "<command>cron</command> recognizes some abbreviations which replace the first five fields in a <filename>crontab</filename> entry. They correspond to the most classic scheduling options:"
msgstr "... برخی از مخفف‌ها را می‌شناسد که جایگزین پنج فیلد موجود در <filename>crontab</filename> می‌شود. آن‌ها منطبق با قدیمی‌ترین گزینه‌های زمان‌بندی هستند:"

msgid "<literal>@yearly</literal>: once per year (January 1, at 00:00);"
msgstr "<literal>@yearly</literal>: سالی یک بار (اول ژانویه در ساعت ۰۰:۰۰)؛"

msgid "<literal>@monthly</literal>: once per month (the 1st of the month, at 00:00);"
msgstr "<literal>@monthly</literal>: ماهی یک بار (اول هر ماه، در ساعت ۰۰:۰۰)؛"

msgid "<literal>@weekly</literal>: once per week (Sunday at 00:00);"
msgstr "<literal>@weekly</literal>: هر هفته (یکشنبه در ساعت ۰۰:۰۰)؛"

msgid "<literal>@daily</literal>: once per day (at 00:00);"
msgstr "<literal>@daily</literal>: به صورت روزانه (در ساعت ۰۰:۰۰)؛"

msgid "<literal>@hourly</literal>: once per hour (at the beginning of each hour)."
msgstr "<literal>@hourly</literal>: به صورت ساعتی (در ابتدای هر ساعت)؛"

#, fuzzy
#| msgid "The protocol: <literal>tcp</literal> or <literal>udp</literal>."
msgid "More abbreviations are recognized, like <literal>@reboot</literal>or <literal>@midnight</literal>."
msgstr "پروتکل: <literal>tcp</literal> یا <literal>udp</literal>."

msgid "<emphasis>SPECIAL CASE</emphasis> <command>cron</command> and daylight savings time"
msgstr "<emphasis>مورد خاص</emphasis> <command>cron</command> و ساعت تابستانی"

msgid "In Debian, <command>cron</command> takes the time change (for Daylight Savings Time, or in fact for any significant change in the local time) into account as best as it can. Thus, the commands that should have been executed during an hour that never existed (for example, tasks scheduled at 2:30 am during the Spring time change in France, since at 2:00 am the clock jumps directly to 3:00 am) are executed shortly after the time change (thus around 3:00 am DST). On the other hand, in autumn, when commands would be executed several times (2:30 am DST, then an hour later at 2:30 am standard time, since at 3:00 am DST the clock turns back to 2:00 am) are only executed once."
msgstr "در دبیان، <command>cron</command> تغییرات زمانی را (برای ساعت تابستانی، یا در حقیقت برای کوچکترین تغییر در زمان) در بهترین حالت به حساب می‌آورد. پس، دستوراتی که باید طی یک ساعت مشخص اجرا شوند ولی آن ساعت وجود ندارد (برای نمونه، وظایفی که زمان‌بندی شده‌اند تا در ۰۲:۳۰ صبخ طی تغییر زمانی بهاره در فرانسه اجرا شوند، چرا که در این بازه ساعت به ۰۳:۰۰ صبح تغییر می‌یابد) بلافاصله پس از تغییر در زمان اجرا می‌شوند (یعنی حدود ساعت ۰۳:۰۰ صبح). از طرف دیگر، در پاییز زمانی که دستورات باید چندین مرتبه اجرا شوند (۰۲:۳۰ صبح در ساعت تابستانی، آنگاه یک ساعت بعد در ساعت ۰۲:۳۰ استاندارد چرا که در ساعت ۰۳:۰۰ صبح زمان به ۰۲:۰۰ صبح باز می‌گردد) تنها یکبار به اجرا در می‌آیند."

msgid "Be careful, however, if the order in which the different scheduled tasks and the delay between their respective executions matters, you should check the compatibility of these constraints with <command>cron</command>'s behavior; if necessary, you can prepare a special schedule for the two problematic nights per year."
msgstr "در هر صورت باید مراقب باشید که اگر ترتیب اجرای دستورات زمان‌بندی شده اهمیت داشته باشد باید سازگاری این محدودیت‌ها را با عملکرد <command>cron</command> بررسی کنید؛ در صورت نیاز، می‌توانید یک برنامه خاص را برای این دو شب دردسرساز در سال در نظر بگیرید."

#, fuzzy
#| msgid "Each significant line of a <emphasis>crontab</emphasis> describes a scheduled command with the six (or seven) following fields:"
msgid "Each significant line of a <filename>crontab</filename> entry describes a scheduled command with the six (or seven) following fields:"
msgstr "هر خط جداگانه در <emphasis>crontab</emphasis> یک برنامه زمان‌بندی شده با شش (یا هفت) فیلد را مشخص می‌کند:"

#, fuzzy
#| msgid "the value for the minute (number from 0 to 59);"
msgid "the value for the minute (from 0 to 59);"
msgstr "دقیقه (از ۰ تا ۵۹)؛"

msgid "the value for the hour (from 0 to 23);"
msgstr "ساعت (از ۰ تا ۲۳)؛"

msgid "the value for the day of the month (from 1 to 31);"
msgstr "روز در ماه (از ۱ تا ۳۱)؛"

msgid "the value for the month (from 1 to 12);"
msgstr "ماه (از ۱ تا ۱۲)؛"

msgid "the value for the day of the week (from 0 to 7, 1 corresponding to Monday, Sunday being represented by both 0 and 7; it is also possible to use the first three letters of the name of the day of the week in English, such as <literal>Sun</literal>, <literal>Mon</literal>, etc.);"
msgstr "روز در هفته (از ۰ تا ۷، ۱ متناظر با دوشنبه، یکشنه نیز با ۰ یا ۷ نمایش داده می‌شود؛ همچنین امکان استفاده از سه حرف ابتدای هر روز به زبان انگلیسی وجود دارد، مانند <literal>Sun</literal> و <literal>Mon</literal>)؛"

msgid "the user name under whose identity the command must be executed (in the <filename>/etc/crontab</filename> file and in the fragments located in <filename>/etc/cron.d/</filename>, but not in the users' own crontab files);"
msgstr "کاربری که طبق مجوز او دستور باید اجرا گردد (در فایل <filename>/etc/crontab</filename> و در قسمت‌های مشخص شده در <filename>/etc/cron.d</filename> اما نه در فایل crontab خود کاربر)؛"

msgid "the command to execute (when the conditions defined by the first five columns are met)."
msgstr "دستوری که باید اجرا شود (زمانی که شرایط تعریف شده توسط پنج ستون اول رعایت شده باشد)."

msgid "All these details are documented in the <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgstr "تمام این جزئیات در صفحه راهنمای <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> مستندسازی شده‌اند."

#, fuzzy
#| msgid "Each value can be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values."
msgid "Each value can also be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values."
msgstr "هر مقدار می‌تواند به صورت فرمی از مقادیر جدا شده با کاما بیان شود. عبارت <literal>a-b</literal> بازه تمام مقادیر بین <literal>a</literal> و <literal>b</literal> را شامل می‌شود. عبارت <literal>a-b/c</literal> بازه افزایشی به همراه <literal>c</literal> را شامل می‌شود (نمونه: <literal>0-10/2</literal> یعنی <literal>0,2,4,6,8,10</literal>). یک <literal>*</literal> به عنوان تمام مقادیر مجاز بکار می‌رود."

#, fuzzy
#| msgid "Sample <filename>crontab</filename> file"
msgid "Sample user <filename>crontab</filename> file"
msgstr "فایل نمونه <filename>crontab</filename>"

#, fuzzy
#| msgid ""
#| "#Format\n"
#| "#min hour day mon dow  command\n"
#| "\n"
#| "# Download data every night at 7:25 pm\n"
#| " 25  19   *   *   *    $HOME/bin/get.pl\n"
#| "\n"
#| "# 8:00 am, on weekdays (Monday through Friday)\n"
#| " 00  08   *   *   1-5  $HOME/bin/dosomething\n"
#| "\n"
#| "# Restart the IRC proxy after each reboot\n"
#| "@reboot /usr/bin/dircproxy"
msgid ""
"#Format\n"
"#min hour day mon dow  command\n"
"\n"
"# Download data every night at 7:25 pm\n"
" 25  19   *   *   *    $HOME/bin/get.pl\n"
"\n"
"# 8:00 am, on weekdays (Monday through Friday)\n"
" 00  08   *   *   1-5  $HOME/bin/dosomething\n"
"\n"
"# every two hours\n"
" *  */2   *   *   *    $HOME/bin/dosomethingelse\n"
"\n"
"# Restart the IRC proxy after each reboot\n"
"@reboot /usr/bin/dircproxy"
msgstr ""
"#Format\n"
"#min hour day mon dow  command\n"
"\n"
"# Download data every night at 7:25 pm\n"
" 25  19   *   *   *    $HOME/bin/get.pl\n"
"\n"
"# 8:00 am, on weekdays (Monday through Friday)\n"
" 00  08   *   *   1-5  $HOME/bin/dosomething\n"
"\n"
"# Restart the IRC proxy after each reboot\n"
"@reboot /usr/bin/dircproxy"

msgid "<emphasis>TIP</emphasis> Executing a command on boot"
msgstr "<emphasis>نکته</emphasis> اجرای یک دستور هنگام راه‌اندازی اولیه"

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><command>cron</command></primary><secondary><literal>@reboot</literal></secondary>"
msgstr "<primary>کلاینت</primary><secondary>معماری کلاینت/سرور</secondary>"

msgid "To execute a command a single time, just after booting the computer, you can use the <literal>@reboot</literal> macro (a simple restart of <command>cron</command> does not trigger a command scheduled with <literal>@reboot</literal>). This macro replaces the first five fields of an entry in the <emphasis>crontab</emphasis>."
msgstr "برای اجرای یک دستور، یک مرتبه پس از راه‌اندازی رایانه، می‌توانید از ماکرو <literal>@reboot</literal> استفاده کنید (راه‌اندازی مجدد <command>cron</command> منجر به اجرای دستور همراه با <literal>@reboot</literal> نمی‌شود). این ماکرو جایگزین پنج فیلد اول هر خط از <emphasis>crontab</emphasis> می‌شود."

msgid "<emphasis>ALTERNATIVE</emphasis> Emulating <command>cron</command> with <command>systemd</command>"
msgstr "<emphasis>جایگزین</emphasis> شبیه‌سازی <command>cron</command> با <command>systemd</command>"

#, fuzzy
#| msgid "It is possible to emulate part of <command>cron</command>'s behaviour with <command>systemd</command>'s timer mechanism (see <xref linkend=\"sect.systemd\" />)."
msgid "It is possible to emulate part of <command>cron</command>'s behavior with <command>systemd</command>'s timer mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "امکان شبیه‌سازی بخشی از عملکرد <command>cron</command> با استفاده از مکانیزم زمان‌بندی <command>systemd</command> وجود دارد (<xref linkend=\"sect.systemd\" /> را مشاهده کنید)."

msgid "Using the <command>at</command> Command"
msgstr "استفاده از دستور <command>at</command>"

msgid "<primary><command>at</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.15</literal> thus representing 27 July 2015), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2015-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (ie., <literal>12/25/15</literal> or <literal>12/25/2015</literal> will be December 25, 2015), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122515</literal> or <literal>12252015</literal> will, likewise, represent December 25, 2015). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory."
msgid "The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.22</literal> thus representing 27 July 2022), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2022-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (i.e., <literal>12/25/22</literal> or <literal>12/25/2022</literal> will be December 25, 2022), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122522</literal> or <literal>12252022</literal> will, likewise, represent December 25, 2022). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory."
msgstr "<command>at</command> یک دستور را در زمان مشخصی از آینده اجرا می‌کند. زمان و تاریخ مناسب را از طریق پارامترهای خط-فرمان دریافت کرده و دستور مورد نظر جهت اجرا را از ورودی استاندارد می‌گیرد. دستور شروع به اجرا می‌کند به طوری که انگار در پوسته کنونی وارد شده باشد. <command>at</command> حتی به حفظ محیط فعلی رسیدگی می‌کند تا در زمان اجرای دستور همین شرایط برقرار باشد. زمان با استفاده از قوانین زیر تعیین می‌شود: <literal>16:12</literal> یا <literal>4:12pm</literal> نشان‌دهنده ۰۴:۱۲ بعد از ظهر هستند. تاریخ می‌تواند با چندین قالب مختلف اروپایی و غربی بیان شود، از جمله <literal>DD.MM.YY</literal> (عبارت <literal>27.07.15</literal> که بیانگر ۲۷ جولای ۲۰۱۵ است)، <literal>YYYY-MM-DD</literal> (همان تاریخ که به صورت <literal>2015-07-27</literal> بیان می‌شود)، <literal>MM/DD/[CC]YY</literal> (برای نمونه، <literal>12/25/15</literal> یا <literal>12/25/2015</literal> برابر با ۲۵ دسامبر ۲۰۱۵ خواهد بود) یا <literal>MMDD[CC]YY</literal> (که در آن <literal>122515</literal> یا <literal>12252015</literal> بیانگر همان تاریخ قبلی هستند). بدون أن، دستور در اولین بازه زمانی تعیین شده اجرا می‌شود (همان روز، یا فردا اگر زمان روز فعلی گذشته باشد). همچنین می‌توانید از عبارت‌های “today” یا “tomorrow” نیز استفاده کنید."

#, fuzzy
#| msgid ""
#| "\n"
#| "<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
#| "<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
#| "<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
#| "<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
#| "<computeroutput>warning: commands will be executed using /bin/sh\n"
#| "job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.22 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 1 at Wed Jul 27 09:00:00 2022</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"

msgid "An alternative syntax postpones the execution for a given duration: <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command>. The <replaceable>period</replaceable> can be <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal>, or <literal>weeks</literal>. The <replaceable>number</replaceable> simply indicates the number of said units that must elapse before execution of the command."
msgstr "یک شیوه نگارش جایگزین اجرای دستور را برای مدت مشخصی به عقب می‌اندازد: <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command> که <replaceable>period</replaceable> می‌تواند <literal>minutes</literal>، <literal>hours</literal>، <literal>days</literal> یا <literal>weeks</literal> باشد. <replaceable>number</replaceable> نیز بیانگر تعداد دفعات واحد مشخص شده برای گذشتن جهت اجرای دستور است."

msgid "To cancel a task scheduled by <command>cron</command>, simply run <command>crontab -e</command> and delete the corresponding line in the <emphasis>crontab</emphasis> file. For <command>at</command> tasks, it is almost as easy: run <command>atrm <replaceable>task-number</replaceable></command>. The task number is indicated by the <command>at</command> command when you scheduled it, but you can find it again with the <command>atq</command> command, which gives the current list of scheduled tasks."
msgstr "برای لغو برنامه زمان‌بندی <command>cron</command> تنها کافی است دستور <command>crontab -e</command> را اجرا کرده و خط مربوط به آن دستور را از فایل <emphasis>crontab</emphasis> حذف کنید. برای وظایف <command>at</command> نیز به همین سادگی است: دستور <command>atrm <replaceable>task-number</replaceable></command> را اجرا کنید. شناسه وظیفه توسط <command>at</command> هنگام تعریف آن مشخص می‌شود و می‌توانید آن را با دستور <command>atq</command> پیدا کنید که فهرستی از وظایف زمان‌بندی شده را باز می‌گرداند."

msgid "<primary><command>atrm</command></primary>"
msgstr "<primary><command>atrm</command></primary>"

msgid "<primary><command>atq</command></primary>"
msgstr "<primary><command>atq</command></primary>"

msgid "Scheduling Asynchronous Tasks: <command>anacron</command>"
msgstr "زمان‌بندی وظیفه‌های غیرهمزمان: <command>anacron</command>"

#, fuzzy
#| msgid "<primary><command>anacron</command></primary>"
msgid "<primary><command>anacron</command></primary><seealso><command>cron</command></seealso>"
msgstr "<primary><command>anacron</command></primary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/anacrontab</filename></secondary>"
msgstr "<primary>فایل‌ها</primary><secondary>فایل‌های گزارش</secondary>"

msgid "<command>anacron</command> is the daemon that completes <command>cron</command> for computers that are not on at all times. Since regular tasks are usually scheduled for the middle of the night, they will never be executed if the computer is off at that time. The purpose of <command>anacron</command> is to execute them, taking into account periods in which the computer is not working."
msgstr "<command>anacron</command> یک فرآیند پس‌زمینه مکمل برای <command>cron</command> است مخصوص رایانه‌هایی که در همه زمان روشن نیستند. از آنجا که وظایف معمولی برای نیمه شب زمان‌بندی می‌شوند، در صورت خاموش بودن رایانه هیچگاه اجرا نخواهند شد. هدف <command>anacron</command> اجرای این دستورات است با در نظر گرفتن اینکه رایانه ممکن است روشن نباشد."

#, fuzzy
#| msgid "<primary><command>init</command></primary>"
msgid "<primary><command>nice</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "Please note that <command>anacron</command> will frequently execute such activity a few minutes after booting the machine, which can render the computer less responsive. This is why the tasks in the <filename>/etc/anacrontab</filename> file are started with the <command>nice</command> command, which reduces their execution priority and thus limits their impact on the rest of the system. Beware, the format of this file is not the same as that of <filename>/etc/crontab</filename>; if you have particular needs for <command>anacron</command>, see the <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page."
msgstr "به یاد داشته باشید که <command>anacron</command> چنین فعالیت‌هایی را بلافاصله پس از راه‌اندازی مجدد رایانه آغاز می‌کند، که ممکن است منجر به کندی آن شوند. به همین دلیل است که وظایف موجود در فایل <filename>/etc/anacrontab</filename> با دستور <command>nice</command> آغاز می‌شوند که اولویت اجرایی آن‌ها را کاهش داده و تاثیر منفی آن‌ها را روی سیستم محدود می‌سازد. آگاه باشید که قالب این فایل با آنچه در <filename>/etc/crontab</filename> وجود دارد متفاوت است؛ اگر نیاز خاصی در رابطه با <command>anacron</command> دارید به صفحه راهنمای <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> را مشاهده کنید."

msgid "<emphasis>BACK TO BASICS</emphasis> Priorities and <command>nice</command>"
msgstr "<emphasis>بازگشت به مقدمات</emphasis> اولویت‌ها و <command>nice</command>"

#, fuzzy
#| msgid "<primary><command>rsync</command></primary>"
msgid "<primary><command>renice</command></primary>"
msgstr "<primary><command>rsync</command></primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>niceness</primary><seealso><command>nice</command></seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "Unix systems (and thus Linux) are multi-tasking and multi-user systems. Indeed, several processes can run in parallel, and be owned by different users: the kernel mediates access to the resources between the different processes. As a part of this task, it has a concept of priority, which allows it to favor certain processes over others, as needed. When you know that a process can run in low priority, you can indicate so by running it with <command>nice <replaceable>program</replaceable></command>. The program will then have a smaller share of the CPU, and will have a smaller impact on other running processes. Of course, if no other processes needs to run, the program will not be artificially held back."
msgid "Unix systems (and thus Linux) are multi-tasking and multi-user systems. Indeed, several processes can run in parallel, and be owned by different users: the kernel mediates access to the resources between the different processes. As a part of this task, it has a concept of priority, which allows it to favor certain processes over others, as needed. When you know that a process can run in low priority, you can indicate so by running it with <command>nice <replaceable>program</replaceable></command>. The program will then have a smaller share of the CPU, and will have a smaller impact on other running processes. Of course, if no other process needs to run, the program will not be artificially held back."
msgstr "سیستم‌های یونیکس (مانند لینوکس) به صورت چند-وظیفه‌ای و چند-کاربره کار می‌کنند. در حقیقت، چندین فرآیند می‌توانند به صورت همزمان اجرا شوند و به کاربران مختلفی تعلق داشته باشند: کرنل وظیفه مدیریت منابع بین فرآیندهای مختلف را بر عهده دارد. به عنوان قسمتی از این وظیفه، مفومی به نام اولویت وجود دارد که ترتیب اجرایی فرآیندهای مختلف نسبت به یکدیگر را مشخص می‌کند. زمانی که می‌دانید یک فرآیند می‌تواند با اولویت پایین اجرا شود، می‌توانید آن را با دستور <command>nice <replaceable>program</replaceable></command> مشخص کنید. برنامه در این صورت سهم کوچکی از پردازنده خواهد داشت و بنابراین تاثیر کمتری رو عملکرد کلی سیستم می‌گذارد. البته، اگر هیچ فرآیند دیگری برای اجرا وجود نداشته باشد، برنامه به صورت مصنوعی عقب نگاه داشته نمی‌شود."

msgid "<command>nice</command> works with levels of “niceness”: the positive levels (from 1 to 19) progressively lower the priority, while the negative levels (from -1 to -20) will increase it — but only root can use these negative levels. Unless otherwise indicated (see the <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry> manual page), <command>nice</command> increases the current level by 10."
msgstr "<command>nice</command> با سطح‌های مختلفی از “niceness” کار می‌کند:  سطح‌های مثبت (از ۱ تا ۱۹) اولویت را به آرامی کاهش، در صورتی که سطح‌های منفی (از ۱- تا ۲۰-) آن را افزایش می‌دهند - اما تنها root قادر به استفاده از آن‌ها است. مگر در جایی به آن اشاره شده باشد (صفحه راهنمای <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry> را مشاهده کنید)، <command>nice</command> به صورت پیش‌فرض سطح فعلی را با ۱۰ افزایش می‌دهد."

msgid "If you discover that an already running task should have been started with <command>nice</command> it is not too late to fix it; the <command>renice</command> command changes the priority of an already running process, in either direction (but reducing the “niceness” of a process is reserved for the root user)."
msgstr "اگر دریافتید که یک وظیفه جاری باید با <command>nice</command> آغاز می‌شد ولی این اتفاق نیفتاده است، اصلاح آن ساده است؛ دستور <command>renice</command> اولویت یک فرآیند در حال اجرا را تغییر می‌دهد، در هر جهت (اما کاهش میزان ... یک فرآیند به دسترسی کاربر root نیاز دارد)."

msgid "Installation of the <emphasis role=\"pkg\">anacron</emphasis> package deactivates execution by <command>cron</command> of the scripts in the <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, and <filename>/etc/cron.monthly/</filename> directories. This avoids their double execution by <command>anacron</command> and <command>cron</command>. The <command>cron</command> command remains active and will continue to handle the other scheduled tasks (especially those scheduled by users)."
msgstr "نصب بسته <emphasis role=\"pkg\">anacron</emphasis> منجر به توقف اجرای اسکریپت‌های <command>cron</command> در دایرکتوری‌های <filename>/etc/cron.hourly/</filename>، <filename>/etc/cron.daily/</filename>، <filename>/etc/cron.weekly/</filename> و <filename>/etc/cron.monthly/</filename> می‌شود. این کار از اجرای تکرای <command>cron</command> و <command>anacron</command> جلوگیری می‌کند. دستور <command>cron</command> فعال باقی می‌ماند و به اجرای وظایف زمان‌بندی شده (به خصوص از طرف کاربر) می‌پردازد."

msgid "Quotas"
msgstr "سهمیه‌بندی"

msgid "<primary>quota</primary>"
msgstr "<primary>quota</primary>"

msgid "The quota system allows limiting disk space allocated to a user or group of users. To set it up, you must have a kernel that supports it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is the case with Debian kernels. The quota management software is found in the <emphasis role=\"pkg\">quota</emphasis> Debian package."
msgstr "سیستم سهمیه‌بندی امکان محدودسازی فضای دیسک موجود را برای کاربران و گروه‌ها فراهم می‌سازد. برای تنظیم آن، باید کرنلی داشته باشید که آن را پشتیبانی کند (با گزینه <varname>CONFIG_QUOTA</varname> کامپایل شده باشد) - که در مورد کرنل‌های دبیان صادق است. نرم‌افزار مدیریت سهمیه در بسته دبیان <emphasis role=\"pkg\">quota</emphasis> پیدا می‌شود."

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary><literal>usrquota</literal></primary><seealso>quota</seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary><literal>grpquota</literal></primary><seealso>quota</seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

msgid "To activate quota in a filesystem, you have to indicate the <literal>usrquota</literal> and <literal>grpquota</literal> options in <filename>/etc/fstab</filename> for the user and group quotas, respectively. Rebooting the computer will then update the quotas in the absence of disk activity (a necessary condition for proper accounting of already used disk space)."
msgstr "برای فعال‌سازی سهمیه‌بندی در یک فایل‌سیستم، باید گزینه‌های <literal>usrquota</literal> و <literal>grpquota</literal> در فایل <filename>/etc/fstab</filename> را برای سهمیه‌بندی کاربران و گروه‌ها مشخص کنید. راه‌اندازی مجدد رایانه منجر به بروزرسانی این سهمیه‌بندی در غیاب فعالیت دیسک می‌شود (یک شرایط لازم برای محاسبه دقیق فضای مصرفی دیسک)."

msgid "<primary><command>edquota</command></primary>"
msgstr "<primary><command>edquota</command></primary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>quota</primary><secondary><command>edquota</command></secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "The <command>edquota <replaceable>user</replaceable></command> (or <command>edquota -g <replaceable>group</replaceable></command>) command allows you to change the limits while examining current disk space usage."
msgstr "دستور <command>edquota <replaceable>user</replaceable></command> یا <command>edquota -g<replaceable>group</replaceable></command> امکان ویرایش سهمیه‌بندی فعلی بر اساس ظرفیت موجود در دیسک را فراهم می‌سازد."

msgid "<emphasis>GOING FURTHER</emphasis> Defining quotas with a script"
msgstr "<emphasis>مطالعه بیشتر</emphasis> تعیین سهمیه‌بندی با اسکریپت"

msgid "<primary><command>setquota</command></primary>"
msgstr "<primary><command>setquota</command></primary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>quota</primary><secondary><command>setquota</command></secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "The <command>setquota</command> program can be used in a script to automatically change many quotas. Its <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> manual page details the syntax to use."
msgstr "برنامه <command>setquota</command> می‌تواند به منظور تغییر سهمیه‌بندی‌ها در اسکریپت‌ها استفاده گردد. صفحه راهنمای <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> به توضیح شیوه استفاده از آن می‌پردازد."

msgid "The quota system allows you to set four limits:"
msgstr "سیستم سهمیه‌بندی به شما امکان تنظیم چهار محدودیت را می‌دهد؛"

#, fuzzy
#| msgid "two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, a block contains 1024 bytes from the same file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will however be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total."
msgid "two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, the 1024 available bytes of each block can only be assigned to one file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will, however, be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total."
msgstr "دو محدودیت “soft” و “hard” به تعداد بلاک‌های مصرفی اشاره دارند. اگر فایل‌سیستم با اندازه بلاک ۱ کیلوبایت ایجاد شده باشد، یک بلاک شامل ۱۰۲۴ بایت از آن فایل است. بلاک‌های اشباع‌نشده منجر به از بین رفتن فضای دیسک می‌شوند. سهمیه‌ای با ۱۰۰ بلاک، که به صورت نظری قابلیت ذخیره‌سازی ۱۰۲،۴۰۰ بایت را دارد، تنها به ذخیره ۱۰۰ فایل ۵۰۰ بایتی محدود می‌شود، که فقط ۵۰،۰۰۰ بایت در مجموع را شامل می‌شود."

#, fuzzy
#| msgid "two limits (soft and hard) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files."
msgid "two limits (“soft” and “hard”) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files."
msgstr "دو محدویت “soft” و “hard” به تعداد inodeهای مصرفی اشاره دارند. هر فایل حداقل یک inode مربوط به خود به منظور ذخیره‌سازی اطلاعات جانبی را دارد (مجوزها، مالک، برچسب‌زمانی از آخرین دسترسی و از این قبیل). این یک محدودیت در فایل‌های مورد استفاده کاربر است."

msgid "<primary>inode</primary>"
msgstr "<primary>inode</primary>"

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary>quota</primary><secondary>soft limit</secondary>"
msgstr "<primary>ورود</primary><secondary>ورود از راه‌دور</secondary>"

#, fuzzy
#| msgid "<primary>link</primary><secondary>hard link</secondary>"
msgid "<primary>quota</primary><secondary>hard limit</secondary>"
msgstr "<primary>پیوند</primary><secondary>پیوند سخت</secondary>"

msgid "A “soft” limit can be temporarily exceeded; the user will simply be warned that they are exceeding the quota by the <command>warnquota</command> command, which is usually invoked by <command>cron</command>. A “hard” limit can never be exceeded: the system will refuse any operation that will cause a hard quota to be exceeded."
msgstr "یک حد “soft” به صورت موقت می‌تواند تجاوز کند؛ در این حالت با استفاده از دستور <command>warnquota</command> که معمولا توسط <command>cron</command> فراخوانی می‌شود به کاربر اخطار ظرفیت دیسک داده می‌شود. یک حد “hard” هیچگاه نمی‌تواند تجاوز کند: سیستم به رد تمام عملیاتی می‌پردازد که منجر به گذشتن از سهمیه مجاز “hard” باشد."

#, fuzzy
#| msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgid "<primary>quota</primary><secondary><command>warnquota</command></secondary>"
msgstr "<primary>گزارش</primary><secondary>فورواردکردن</secondary>"

msgid "<emphasis>VOCABULARY</emphasis> Blocks and inodes"
msgstr "<emphasis>واژگان</emphasis> block و inode"

msgid "<primary>block (disk)</primary>"
msgstr "<primary>بلاک (دیسک)</primary>"

msgid "The filesystem divides the hard drive into blocks — small contiguous areas. The size of these blocks is defined during creation of the filesystem, and generally varies between 1 and 8 kibibytes."
msgstr "فایل‌سیستم، هارد درایو را به بلاک - ناحیه‌های کوچک پیوسته - تقسیم می‌کند. اندازه این بلاک‌ها هنگام ایجاد فایل‌سیستم تعیین می‌شود که معمولا بین ۱ تا ۸ کیلوبایت هستند."

msgid "A block can be used either to store the real data of a file, or for meta-data used by the filesystem. Among this meta-data, you will especially find the inodes. An inode uses a block on the hard drive (but this block is not taken into consideration in the block quota, only in the inode quota), and contains both the information on the file to which it corresponds (name, owner, permissions, etc.) and the pointers to the data blocks that are actually used. For very large files that occupy more blocks than it is possible to reference in a single inode, there is an indirect block system; the inode references a list of blocks that do not directly contain data, but another list of blocks."
msgstr "هر بلاک می‌تواند به منظور ذخیره‌سازی داده‌های حفیقی یک فایل یا اطلاعات-جانبی مربوط به آن استفاده شود. در میان این اطلاعات-جانبی، معمولا inode را پیدا می‌کنید. یک inode از بلاک موجود در هارد درایو استفاده کرده (اما این بلاک در سهمیه‌بندی بلاک لحاظ نمی‌شود بلکه در سهمیه‌بندی inode قرار می‌گیرد) و شامل اطلاعات جانبی درباره فایل (نام، مالک، مجوزها و از این قبیل) همچنین نشانگرها به بلاک‌های داده‌ای واقعی این فایل می‌شود. برای فایل‌های بسیار بزرگ که به بلاک‌های بیشتری برای ذخیره‌سازی اطلاعات inode نیاز دارد، یک سیستم غیرمستقیم بلاک وجود دارد؛ inode شامل فهرستی از بلاک‌ها می‌باشد که داده واقعی را شامل نمی‌شوند، بلکه آن‌ها نیز شامل فهرستی از بلاک‌های دیگر هستند."

msgid "With the <command>edquota -t</command> command, you can define a maximum authorized “grace period” within which a soft limit may be exceeded. After this period, the soft limit will be treated like a hard limit, and the user will have to reduce their disk space usage to within this limit in order to be able to write anything to the hard drive."
msgstr "با استفاده از دستور <command>edquota -t</command>، می‌توانید یک “بازه محدود” حداکثری که حد نرم از آن عبور کند را تعریف کنید. پس از این بازه، یک حد نرم مانند یک حد سخت در نظر گرفته می‌شود و کاربر مجبور است فضای دیسک را کاهش دهد تا بتواند اطلاعات جدید روی آن ذخیره کند."

msgid "<emphasis>GOING FURTHER</emphasis> Setting up a default quota for new users"
msgstr "<emphasis>مطالعه بیشتر</emphasis> تنظیم سهمیه پیش‌فرض برای کاربران جدید"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>quota</primary><secondary><varname>QUOTAUSER</varname></secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>environment variable</primary><secondary><varname>QUOTAUSER</varname></secondary>"
msgstr "<primary>سرویس</primary><secondary>راه‌اندازی‌مجدد</secondary>"

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/adduser.conf</filename></secondary>"
msgstr "<primary>کلاینت</primary><secondary>معماری کلاینت/سرور</secondary>"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary>quota</primary><secondary>template user</secondary>"
msgstr "<primary>مالک</primary><secondary>کاربر</secondary>"

msgid "To automatically setup a quota for new users, you have to configure a template user (with <command>edquota</command> or <command>setquota</command>) and indicate their user name in the <varname>QUOTAUSER</varname> variable in the <filename>/etc/adduser.conf</filename> file. This quota configuration will then be automatically applied to each new user created with the <command>adduser</command> command."
msgstr "به منظور خودکارسازی تنظیم سهمیه برای کاربران جدید، باید یک قالب کاربری جدید (با <command>edquota</command> یا <command>setquota</command>) ایجاد کرده و نام کاربری را در متغیر <varname>QUOTAUSER</varname> موجود در فایل <filename>/etc/adduser.conf</filename> مشخص سازید. این پیکربندی سهمیه به صورت خودکار با هر بار فراخوانی دستور <command>adduser</command> به منظور ایجاد کاربر جدید اعمال می‌شود."

msgid "<primary>backup</primary>"
msgstr "<primary>پشتیبان‌گیری</primary>"

msgid "<primary>restoration</primary>"
msgstr "<primary>بازیابی</primary>"

msgid "Making backups is one of the main responsibilities of any administrator, but it is a complex subject, involving powerful tools which are often difficult to master."
msgstr "پشتیبان‌گیری یکی از وظایف اصلی مدیرسیستم‌ها است، اما از آنجا که موضوع پیچیده‌ای است، ابزار آن نیز از پیچیدگی بیشتری برخوردار هستند."

msgid "<primary><command>amanda</command></primary>"
msgstr "<primary><command>amanda</command></primary>"

msgid "<primary><command>bacula</command></primary>"
msgstr "<primary><command>bacula</command></primary>"

#, fuzzy
#| msgid "<primary><command>atd</command></primary>"
msgid "<primary><command>dd</command></primary>"
msgstr "<primary><command>atd</command></primary>"

#, fuzzy
#| msgid "<primary><command>init</command></primary>"
msgid "<primary><command>duplicity</command></primary>"
msgstr "<primary><command>init</command></primary>"

#, fuzzy
#| msgid "<primary><command>chgrp</command></primary>"
msgid "<primary><command>fsarchiver</command></primary>"
msgstr "<primary><command>chgrp</command></primary>"

msgid "<primary><command>BackupPC</command></primary>"
msgstr "<primary><command>BackupPC</command></primary>"

#, fuzzy
#| msgid "<primary><command>diff</command></primary>"
msgid "<primary><command>rdiff-backup</command></primary>"
msgstr "<primary><command>diff</command></primary>"

#, fuzzy
#| msgid "<primary><command>rsh</command></primary>"
msgid "<primary><command>rsnapshot</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

#, fuzzy
#| msgid "<primary><command>init</command></primary>"
msgid "<primary><command>timeshift</command></primary>"
msgstr "<primary><command>init</command></primary>"

#, fuzzy
#| msgid "Many programs exist, such as <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Those are client/server system featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. But Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>."
msgid "Many programs exist, such as <command>amanda</command>, <command>bacula</command>, or <command>BackupPC</command>. Those are client/server systems featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. For non-enterprise systems, administrators might want to check out <command>rsnapshot</command> or <command>rdiff-backup</command>. Users can easily create backups of their filesystems with <command>timeshift</command>, <command>fsarchiver</command>, <command>duplicity</command>, or even <command>dd</command>."
msgstr "برنامه‌های بسیاری برای اینکار وجود دارند از جمله <command>amanda</command>، <command>bacula</command> و <command>BackupPC</command>. این‌ها سیستم‌های کلاینت/سروری هستند که گزینه‌های بسیاری دارند با پیکربندی‌های به نسبت دشوار. برخی از آن‌ها به منظور غلبه بر این دشواری از رابط‌های کاربر-پسند تحت وب استفاده می‌کنند. اما دبیان شامل طیف گسترده‌ای از ابزارهای پشتیبان‌گیری است که با استفاده از دستور <command>apt-cache search backup</command> می‌توانید فهرستی از آنان را مشاهده کنید."

msgid "Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>."
msgstr ""

msgid "Rather than detailing some of them, this section will present the thoughts of the Falcot Corp administrators when they defined their backup strategy."
msgstr "بجای تشریح هر یک از آن‌ها، در این بخش به بررسی استراتژی پشتیبان‌گیری در شرکت فالکوت می‌پردازیم که مدیرسیستم‌های آن تهیه کرده‌اند."

msgid "At Falcot Corp, backups have two goals: recovering erroneously deleted files, and quickly restoring any computer (server or desktop) whose hard drive has failed."
msgstr "در شرکت فالکوت، فایل‌های پشتیبان دو هدف دارند: بازیابی فایل‌های پاک شده و بازیابی رایانه‌ای (رومیزی یا سرور) که هارد درایو آن دچار مشکل شده است."

msgid "Backing Up with <command>rsync</command>"
msgstr "پشتیبان‌گیری با استفاده از <command>rsync</command>"

msgid "<primary><command>rsync</command></primary>"
msgstr "<primary><command>rsync</command></primary>"

msgid "Backups on tape having been deemed too slow and costly, data will be backed up on hard drives on a dedicated server, on which the use of software RAID (see <xref linkend=\"sect.raid-soft\" />) will protect the data from hard drive failure. Desktop computers are not backed up individually, but users are advised that their personal account on their department's file server will be backed up. The <command>rsync</command> command (from the package of the same name) is used daily to back up these different servers."
msgstr "پشتیبان‌گیری در نوار مغناطیسی زمان و هزینه بالایی می‌برد، پس داده‌ها روی هارد درایوهای یک سرور اختصاصی نگهداری می‌شوند که در آن استفاده از RAID نرم‌افزاری (<xref linkend=\"sect.raid-soft\" /> را مشاهده کنید) داده‌ها را از خطرات هارد درایو محافظت می‌کند. رایانه‌های رومیزی به صورت انفرادی پشتیبان‌گیری نمی‌شوند، اما به کاربران توصیه شده است که داده‌های شخصی خود را در فایل سرور دپارتمان ذخیره‌سازی کنند. دستور <command>rsync</command> (از بسته‌ای با همین نام) به صورت روزانه برای پشتیبان‌گیری از این سرورها استفاده می‌شود."

msgid "<emphasis>BACK TO BASICS</emphasis> The hard link, a second name for the file"
msgstr "<emphasis>بازگشت به مقدمات</emphasis> پیوند سخت، نام دوم برای فایل"

msgid "<primary>link</primary><secondary>hard link</secondary>"
msgstr "<primary>پیوند</primary><secondary>پیوند سخت</secondary>"

msgid "<primary>hard link</primary>"
msgstr "<primary>پیوند سخت</primary>"

#, fuzzy
#| msgid "<primary><command>telnet</command></primary>"
msgid "<primary><command>ln</command></primary>"
msgstr "<primary><command>telnet</command></primary>"

msgid "A hard link, as opposed to a symbolic link, cannot be differentiated from the linked file. Creating a hard link is essentially the same as giving an existing file a second name. This is why the deletion of a hard link only removes one of the names associated with the file. As long as another name is still assigned to the file, the data therein remain present on the filesystem. It is interesting to note that, unlike a copy, the hard link does not take up additional space on the hard drive."
msgstr "یک پیوند سخت، بر خلاف پیوند نرم، از فایل پیوند داده شده قابل تشخیص نیست. ایجاد یک پیوند سخت به منزله در نظر گرفتن نام دوم برای فایل است. به همین دلیل است که حذف پیوند سخت تنها منجر به از بین رفتن یکی از نام‌های فایل می‌شود. تا زمانی که نام دیگری برای دسترسی به فایل موجود باشد، داده روی آن در فایل‌سیستم باقی می‌ماند. شایان ذکر است که بر خلاف عملیات رونوشت‌گیری، یک پیوند سخت فضای اضافی روی دیسک در نظر نمی‌گیرد."

msgid "A hard link is created with the <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> command. The <replaceable>link</replaceable> file is then a new name for the <replaceable>target</replaceable> file. Hard links can only be created on the same filesystem, while symbolic links are not subject to this limitation."
msgstr "یک پیوند سخت با دستور <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> ایجاد می‌شود. فایل <replaceable>link</replaceable> یک نام جدید برای فایل <replaceable>target</replaceable> است. پیوندهای سخت تنها می‌توانند روی یک فایل‌سیستم ایجاد گردند، در جایی که پیوندهای نمادین این محدودیت را ندارند."

msgid "The available hard drive space prohibits implementation of a complete daily backup. As such, the <command>rsync</command> command is preceded by a duplication of the content of the previous backup with hard links, which prevents usage of too much hard drive space. The <command>rsync</command> process then only replaces files that have been modified since the last backup. With this mechanism a great number of backups can be kept in a small amount of space. Since all backups are immediately available and accessible (for example, in different directories of a given share on the network), you can quickly make comparisons between two given dates."
msgstr "فضای موجود هارد درایو امکان پیاده‌سازی پشتیبان‌گیری روزانه را نمی‌دهد. به همین دلیل، دستور <command>rsync</command> به همراه کپی محتوای هارد پشتیبان‌گیری شده با پیوندهای سخت استفاده می‌شود، که این امر از استفاده بیش از حد فضای هارد درایو جلوگیری می‌کند. فرآیند <command>rsync</command> تنها فایل‌هایی را جایگزین می‌کند که از آخرین زمان پشتیبان‌گیری تغییر کرده باشند. با این مکانیزم تعداد زیادی فایل پشتیبان در فضای کمی از دیسک قابل ذخیره‌سازی هستند. از آنجا که تمام فایل‌های پشتیبان بلافاصله موجود و در دسترس هستند (برای نمونه، در دایرکتوری‌های مختلف از یک شبکه اشتراکی) به سرعت می‌توانید اختلاف محتوای آن‌ها در دو تاریخ مختلف را بدست آورید."

msgid "<primary>copy, backup copy</primary>"
msgstr "<primary>رونوشت‌گیری، رونوشت از فایل پشتیبان</primary>"

msgid "<primary>backup</primary><secondary>copy</secondary>"
msgstr "<primary>پشتیبان</primary><secondary>رونوشت</secondary>"

msgid "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"

msgid "This backup mechanism is easily implemented with the <command>dirvish</command> program. It uses a backup storage space (“bank” in its vocabulary) in which it places timestamped copies of sets of backup files (these sets are called “vaults” in the dirvish documentation)."
msgstr "مکانیزم پشتیبان‌گیری به راحتی توسط برنامه <command>dirvish</command> پیاده‌سازی شده است. این برنامه از یک فضای ذخیره‌سازی پشتیبان (“بانک”) استفاده می‌کند که در آن فایل‌های پشتیبان را بر اساس بازه زمانی قرار می‌دهد (که به این فایل‌ها “صندوق” گفته می‌شود)."

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/dirvish/master.conf</filename></secondary>"
msgstr "<primary>رابط</primary><secondary>رابط مدیریتی</secondary>"

msgid "The main configuration is in the <filename>/etc/dirvish/master.conf</filename> file. It defines the location of the backup storage space, the list of “vaults” to manage, and default values for expiration of the backups. The rest of the configuration is located in the <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> files and contains the specific configuration for the corresponding set of files."
msgstr "پیکربندی اصلی آن در فایل <filename>/etc/dirvish/master.conf</filename> قرار دارد. در این فایل می‌توان محل ذخیره‌سازی فایل‌های پشتیبان، فهرست “صندوق‌ها” برای مدیریت و مقدار پیش‌فرض برای تاریخ انقضای آن‌ها را مشخص کرد. باقی پیکربندی در فایل‌های <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> قرار دارد که تنظیمات مختص به هر یک از فایل‌ها را شامل می‌شود."

msgid "The <filename>/etc/dirvish/master.conf</filename> file"
msgstr "فایل <filename>/etc/dirvish/master.conf</filename>"

msgid ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   MIN HR    DOM MON       DOW  STRFTIME_FMT\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"
msgstr ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   MIN HR    DOM MON       DOW  STRFTIME_FMT\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"

#, fuzzy
#| msgid "The <literal>bank</literal> setting indicates the directory in which the backups are stored. The <literal>exclude</literal> setting allows you to indicate files (or file types) to exclude from the backup. The <literal>Runall</literal> is a list of file sets to backup with a time-stamp for each set, which allows you to assign the correct date to the copy, in case the backup is not triggered at precisely the assigned time. You have to indicate a time just before the actual execution time (which is, by default, 10:04 pm in Debian, according to <filename>/etc/cron.d/dirvish</filename>). Finally, the <literal>expire-default</literal> and <literal>expire-rule</literal> settings define the expiration policy for backups. The above example keeps forever backups that are generated on the first Sunday of each quarter, deletes after one year those from the first Sunday of each month, and after 3 months those from other Sundays. Other daily backups are kept for 15 days. The order of the rules does matter, Dirvish uses the last matching rule, or the <literal>expire-default</literal> one if no other <literal>expire-rule</literal> matches."
msgid "The <literal>bank</literal> setting indicates the directory in which the backups are stored. The <literal>exclude</literal> setting allows you to indicate files (or file types) to exclude from the backup. The <literal>Runall</literal> is a list of file sets to backup with a time-stamp for each set, which allows you to assign the correct date to the copy, in case the backup is not triggered at precisely the assigned time. You have to indicate a time just before the actual execution time (according to <filename>/etc/cron.d/dirvish</filename>). Finally, the <literal>expire-default</literal> and <literal>expire-rule</literal> settings define the expiration policy for backups. The above example keeps forever backups that are generated on the first Sunday of each quarter, deletes after one year those from the first Sunday of each month, and after 3 months those from other Sundays. Other daily backups are kept for 15 days. The order of the rules does matter, Dirvish uses the last matching rule, or the <literal>expire-default</literal> one if no other <literal>expire-rule</literal> matches."
msgstr "گزینه <literal>bank</literal> دایرکتوری مورد نظر جهت پشتیبان‌گیری را مشخص می‌کند. گزینه <literal>exclude</literal> به شما امکان استخراج فایل‌ها (یا نوع فایل‌ها) از فرآیند پشتیبان‌گیری را می‌دهد. گزینه <literal>Runall</literal> فهرستی از فایل‌ها به منظور پشتیبان‌گیری به همراه بازه زمانی است، که به شما امکان تخصیص تاریخ صحیح برای رونوشت‌گیری را می‌دهد، در صورتی که پشتیبان در زمان مقرر صورت نگرفته باشد. باید یک زمان قبل از زمان اجرای آن (که به صورت پیش فرض ۱۰:۰۴ بعد از ظهر در دبیان بر طبق فایل <filename>/etc/cron.d/dirvish</filename> است) را مشخص کنید. در نهایت، تنظیمات <literal>expire-default</literal> و <literal>expire-rule</literal> سیاست انقضای فایل‌های پشتبان را مشخص می‌کنند. نمونه بالا فایل‌های پشتیبانی که در اولین یکشنه هر فصل ایجاد می‌شوند را تا ابد نگاه می‌دارد، اگر یک سال از اولین یکشنبه هر ماه بگذرد و پس از گذشت سه ماه از سایر یکشنبه‌ها آن‌ها را پاک می‌کند. سایر فایل‌های پشتیبان برای ۱۵ روز نگاه داشته می‌شوند. ترتیب این قانون‌ها اهمیت دارد، چرا که Dirvish از آخرین قانون صحیح استفاده می‌کند یا گزینه <literal>expire-default</literal> در صورتی که هیچ گزینه <literal>expire-rule</literal> یافت نشود."

msgid "<emphasis>IN PRACTICE</emphasis> Scheduled expiration"
msgstr "<emphasis>در عمل</emphasis> انقضای زمان‌بندی شده"

msgid "The expiration rules are not used by <command>dirvish-expire</command> to do its job. In reality, the expiration rules are applied when creating a new backup copy to define the expiration date associated with that copy. <command>dirvish-expire</command> simply peruses the stored copies and deletes those for which the expiration date has passed."
msgstr "قواعد انقضا توسط <command>dirvish-expire</command> برای انجام کارش استفاده نمی‌شوند. در واقعیت، این قواعد زمانی که هنگام ایجاد یک رونوشت از فایل پشتیبان برای تعیین تاریخ آن اعمال می‌شوند. <command>dirvish-expire</command> به سادگی از رونوشت‌های ذخیره شده استفاده کرده و آن‌هایی که تاریخشان گذشته باشد را حذف می‌کند."

msgid "The <filename>/backup/root/dirvish/default.conf</filename> file"
msgstr "فایل <filename>/backup/root/dirvish/default.conf</filename>"

msgid ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"
msgstr ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"

msgid "The above example specifies the set of files to back up: these are files on the machine <emphasis>rivendell.falcot.com</emphasis> (for local data backup, simply specify the name of the local machine as indicated by <command>hostname</command>), especially those in the root tree (<literal>tree: /</literal>), except those listed in <literal>exclude</literal>. The backup will be limited to the contents of one filesystem (<literal>xdev: 1</literal>). It will not include files from other mount points. An index of saved files will be generated (<literal>index: gzip</literal>), and the image will be named according to the current date (<literal>image-default: %Y%m%d</literal>)."
msgstr "نمونه بالا تعداد مشخصی از فایل‌ها را برای پشتبان‌گیری مشخص کرده است: فایل‌های روی رایانه <emphasis>rivendell.falcot.com</emphasis> (برای داده‌های پشتیبان محلی کافی است فقط نام رایانه که با دستور <command>hostname</command> معلوم می‌شود را وارد کنیم)، به خصوص آن‌هایی که در مسیر ریشه قرار دارند (<literal>tree: /</literal>)، بجز آن‌هایی که در مسیر <literal>exclude</literal> قرار گرفته‌اند. پشتیبان‌گیری محدود به محتوای یک فایل‌سیستم است (<literal>xdev: 1</literal>). شامل فایل‌های سایر نقاط اتصال نمی‌باشد. یک شاخص برای فایل‌های ذخیره شده تولید می‌شود (<literal>index: gzip</literal>) و فایل اصلی به صورت <literal>image-default: %Y%m%d</literal> و با تاریخ روز ثبت می‌گردد."

#, fuzzy
#| msgid "There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired."
msgid "There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired."
msgstr "گزینه‌های بسیاری موجود هستند که در صفحه راهنمای <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> مستندسازی گشته‌اند. زمانی که این فایل‌های پیکربندی تنظیم گردند، باید هر مجموعه فایل را با دستور <command>dirvish --vault <replaceable>vault</replaceable> --init</command> راه‌اندازی اولیه کنید. از این زمان به بعد به صورت روزانه فراخوانی <command>dirvish-runall</command> به صورت خودکار اقدام به ایجاد رونوشت‌های پشتیبان کرده و آن‌هایی را که تاریخ گذشته باشند حذف می‌کند."

msgid "<emphasis>IN PRACTICE</emphasis> Remote backup over SSH"
msgstr "<emphasis>در عمل</emphasis> پشتیبان‌گیری راه‌دور با استفاده از SSH"

msgid "When dirvish needs to save data to a remote machine, it will use <command>ssh</command> to connect to it, and will start <command>rsync</command> as a server. This requires the root user to be able to automatically connect to it. The use of an SSH authentication key allows precisely that (see <xref linkend=\"sect.ssh-key-based-auth\" />)."
msgstr "زمانی که dirvish نیاز دارد داده‌ها را در یک رایانه راه‌دور ذخیره کند، از <command>ssh</command> برای اتصال به آن استفاده کرده و <command>rsync</command> را به عنوان یک سرور راه‌اندازی می‌کند. این کار نیازمند دسترسی‌های کاربر root به منظور اتصال خودکار به آن است. استفاده از یک کلید احرازهویت SSH دقیقا این هدف را برآورده می‌سازد. (<xref linkend=\"sect.ssh-key-based-auth\" /> را مشاهده کنید)."

msgid "Restoring Machines without Backups"
msgstr "بازیابی رایانه‌هایی که فایل پشتیبان ندارند"

#, fuzzy
#| msgid "Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs prepared with <emphasis>Simple-CDD</emphasis> (see <xref linkend=\"sect.simple-cdd\" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to dconf (see <xref linkend=\"sect.gnome-desktop\" /> for more information about this)."
msgid "Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs/USB sticks prepared with <emphasis role=\"pkg\">simple-cdd</emphasis> (see <xref linkend=\"sect.simple-cdd\" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to <command>dconf</command> (see <xref linkend=\"sect.gnome-desktop\" /> for more information about this)."
msgstr "رایانه‌های رومیزی، که پشتیبان‌گیری نمی‌شوند، به آسادگی از طریق DVD-ROM مخصوص با استفاده از <emphasis>Simple-CDD</emphasis> قابل نصب مجدد هستند (<xref linkend=\"sect.simple-cdd\" /> را مشاهده کنید). از آنجا که این امر عملیات نصب را از ابتدا انجام می‌دهد هر گونه سفارشی‌کردن سیستم قبل از آن از بین می‌رود. اشکالی در این کار نیست چرا که تمام سیستم‌‌ها به یک دایرکتوری مرکزی LDAP برای مدیریت حساب کاربری متصل و بسیاری برنامه‌های رومیزی نیز به لطف dconf قابل پیکربندی هستند (برای اطلاعت بیشتر در این رابطه، <xref linkend=\"sect.gnome-desktop\" /> را مشاهده کنید)."

msgid "The Falcot Corp administrators are aware of the limits in their backup policy. Since they can't protect the backup server as well as a tape in a fireproof safe, they have installed it in a separate room so that a disaster such as a fire in the server room won't destroy backups along with everything else. Furthermore, they do an incremental backup on DVD-ROM once per week — only files that have been modified since the last backup are included."
msgstr "مدیرسیستم‌های شرکت فالکوت از محدودیت حجمی سیاست پشتیبان‌گیری خود آگاه هستند. از آنجا که محافظت از سرور پشتیبان به خوبی یک نوار مغناطیسی موجود در یک محفظه ضد آتش نیست، آن‌ها این سرور را در یک اتاق جداگانه نصب کرده‌اند تا در زمان حادثه برای اتاق اصلی سرور، خطری این سرور پشتیبان را تهدید نکند. علاوه بر این، آن‌ها از یک مکانیزم پشتیبان‌گیری افزایشی با استفاده از DVD به صورت هفتگی استفاده می‌کنند - که در آن تنها فایل‌های تغییر کرده از آخرین عملیات پشتیبان‌گیری لحاظ شده‌اند."

msgid "<emphasis>GOING FURTHER</emphasis> Backing up SQL and LDAP services"
msgstr "<emphasis>مطالعه بیشتر</emphasis> پشتیبان‌گیری از سرویس‌های SQL و LDAP"

msgid "<primary><command>xdelta</command></primary>"
msgstr "<primary><command>xdelta</command></primary>"

msgid "<primary><command>diff</command></primary>"
msgstr "<primary><command>diff</command></primary>"

msgid "<primary>dump</primary>"
msgstr "<primary>dump</primary>"

msgid "Many services (such as SQL or LDAP databases) cannot be backed up by simply copying their files (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times). As such, it is necessary to use an “export” mechanism to create a “data dump” that can be safely backed up. These are often quite large, but they compress well. To reduce the storage space required, you will only store a complete text file per week, and a <command>diff</command> each day, which is created with a command of the type <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. The <command>xdelta</command> program produces incremental differences from binary dumps."
msgstr "بسیاری از سرویس‌ها (مانند پایگاه‌داده‌های SQL و LDAP) به راحتی و با رونوشت‌گیری از فایل‌هایشان قابل ذخیره‌سازی نیستند (مگر در زمان پشتیبان‌گیری کاملا از کار بیفتند، که این امری دردسرساز است چرا که این سرویس‌ها باید در هر زمان فعال باشند). بنابراین، لازم است از یک مکانیزم “استخراج” برای ایجاد “رونوشت داده‌ها” که به راحتی قابل پشتیبان‌گیری هستند استفاده شود. این فایل‌ها اغلب بزرگ هستند اما به راحتی فشرده می‌شوند. برای کاهش فضای مورد نیاز ذخیره‌سازی، تنها کافی است یک فایل متنی کامل هر هفته ذخیره کنید، به همراه یک فایل <command>diff</command> روزانه، که از دستوری معادل با <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command> ایجاد می‌گردد. برنامه <command>xdelta</command> از داده‌های باینری می‌تواند فایل‌های اختلاف زمانی تولید کند."

msgid "<emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>, the standard for tape backups"
msgstr "<emphasis>فرهنگ</emphasis> <emphasis>TAR</emphasis>، استاندارد پشتیبان‌گیری نوار"

msgid "<primary>backup</primary><secondary>on tape</secondary>"
msgstr "<primary>پشتیبان‌گیری</primary><secondary>روی نوار مغناطیسی</secondary>"

msgid "<primary>tape, backup</primary>"
msgstr "<primary>نوار مغناطیسی، پشتیبان‌گیری</primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary><acronym>TAR</acronym></primary><seealso>tape archive</seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>tape, backup</primary>"
msgid "<primary>tape archive</primary>"
msgstr "<primary>نوار مغناطیسی، پشتیبان‌گیری</primary>"

msgid "Historically, the simplest means of making a backup on Unix was to store a <emphasis>TAR</emphasis> archive on a tape. The <command>tar</command> command even got its name from “Tape ARchive”."
msgstr "به لحاظ تاریخی، ساده‌ترین روش برای پشتیبان‌گیری در یونیکس ذخیره‌سازی یک بایگانی <emphasis>TAR</emphasis> روی نوار مغناطیسی بود. دستور <command>tar</command> حتی نام خود را از عبارت “Tape ARchive” وام گرفته است."

msgid "Hot Plugging: <emphasis>hotplug</emphasis>"
msgstr "اتصال سریع: <emphasis>hotplug</emphasis>"

msgid "Introduction"
msgstr "مقدمه"

msgid "<primary>hotplug</primary>"
msgstr "<primary>اتصال سریع</primary>"

#, fuzzy
#| msgid "<primary>booting</primary><secondary>the system</secondary>"
msgid "<primary>kernel</primary><secondary>hotplug subsystem</secondary>"
msgstr "<primary>راه‌اندازی</primary><secondary>سیستم</secondary>"

#, fuzzy
#| msgid "<primary><command>inetd</command></primary>"
msgid "<primary><command>udevd</command></primary>"
msgstr "<primary><command>inetd</command></primary>"

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>/dev</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>device</primary><seealso><filename>/dev</filename></seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

msgid "<primary>PCMCIA</primary>"
msgstr "<primary>PCMCIA</primary>"

msgid "<primary>SATA</primary>"
msgstr "<primary>SATA</primary>"

#, fuzzy
#| msgid "The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be hotplugged: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory."
msgid "The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be “hotplugged“: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory."
msgstr "زیرسیستم <emphasis>hotplug</emphasis> از کرنل به صورت پویا اضافه و حذف شدن دستگاه‌ها را مدیریت می‌کند، با بارگیری درایورهای مناسب و ایجاد فایل‌های مخصوص به هر دستگاه (با کمک دستور <command>udevd</command>). با وجود سخت‌افزار جدید و عملیات مجازی‌سازی، تقریبا هر چیزی قابلیت اتصال سریع را دارد: از دستگاه‌های متداول USB/PCMCIA/IEEE 1394 گرفته تا هارد درایوهای SATA، همچنین پردازنده و حافظه اصلی."

msgid "The kernel has a database that associates each device ID with the required driver. This database is used during boot to load all the drivers for the peripheral devices detected on the different buses, but also when an additional hotplug device is connected. Once the device is ready for use, a message is sent to <command>udevd</command> so it will be able to create the corresponding entry in <filename>/dev/</filename>."
msgstr "کرنل شامل پایگاه‌داده‌ای است که هر شناسه دستگاه را به درایور مخصوص به آن ثبت می‌کند. این پایگاه‌داده در زمان راه‌اندازی اولیه به منظور بارگیری تمام درایورهای مورد نیاز برای دستگاه‌های شناخته شده در خطوط ارتباطی مختلف استفاده می‌شود، همچنین در زمانی که یک دستگاه جانبی به سیستم متصل می‌گردد. زمانی که دستگاه آماده استفاده باشد یک پیام به <command>udevd</command> ارسال می‌شود تا فایل مورد نظر دستگاه در <filename>/dev/</filename> را ایجاد کند."

msgid "The Naming Problem"
msgstr "مشکل نامگذاری"

msgid "Before the appearance of hotplug connections, it was easy to assign a fixed name to a device. It was based simply on the position of the devices on their respective bus. But this is not possible when such devices can come and go on the bus. The typical case is the use of a digital camera and a USB key, both of which appear to the computer as disk drives. The first one connected may be <filename>/dev/sdb</filename> and the second <filename>/dev/sdc</filename> (with <filename>/dev/sda</filename> representing the computer's own hard drive). The device name is not fixed; it depends on the order in which devices are connected."
msgstr "قبل از ظهور قابلیت اتصال، انتساب یک نام ثابت به یک دستگاه کار ساده‌ای بود. اینکار بر اساس موقعیت دستگاه‌ها روی گذرگاه سیستم انجام می‌شد. اما این امکان برای دستگاه‌هایی که روی این گذرگاه وارد و خارج می‌شوند وجود ندارد. مورد متداول هم کاربرد دوربین دیجیتال و حافظه جانبی USB است، که هر دو در رایانه به عنوان هارد درایو ظاهر می‌شوند. اولی به نام <filename>/dev/sdb</filename> و دومی به نام <filename>/dev/sdc</filename> (به همراه <filename>/dev/sda</filename> که نام هارد درایو اصلی رایانه است). نام دستگاه ثابت نیست؛ در حقیقت به ترتیبی که دستگاه‌ها متصل می‌شوند ارتباط دارد."

msgid "Additionally, more and more drivers use dynamic values for devices' major/minor numbers, which makes it impossible to have static entries for the given devices, since these essential characteristics may vary after a reboot."
msgstr "علاوه بر این، درایورهای بیشتری از شماره‌گذاری ماژور/مینور دستگاه‌ها استفاده می‌کنند که امکان نامگذاری ثابت دستگاه‌ها را از بین می‌برد چرا که این خصوصیات ضروری در هر مرتبه راه‌اندازی سیستم از بین می‌روند."

#, fuzzy
#| msgid "<primary>inode</primary>"
msgid "<primary>udev</primary>"
msgstr "<primary>inode</primary>"

msgid "<emphasis>udev</emphasis> was created precisely to solve this problem."
msgstr "<emphasis>udev</emphasis> دقیقا به منظور حل این مشکل ایجاد شد."

msgid "How <emphasis>udev</emphasis> Works"
msgstr "چگونگی کارکرد <emphasis>udev</emphasis>"

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>/sys</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/udev/rules.d/</filename></secondary>"
msgstr "<primary>کلاینت</primary><secondary>معماری کلاینت/سرور</secondary>"

#, fuzzy
#| msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgid "<primary><filename>/lib</filename></primary><secondary><filename>/lib/udev/rules.d/</filename></secondary>"
msgstr "<primary>ماژول‌ها</primary><secondary>ماژول‌های کرنل</secondary>"

msgid "When <emphasis>udev</emphasis> is notified by the kernel of the appearance of a new device, it collects various information on the given device by consulting the corresponding entries in <filename>/sys/</filename>, especially those that uniquely identify it (MAC address for a network card, serial number for some USB devices, etc.)."
msgstr "زمانی که کرنل <emphasis>udev</emphasis> را از وجود یک دستگاه جدید آگاه می‌کند، این برنامه به جمع‌آوری اطلاعات مختلف در رابطه با دستگاه از طریق <filename>/sys/</filename> می‌پردازد، به خصوص اطلاعاتی که منجر به شناسایی دستگاه می‌شوند (نشانی MAC برای یک کارت شبکه، شماره سریال برخی دستگاه‌های USB و از این قبیل)."

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>udev</primary><secondary>rules</secondary>"
msgstr "<primary>کاربر</primary><secondary>مالک</secondary>"

msgid "Armed with all of this information, <emphasis>udev</emphasis> then consults all of the rules contained in <filename>/etc/udev/rules.d/</filename> and <filename>/lib/udev/rules.d/</filename>. In this process it decides how to name the device, what symbolic links to create (to give it alternative names), and what commands to execute. All of these files are consulted, and the rules are all evaluated sequentially (except when a file uses “GOTO” directives). Thus, there may be several rules that correspond to a given event."
msgstr "هنگامی که این اطلاعت بدست آمد، <emphasis>udev</emphasis> به مجموعه قواعد موجود در <filename>/etc/udev/rules.d/</filename> و <filename>/lib/udev/rules.d/</filename> مراجعه می‌کند. در این فرآیند تصمیم می‌گیرد که چه نامی به دستگاه اختصاص دهد، از چه پیوندهای نمادین برای ایجاد کردنش استفاده کند (برای اختصاص نام مستعار) و چه دستوراتی را اجرا کند. تمام این فایل‌ها مورد بررسی قرار می‌گیرند و قواعد موجود در آن‌ها به ترتیب ارزیابی می‌گردند (بجز حالتی که یک فایل از عبارت “GOTO” استفاده کند). پس، ممکن است چندین قاعده درباره یک رخداد بررسی شوند."

msgid "The syntax of rules files is quite simple: each row contains selection criteria and variable assignments. The former are used to select events for which there is a need to react, and the latter defines the action to take. They are all simply separated with commas, and the operator implicitly differentiates between a selection criterion (with comparison operators, such as <literal>==</literal> or <literal>!=</literal>) or an assignment directive (with operators such as <literal>=</literal>, <literal>+=</literal> or <literal>:=</literal>)."
msgstr "شیوه نگارش این قواعد تقریبا ساده است: هر سطر شامل شرایط انتخاب و انتساب متغیرها است. اولی برای انتخاب رویدادها جهت پاسخ دادن و دومی اقدام مورد نظر در پاسخ به آن رویداد است. تمام این قواعد با کاما از یکدیگر جدا شده‌اند و عملگر بین شرایط انتخاب (با عملگرهای مقایسه‌ای، مانند <literal>==</literal> یا <literal>!=</literal>) یا شرایط انتساب (با عملگرهایی نظیر <literal>=</literal>، <literal>+=</literal> یا <literal>:=</literal>) تفاوت قائل می‌شود."

msgid "Comparison operators are used on the following variables:"
msgstr "عملگرهای مقایسه‌ای روی متغیرهای زیر اعمال می‌شوند:"

msgid "<literal>KERNEL</literal>: the name that the kernel assigns to the device;"
msgstr "<literal>KERNEL</literal>: نامی که کرنل به دستگاه اختصاص داده است؛"

msgid "<literal>ACTION</literal>: the action corresponding to the event (“add” when a device has been added, “remove” when it has been removed);"
msgstr "<literal>ACTION</literal>: پاسخ متناظر به رویداد (“add” زمانی که دستگاه اضافه شده یا “remove” زمانی که دستگاه حذف شده باشد)؛"

msgid "<literal>DEVPATH</literal>: the path of the device's <filename>/sys/</filename> entry;"
msgstr "<literal>DEVPATH</literal>: مسیر دستگاه در ساختار <filename>/sys/</filename>؛"

msgid "<literal>SUBSYSTEM</literal>: the kernel subsystem which generated the request (there are many, but a few examples are “usb”, “ide”, “net”, “firmware”, etc.);"
msgstr "<literal>SUBSYSTEM</literal>: زیرسیستم کرنل که درخواست را ایجاد کرده است (گزینه‌های زیادی وجود دارند اما برخی عبارتند از “usb”، “ide”، “net”، “firmware”، و از این قبیل);"

msgid "<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: file contents of the <replaceable>attribute</replaceable> file in the <filename>/sys/<replaceable>$devpath</replaceable>/</filename> directory of the device. This is where you find the MAC address and other bus specific identifiers;"
msgstr "<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: محتوای فایل <replaceable>attribute</replaceable> در دایرکتوری <filename>/sys/<replaceable>$devpath</replaceable>/</filename> دستگاه. اینجاست که می‌توانید نشانی MAC و سایر شناسه‌های مخصوص گذرگاه را پیدا کنید."

msgid "<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> and <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> are variations that will try to match the different options on one of the parent devices of the current device;"
msgstr "<literal>KERNELS</literal>، <literal>SUBSYSTEMS</literal> و <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> انواع گوناگونی هستند که تلاش دارند گزینه‌های مختلف در رابطه با دستگاه‌های والد با دستگاه فعلی را سازگار سازند."

msgid "<literal>PROGRAM</literal>: delegates the test to the indicated program (true if it returns 0, false if not). The content of the program's standard output is stored so that it can be reused by the <literal>RESULT</literal> test;"
msgstr "<literal>PROGRAM</literal>: نماینده آزمون برای برنامه مشخص شده است (در صورت بازگرداندن ۰ برابر با true، در غیر اینصورت false). محتوای خروحی استاندارد برنامه ذخیره می‌شود تا توسط آزمون <literal>RESULT</literal> قابل استفاده باشد."

msgid "<literal>RESULT</literal>: execute tests on the standard output stored during the last call to <literal>PROGRAM</literal>."
msgstr "<literal>RESULT</literal>: آزمون‌های مورد نظر را روی خروجی استاندارد ذخیره شده از آخرین فراخوانی <literal>PROGRAM</literal> اجرا می‌کند."

msgid "The right operands can use pattern expressions to match several values at the same time. For instance, <literal>*</literal> matches any string (even an empty one); <literal>?</literal> matches any character, and <literal>[]</literal> matches the set of characters listed between the square brackets (or the opposite thereof if the first character is an exclamation point, and contiguous ranges of characters are indicated like <literal>a-z</literal>)."
msgstr "عملگر سمت راست می‌تواند به شیوه‌ای استفاده شود که امکان انتخاب چند مقدار در یک لحظه را داشته باشد. برای نمونه، <literal>*</literal> هر رشته‌ای را شامل می‌شود (حتی رشته خالی)؛ <literal>?</literal> هر کاراکتری را شامل می‌شود و <literal>[]</literal> مجموعه از کاراکترهای محدود را شامل می‌شود (یا خلاف آن، در صورتی که اولین کاراکتر برابر با ! باشد و بازه پیوسته کاراکترها به صورت <literal>a-z</literal> بیان شود)."

msgid "Regarding the assignment operators, <literal>=</literal> assigns a value (and replaces the current value); in the case of a list, it is emptied and contains only the value assigned. <literal>:=</literal> does the same, but prevents later changes to the same variable. As for <literal>+=</literal>, it adds an item to a list. The following variables can be changed:"
msgstr "با توجه به عملگرهای انتسابی، <literal>=</literal> یک مقدار را نسبت می‌دهد (که جایگزین مقدار فعلی می‌شود)؛ در مورد یک فهرست، خالی می‌شود و تنها مقدار انتسابی را شامل می‌گردد. <literal>:=</literal> نیز همین کار را کرده، اما از تغییرات بعدی آن متغیر جلوگیری می‌کند. همینطور <literal>+=</literal> که یک گزینه به فهرست اضافه می‌کند. متغیرهای زیر می‌توانند تغییر کنند:"

msgid "<literal>NAME</literal>: the device filename to be created in <filename>/dev/</filename>. Only the first assignment counts; the others are ignored;"
msgstr "<literal>NAME</literal>: نام دستگاه که در مسیر <filename>/dev/</filename> ایجاد می‌شود. تنها اولین انتساب به حساب می‌آید؛ باقی انتساب‌ها نادیده گرفته می‌شوند؛"

msgid "<literal>SYMLINK</literal>: the list of symbolic links that will point to the same device;"
msgstr "<literal>SYMLINK</literal>: فهرستی از پیوندهای نمادین که به یک دستگاه اشاره می‌کنند؛"

msgid "<literal>OWNER</literal>, <literal>GROUP</literal> and <literal>MODE</literal> define the user and group that owns the device, as well as the associated permission;"
msgstr "<literal>Owner</literal>، <literal>Group</literal> و <literal>MODE</literal> کاربر و گروه و مجوزهای مورد نیاز دستگاه را تعریف می‌کنند؛"

msgid "<literal>RUN</literal>: the list of programs to execute in response to this event."
msgstr "<literal>RUN</literal>: فهرست برنامه‌هایی که در پاسخ به این رویداد باید اجرا شوند."

msgid "The values assigned to these variables may use a number of substitutions:"
msgstr "مقدارهای انتسابی به این متغیرها می‌توانند از جایگزین‌های زیر استفاده کنند:"

msgid "<literal>$kernel</literal> or <literal>%k</literal>: equivalent to <literal>KERNEL</literal>;"
msgstr "<literal>$kernel</literal> یا <literal>%k</literal>: معادل با <literal>KERNEL</literal>؛"

msgid "<literal>$number</literal> or <literal>%n</literal>: the order number of the device, for example, for <literal>sda3</literal>, it would be “3”;"
msgstr "<literal>$number</literal> یا <literal>%n</literal>: شماره ترتیبی برای دستگاه، برای نمونه در <literal>sda3</literal> برابر با “3”؛"

msgid "<literal>$devpath</literal> or <literal>%p</literal>: equivalent to <literal>DEVPATH</literal>;"
msgstr "<literal>$devpath</literal> یا <literal>%p</literal>: معادل با <literal>DEVPATH</literal>؛"

msgid "<literal>$attr{<replaceable>attribute</replaceable>}</literal> or <literal>%s{<replaceable>attribute</replaceable>}</literal>: equivalent to <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;"
msgstr "<literal>$attr{<replaceable>attribute</replaceable>}</literal> یا <literal>%s{<replaceable>attribute</replaceable>}</literal>: معادل با <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>؛"

msgid "<literal>$major</literal> or <literal>%M</literal>: the kernel major number of the device;"
msgstr "<literal>$major</literal> یا <literal>%M</literal>: شماره ماژور کرنل برای دستگاه؛"

msgid "<literal>$minor</literal> or <literal>%m</literal>: the kernel minor number of the device;"
msgstr "<literal>$minor</literal> یا <literal>%m</literal>: شماره مینور کرنل برای دستگاه؛"

msgid "<literal>$result</literal> or <literal>%c</literal>: the string output by the last program invoked by <literal>PROGRAM</literal>;"
msgstr "<literal>$result</literal> یا <literal>%c</literal>: رشته خروجی آخرین برنامه‌ای که توسط <literal>PROGRAM</literal> فراخوانی شده است؛"

msgid "and, finally, <literal>%%</literal> and <literal>$$</literal> for the percent and dollar sign, respectively."
msgstr "و در نهایت، <literal>%%</literal> و <literal>$$</literal> برای علامت‌های درصد و دلار."

#, fuzzy
#| msgid "The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive."
msgid "The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle> <manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive."
msgstr "فهرست بالا کامل نیست (تنها شامل مهم‌ترین پارامترها است)، اما صفحه راهنمای <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> تمام پارامترها را شامل می‌شود."

msgid "A concrete example"
msgstr "یک مثال کامل"

msgid "Let us consider the case of a simple USB key and try to assign it a fixed name. First, you must find the elements that will identify it in a unique manner. For this, plug it in and run <command>udevadm info -a -n /dev/sdc</command> (replacing <replaceable>/dev/sdc</replaceable> with the actual name assigned to the key)."
msgstr "بیایید یک حافظه جانبی USB را در نظر بگیریم که می‌خواهیم نامی ثابت برایش ایجاد کنیم. ابتدا، باید شیوه‌ای برای شناسایی منحصربفرد آن بیابید. به این منظور، دستگاه را متصل کرده و دستور <command>udevadm info -a -n /dev/sdc</command> را اجرا کنید (<replaceable>/dev/sdc</replaceable> را با نام انتسابی به دستگاه جایگزین کنید)."

#, fuzzy
#| msgid ""
#| "<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
#| "<computeroutput>[...]\n"
#| "  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':\n"
#| "    KERNEL==\"sdc\"\n"
#| "    SUBSYSTEM==\"block\"\n"
#| "    DRIVER==\"\"\n"
#| "    ATTR{range}==\"16\"\n"
#| "    ATTR{ext_range}==\"256\"\n"
#| "    ATTR{removable}==\"1\"\n"
#| "    ATTR{ro}==\"0\"\n"
#| "    ATTR{size}==\"126976\"\n"
#| "    ATTR{alignment_offset}==\"0\"\n"
#| "    ATTR{capability}==\"53\"\n"
#| "    ATTR{stat}==\"      51      100     1208      256        0        0        0        0        0      192      25        6\"\n"
#| "    ATTR{inflight}==\"       0        0\"\n"
#| "[...]\n"
#| "  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':\n"
#| "    KERNELS==\"9:0:0:0\"\n"
#| "    SUBSYSTEMS==\"scsi\"\n"
#| "    DRIVERS==\"sd\"\n"
#| "    ATTRS{device_blocked}==\"0\"\n"
#| "    ATTRS{type}==\"0\"\n"
#| "    ATTRS{scsi_level}==\"3\"\n"
#| "    ATTRS{vendor}==\"I0MEGA  \"\n"
#| "    ATTRS{model}==\"UMni64MB*IOM2C4 \"\n"
#| "    ATTRS{rev}==\"    \"\n"
#| "    ATTRS{state}==\"running\"\n"
#| "[...]\n"
#| "    ATTRS{max_sectors}==\"240\"\n"
#| "[...]\n"
#| "  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':\n"
#| "    KERNELS==\"9:0:0:0\"\n"
#| "    SUBSYSTEMS==\"usb\"\n"
#| "    DRIVERS==\"usb\"\n"
#| "    ATTRS{configuration}==\"iCfg\"\n"
#| "    ATTRS{bNumInterfaces}==\" 1\"\n"
#| "    ATTRS{bConfigurationValue}==\"1\"\n"
#| "    ATTRS{bmAttributes}==\"80\"\n"
#| "    ATTRS{bMaxPower}==\"100mA\"\n"
#| "    ATTRS{urbnum}==\"398\"\n"
#| "    ATTRS{idVendor}==\"4146\"\n"
#| "    ATTRS{idProduct}==\"4146\"\n"
#| "    ATTRS{bcdDevice}==\"0100\"\n"
#| "[...]\n"
#| "    ATTRS{manufacturer}==\"USB Disk\"\n"
#| "    ATTRS{product}==\"USB Mass Storage Device\"\n"
#| "    ATTRS{serial}==\"M004021000001\"\n"
#| "[...]\n"
#| "</computeroutput>"
msgid ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{hidden}==\"0\"\n"
"    ATTR{events}==\"media_change\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{discard_alignment}==\"0\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{events_async}==\"\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"51\"\n"
"    ATTR{events_poll_msecs}==\"-1\"\n"
"    ATTR{stat}==\"130  0  6328  435  0  0  0  0  0  252  252  0  0  0  0\"\n"
"    ATTR{size}==\"15100224\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{inflight}==\"0  0\"\n"
"[...]\n"
"\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0':\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1':\n"
"    KERNELS==\"2-1\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{bDeviceProtocol}==\"00\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{busnum}==\"2\"\n"
"    ATTRS{quirks}==\"0x0\"\n"
"    ATTRS{authorized}==\"1\"\n"
"    ATTRS{ltm_capable}==\"no\"\n"
"    ATTRS{speed}==\"480\"\n"
"    ATTRS{product}==\"TF10\"\n"
"    ATTRS{manufacturer}==\"TDK LoR\"\n"
"[...]\n"
"    ATTRS{serial}==\"07032998B60AB777\"\n"
"[...]\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{size}==\"126976\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"53\"\n"
"    ATTR{stat}==\"      51      100     1208      256        0        0        0        0        0      192      25        6\"\n"
"    ATTR{inflight}==\"       0        0\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':\n"
"    KERNELS==\"9:0:0:0\"\n"
"    SUBSYSTEMS==\"scsi\"\n"
"    DRIVERS==\"sd\"\n"
"    ATTRS{device_blocked}==\"0\"\n"
"    ATTRS{type}==\"0\"\n"
"    ATTRS{scsi_level}==\"3\"\n"
"    ATTRS{vendor}==\"I0MEGA  \"\n"
"    ATTRS{model}==\"UMni64MB*IOM2C4 \"\n"
"    ATTRS{rev}==\"    \"\n"
"    ATTRS{state}==\"running\"\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':\n"
"    KERNELS==\"9:0:0:0\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{configuration}==\"iCfg\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{bConfigurationValue}==\"1\"\n"
"    ATTRS{bmAttributes}==\"80\"\n"
"    ATTRS{bMaxPower}==\"100mA\"\n"
"    ATTRS{urbnum}==\"398\"\n"
"    ATTRS{idVendor}==\"4146\"\n"
"    ATTRS{idProduct}==\"4146\"\n"
"    ATTRS{bcdDevice}==\"0100\"\n"
"[...]\n"
"    ATTRS{manufacturer}==\"USB Disk\"\n"
"    ATTRS{product}==\"USB Mass Storage Device\"\n"
"    ATTRS{serial}==\"M004021000001\"\n"
"[...]\n"
"</computeroutput>"

msgid "To create a new rule, you can use tests on the device's variables, as well as those of one of the parent devices. The above case allows us to create two rules like these:"
msgstr "برای ایجاد یک قانون جدید، می‌توانید از آزمون‌های روی متغیرهای دستگاه استفاده کنید، یا هر یک از دستگاه‌های والد آن. مورد بالا به ما اجازه ایجاد دو قانون به صورت زیر را می‌دهد:"

#, fuzzy
#| msgid ""
#| "KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/disk\"\n"
#| "KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/part%n\""
msgid ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/part%n\""
msgstr ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/part%n\""

msgid "Once these rules are set in a file, named for example <filename>/etc/udev/rules.d/010_local.rules</filename>, you can simply remove and reconnect the USB key. You can then see that <filename>/dev/usb_key/disk</filename> represents the disk associated with the USB key, and <filename>/dev/usb_key/part1</filename> is its first partition."
msgstr "زمانی که این قوانین در یک فایل تنظیم شوند، برای نمونه <filename>/etc/udev/rules.d/010_local.rules</filename>، به سادگی می‌توانید حافظه را جدا کرده و از نو نصب کنید. مشاهده خواهید کرد که <filename>/dev/usb_key/disk</filename> نشان‌دهنده حافظه USB و <filename>/dev/usb_key/part1</filename> نشان‌دهنده اولین پارتیشن آن است."

msgid "<emphasis>GOING FURTHER</emphasis> Debugging <emphasis>udev</emphasis>'s configuration"
msgstr "<emphasis>مطالعه بیشتر</emphasis> اشکال‌زدایی پیکربندی <emphasis>udev</emphasis>"

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary><command>udevd</command></primary><secondary><filename>/var/log/daemon.log</filename></secondary>"
msgstr "<primary>ورود</primary><secondary>ورود از راه‌دور</secondary>"

#, fuzzy
#| msgid "<primary><command>kdm</command></primary>"
msgid "<primary><command>udevadm</command></primary>"
msgstr "<primary><command>kdm</command></primary>"

msgid "Like many daemons, <command>udevd</command> stores logs in <filename>/var/log/daemon.log</filename>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <command>udevadm control --log-priority=info</command> command increases the verbosity level and solves this problem. <command>udevadm control --log-priority=err</command> returns to the default verbosity level."
msgstr "مانند بسیاری فرآیندهای پس‌زمینه، <command>udevd</command> نیز گزارش‌های خود را در <filename>/var/log/daemon.log</filename> ذخیره می‌کند. اما به صورت پیش‌فرض خیلی خوانا نیستند و برای درک شرایط موجود به کار نمی‌آیند. دستور <command>udevadm control --log-priority=info</command> سطح جزئیات را بالا برده و این مشکل را حل می‌کند. <command>udevadm control --log-priority=err</command> نیز به حالت پیش‌فرض باز می‌گردد."

msgid "Power Management: Advanced Configuration and Power Interface (ACPI)"
msgstr "مدیریت نیرو؛ پیکربندی پیشرفته و رابط کار با نیرو (ACPI)"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>power management</primary><seealso>ACPI</seealso>"
msgstr "<primary>تونل SSH</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>management, power management</primary>"
msgid "<primary>management, power management</primary><seealso>ACPI</seealso>"
msgstr "<primary>مدیریت، مدیریت نیرو</primary>"

msgid "<primary>ACPI</primary>"
msgstr "<primary>ACPI</primary>"

#, fuzzy
#| msgid "<primary>Advanced Configuration and Power Interface</primary>"
msgid "<primary>Advanced Configuration and Power Interface</primary><seealso>ACPI</seealso>"
msgstr "<primary>Advanced Configuration and Power Interface</primary>"

msgid "<primary><command>acpid</command></primary>"
msgstr "<primary><command>acpid</command></primary>"

msgid "The topic of power management is often problematic. Indeed, properly suspending the computer requires that all the computer's device drivers know how to put them to standby, and that they properly reconfigure the devices upon waking. Unfortunately, there are still a few devices unable to sleep well under Linux, because their manufacturers have not provided the required specifications."
msgstr "موضوع مدیریت نیرو اغلب دردسرساز است. در حقیقت، اینکه رایانه را به حالت تعلیق ببریم مستلزم این است که تمام درایورهای آن بدانند چطور اینکار صورت می‌گیرد و هنگام برخواستن نیز بتوانند دستگاه‌ها را به درستی پبکربندی کنند. متاسفانه، هنوز برخی دستگاه‌ها هستند که در لینوکس به خوبی نمی‌توانند استراحت کنند، چرا که تولیدکنندگان آن‌ها استاندارد اینکار را ارائه نکرده‌اند."

#, fuzzy
#| msgid "Linux supports ACPI (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role=\"pkg\">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response."
msgid "Linux supports <acronym>ACPI</acronym> (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role=\"pkg\">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response."
msgstr "لینوکس از ACPI یا Advanced Configuration and Power Interface پشتیبانی می‌کند - آخرین استاندارد مدیریت نیرو. بسته <emphasis role=\"pkg\">acpid</emphasis> یک فرآیند پس‌زمینه را شامل می‌شود که مسئول نگهداری از رویدادهای مربوط به مدیریت نیرو است (سوئیچ بین برق و باتری در لپ‌تاپ و از این قبیل) و می‌تواند در پاسخ، دستورات مختلفی را اجرا کند."

msgid "<emphasis>BEWARE</emphasis> Graphics card and standby"
msgstr "<emphasis>آگاه‌باشید</emphasis> کارت‌های گرافیکی و حالت تعلیق"

msgid "The graphics card driver is often the culprit when standby doesn't work properly. In that case, it is a good idea to test the latest version of the X.org graphics server."
msgstr "کارت‌های گرافیکی اغلب مقصر اصلی درست کار نکردن حالت تعلیق هستند. در این مورد، بهتر است که آخرین نسخه سرور گرافیکی X.org را بررسی کنید."

msgid "After this overview of basic services common to many Unix systems, we will focus on the environment of the administered machines: the network. Many services are required for the network to work properly. They will be discussed in the next chapter."
msgstr "پس از بررسی سرویس‌های پایه که در بسیاری سیستم‌های یونیکس متداول هستند، روی محیط رایانه‌‌های مدیریت شده تمرکز می‌کنیم: یعنی شبکه. بسیاری سرویس‌ها برای عملکرد صحیح نیازمند شبکه هستند. در فصل بعد به بررسی آن‌ها می‌پردازیم."

#~ msgid "<emphasis role=\"pkg\">file-rc</emphasis> is a boot system with a very simple process. It keeps the principle of runlevels, but replaces the directories and symbolic links with a configuration file, which indicates to <command>init</command> the processes that must be started and their launch order."
#~ msgstr "<emphasis role=\"pkg\">file-rc</emphasis> یک سیستم راه‌انداز با فرآیندی بسیار ساده است. بر اساس اصول runlevel کار کرده، اما دایرکتوری‌ها و پیوندهای نمادین را با یک فایل پیکربندی جایگزین می‌کند، که به <command>init</command> فرآیندهای مورد نیاز جهت اجرا و ترتیب اجرای هر کدام را نشان می‌دهد."

#~ msgid "As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed."
#~ msgstr "همانطور که مشاهده می‌کنید، کد بسیار کمی در آن وجود دارد، تنها تعریف‌های مورد نیاز. systemd مواردی از قبیل نمایش گزارش‌های پیشرفت، بررسی وضعیت فرآیندها و حتی اجرای مجددشان هر زمان لازم باشد را انجام می‌دهد."

#~ msgid "<primary>Secure Shell</primary>"
#~ msgstr "<primary>Secure Shell</primary>"

#~ msgid "<primary>OpenSSH</primary>"
#~ msgstr "<primary>OpenSSH</primary>"

#~ msgid "VNC also works for mobile users, or company executives, who occasionally need to login from their home to access a remote desktop similar to the one they use at work. The configuration of such a service is more complicated: you first install the <emphasis role=\"pkg\">vnc4server</emphasis> package, change the configuration of the display manager to accept <literal>XDMCP Query</literal> requests (for <command>gdm3</command>, this can be done by adding <literal>Enable=true</literal> in the “xdmcp” section of <filename>/etc/gdm3/daemon.conf</filename>), and finally, start the VNC server with <command>inetd</command> so that a session is automatically started when a user tries to login. For example, you may add this line to <filename>/etc/inetd.conf</filename>:"
#~ msgstr "VNC همچنین برای کاربران یک شرکت، مانند مدیران اجرایی، که نیاز به دسترسی به رایانه شرکت از خانه خود را دارند بکار می‌رود. پیکربندی چنین سرویسی کمی پیچیده‌تر است: ابتدا بسته <emphasis role=\"pkg\">vnc4server</emphasis> را نصب می‌کنید، پیکربندی مدیر نمایش را به منظور قبول درخواست‌های <literal>XDMCP Query</literal> تغییر می‌دهید (برای <command>gdm3</command>، اینکار با افزودن <literal>Enable=true</literal> در قسمت “xdmcp” از فایل <filename>/etc/gdm3/daemon.conf</filename> صورت می‌گیرد) و در نهایت سرور VNC را با استفاده از <command>inetd</command> آغاز می‌کنید به طوری که هر زمان کاربر درخواست داد نشست مربوطه آغاز گردد. برای نمونه، می‌توانید این خط را به فایل <filename>/etc/inetd.conf</filename> بیفزایید:"

#~ msgid "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"
#~ msgstr "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"

#~ msgid "Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <command>gdm3</command> login screen (or equivalent <command>kdm</command>, <command>xdm</command>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <command>vncviewer <replaceable>server</replaceable>:50</command>, because the port used is 5950."
#~ msgstr "هدایت ارتباطات ورودی به مدیر نمایش مشکل احراز هویت را حل می‌کند، چرا که تنها کاربران با حساب‌های کاربری محلی می‌توانند از صفحه <command>gdm3</command> عبور کنند (یا معادل <command>kdm</command>، <command>xdm</command> و از این قبیل). از آنجا که این عملیات امکان چندین ورودی مختلف را فراه می‌کند (در صورت قوی بودن سرور)، می‌تواند برای ارائه میزکارهای گرافیکی برای کاربران سیار (یا برای سیستم‌های رومیزی ضعیف‌تر) استفاده شود. کاربران تنها کافی است با استفاده از <command>vncviewer <replaceable>server</replaceable>:50</command> به سرور متصل شوند، چرا که پورت مورد استفاده ۵۹۵۰ است."

#~ msgid "<primary>rights</primary>"
#~ msgstr "<primary>دسترسی‌ها</primary>"

#~ msgid "<primary>umask</primary>"
#~ msgstr "<primary>umask</primary>"

#~ msgid "<primary><command>debconf</command></primary>"
#~ msgstr "<primary><command>debconf</command></primary>"

#~ msgid "<primary>pipe, named pipe</primary>"
#~ msgstr "<primary>لوله، لوله نامگذاری شده</primary>"

#~ msgid "The following example illustrates the most common cases:"
#~ msgstr "نمونه زیر شامل متداول‌ترین گزینه‌ها است:"

#~ msgid ""
#~ "talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
#~ "finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
#~ "ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"
#~ msgstr ""
#~ "talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
#~ "finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
#~ "ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"

#~ msgid "<primary><command>warnquota</command></primary>"
#~ msgstr "<primary><command>warnquota</command></primary>"

#~ msgid "<primary><emphasis>hotplug</emphasis></primary>"
#~ msgstr "<primary><emphasis>hotplug</emphasis></primary>"

#~ msgid "<primary>power management</primary>"
#~ msgstr "<primary>مدیریت نیرو</primary>"

#~ msgid "<emphasis>IN PRACTICE</emphasis> Network card management"
#~ msgstr "<emphasis>در عمل</emphasis> مدیریت کارت شبکه"

#~ msgid "Many computers have multiple network cards (sometimes two wired interfaces and a wifi interface), and with <emphasis>hotplug</emphasis> support on most bus types, the Linux kernel does not guarantee fixed naming of network interfaces. But users who want to configure their network in <filename>/etc/network/interfaces</filename> need a fixed name!"
#~ msgstr "بسیاری رایانه‌ها چندین رابط شبکه دارند (بعضی وقت‌ها دو رابط سیمی و یک رابط بیسیم) و با پشتیبانی <emphasis>hotplug</emphasis> در اکثر طراحی‌های گذرگاه، کرنل لینوکس نامگذاری ثابت این رابط‌ها را تضمین نمی‌کند، اما کاربرانی که قصد پیکربندی این رابط‌ها در فایل <filename>/etc/network/interfaces</filename> را دارند به یک نام ثابت احتیاج دارند!"

#~ msgid "It would be difficult to ask every user to create their own <emphasis>udev</emphasis> rules to address this problem. This is why <emphasis>udev</emphasis> was configured in a rather peculiar manner; on first boot (and, more generally, each time that a new network card appears) it uses the name of the network interface and its MAC address to create new rules that will reassign the same name on subsequent boots. These rules are stored in <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>."
#~ msgstr "اینکه از کاربران بخواهیم قواعد <emphasis>udev</emphasis> مخصوص به خود را ایجاد کنند کار بسیار دشواری است. به همین دلیل است که <emphasis>udev</emphasis> به شیوه‌ای ویژه پیکربندی شده است؛ در اولین راه‌اندازی (به صورت عمومی‌تر، هر زمان که کارت شبکه پدیدار شود) از نام رابط شبکه و نشانی MAC آن استفاده کرده تا یک نام عمومی ثابت برای آن رابط بسازد. این قواعد در <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> ذخیره می‌شوند."

#~ msgid "This mechanism has some side effects that you should know about. Let's consider the case of a computer that has only one PCI network card. The network interface is named <literal>eth0</literal>, logically. Now say the card breaks down, and the administrator replaces it; the new card will have a new MAC address. Since the old card was assigned the name, <literal>eth0</literal>, the new one will be assigned <literal>eth1</literal>, even though the <literal>eth0</literal> card is gone for good (and the network will not be functional because <filename>/etc/network/interfaces</filename> likely configures an <literal>eth0</literal> interface). In this case, it is enough to simply delete the <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> file before rebooting the computer. The new card will then be given the expected <literal>eth0</literal> name."
#~ msgstr "این مکانیزم برخی عوارض جانبی دارد که بهتر است از آن‌ها با خبر باشید. رایانه‌ای را در نظر بگیرید که تنها یک کارت شبکه PCI دارد. رابط شبکه، به صورت منطقی، نام <literal>eth0</literal> را دارد. فرض کنید کارت شبکه خراب شده است و مدیرسیستم آن را جایگزین می‌کند؛ کارت جدید دارای نشانی MAC جدیدی است. از آنجا که کارت قدیمی نام <literal>eth0</literal> را داشت کارت جدید نام <literal>eth1</literal> را می‌گیرد، با اینکه کارت <literal>eth0</literal> به صورت کلی جایگزین شده است (و شبکه فعال نخواهد بود چرا که <filename>/etc/network/interfaces</filename> رابط <literal>eth0</literal> را پیکربندی کرده است). در این مورد، تنها کافی است فایل <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> را قبل از راه‌اندازی مجدد رایانه پاک کنید. کارت جدید نام مورد نظر <literal>eth0</literal> را خواهد گرفت."
