# AUTHOR <EMAIL@ADDRESS>, YEAR.
msgid ""
msgstr "Project-Id-Version: 0\nPOT-Creation-Date: 2020-07-22 15:37+0200\nPO-Revision-Date: 2021-03-15 15:03+0000\nLast-Translator: xiao sheng wen(肖盛文) <atzlinux@sina.com>\nLanguage-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/debian-handbook/15_debian-packaging/zh_Hans/>\nLanguage: zh-CN\nMIME-Version: 1.0\nContent-Type: application/x-publican; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nPlural-Forms: nplurals=1; plural=0;\nX-Generator: Weblate 4.5.2-dev\n"

msgid "Backport"
msgstr "向后移植"

msgid "Rebuild"
msgstr "重新构建"

msgid "Source package"
msgstr "源码包"

msgid "Archive"
msgstr "存档"

msgid "Meta-package"
msgstr "元包"

msgid "Debian Developer"
msgstr "Debian 开发者"

msgid "Maintainer"
msgstr "维护者"

msgid "Creating a Debian Package"
msgstr "创建 Debian 软件包"

msgid "It is quite common, for an administrator who has been handling Debian packages in a regular fashion, to eventually feel the need to create their own packages, or to modify an existing package. This chapter aims to answer the most common questions in this field, and provide the required elements to take advantage of the Debian infrastructure in the best way. With any luck, after trying your hand for local packages, you may even feel the need to go further than that and join the Debian project itself!"
msgstr "对于以常规方式处理Debian软件包的管理员来说，最终觉得需要创建自己的软件包或修改现有软件包是很常见的。本章旨在回答本领域最常见的问题，并提供必要的元素以最好的方式利用 Debian 基础设施。在尝试自己的本地包后，您甚至会觉得需要去更进一步并加入 Debian 项目！"

msgid "Rebuilding a Package from its Sources"
msgstr "从源码重新构建安装包"

msgid "Rebuilding a binary package is required under several sets of circumstances. In some cases, the administrator needs a software feature that requires the software to be compiled from sources, with a particular compilation option; in others, the software as packaged in the installed version of Debian is not recent enough. In the latter case, the administrator will usually build a more recent package taken from a newer version of Debian — such as <emphasis role=\"distribution\">Testing</emphasis> or even <emphasis role=\"distribution\">Unstable</emphasis> — so that this new package works in their <emphasis role=\"distribution\">Stable</emphasis> distribution; this operation is called “backporting”. As usual, care should be taken, before undertaking such a task, to check whether it has been done already — a quick look on the Debian Package Tracker for that package will reveal that information. <ulink type=\"block\" url=\"https://tracker.debian.org/\" /> <indexterm><primary>backport</primary></indexterm>"
msgstr "在几种情况下需要重新构建二进制包。在某些情况下，管理员需要一个软件功能，需要软件使用特定的编译选项从源码来编译；还有一些其它情况，在已安装的 Debian 版本上打包的软件版本不够新。在后一种情况下，管理员通常将从较新版本的 Debian 构建更新的软件包——如 <emphasis role=\"distribution\">Testing</emphasis>（测试版）或者 <emphasis role=\"distribution\">Unstable</emphasis>（不稳定版）——这样新的软件包可以工作在 <emphasis role=\"distribution\">Stable</emphasis>（稳定版）上；这种操作被称之为“backporting”（向后移植）。像通常一样，应该小心谨慎，在执行这样的任务之前要检查是否有人已经做过了—— 在 Debian Package Tracker （Debian 软件包跟踪网页）上快速查看会显示该信息。 <ulink type=\"block\" url=\"https://tracker.debian.org/\" /> <indexterm><primary>backport</primary></indexterm>"

msgid "Getting the Sources"
msgstr "获取源代码"

msgid "Rebuilding a Debian package starts with getting its source code. The easiest way is to use the <command>apt-get source <replaceable>source-package-name</replaceable></command> command. This command requires a <literal>deb-src</literal> line in the <filename>/etc/apt/sources.list</filename> file, and up-to-date index files (i.e. <command>apt-get update</command>). These conditions should already be met if you followed the instructions from the chapter dealing with APT configuration (see <xref linkend=\"sect.apt-sources.list\" />). Note, however, that you will be downloading the source packages from the Debian version mentioned in the <literal>deb-src</literal> line. If you need another version, you may need to download it manually from a Debian mirror or from the web site. This involves fetching two or three files (with extensions <filename>*.dsc</filename> — for <emphasis>Debian Source Control</emphasis> — <filename>*.tar.<replaceable>comp</replaceable></filename>, and sometimes <filename>*.diff.gz</filename> or <filename>*.debian.tar.<replaceable>comp</replaceable></filename> — <replaceable>comp</replaceable> taking one value among <literal>gz</literal>, <literal>bz2</literal> or <literal>xz</literal> depending on the compression tool in use), then run the <command>dpkg-source -x <replaceable>file.dsc</replaceable></command> command. If the <filename>*.dsc</filename> file is directly accessible at a given URL, there is an even simpler way to fetch it all, with the <command>dget <replaceable>URL</replaceable></command> command. This command (which can be found in the <emphasis role=\"pkg\">devscripts</emphasis> package) fetches the <filename>*.dsc</filename> file at the given address, then analyzes its contents, and automatically fetches the file or files referenced within. Once everything has been downloaded, it verifies the integrity of the downloaded source packages using <command>dscverify</command>, and it extracts the source package (unless the <literal>-d</literal> or <literal>--download-only</literal> option is used). The Debian keyring is needed, unless the option <literal>-u</literal> is supplied."
msgstr "重新构建 Debian 软件包的第一步是获得相关软件的源码。最简单的方式是使用命令 <command>apt-get source <replaceable>source-package-name</replaceable></command>。 这个命令需要 <filename>/etc/apt/sources.list</filename> 文件中存在<literal>deb-src</literal> 行， 并更新索引文件到最新（也就是通过 <command>apt-get update</command> 命令）。如果已经如何按照处理 APT 配置的章节中的指示，那么这些条件应该已经满足了（请参见 <xref linkend=\"sect.apt-sources.list\" />）。 然而注意，将会下载 <literal>deb-src</literal> 行中提到的 Deaian 版本的源码包。如果需要其它版本，需要从 Debian 的镜像或从网站上手动下载。这包括取回两到三个文件（带有 <filename>*.dsc</filename> 后缀——用于 <emphasis>Debian Source Control（Debian 源码控制）</emphasis>——<filename>*.tar.<replaceable>comp</replaceable></filename>，并且有时是 <filename>*.diff.gz</filename> 或 <filename>*.debian.tar.<replaceable>comp</replaceable></filename>——<replaceable>comp</replaceable> 根据所使用的压缩工具在 <literal>gz</literal>、<literal>bz2</literal> 或 <literal>xz</literal> 中取一个值），然后运行命令 <command>dpkg-source -x <replaceable>file.dsc</replaceable></command>。如果文件 <filename>*.dsc</filename>可以在给定的 URL 上直接访问，那么有一个甚至更简便的方法，通过使用命令<command>dget <replaceable>URL</replaceable></command>，来一次获取所有文件。这个命令（位于 <emphasis role=\"pkg\">devscripts</emphasis> 软件包中）在给定的网址取回 <filename>*.dsc</filename> 文件，然后分析文件内容，并自动取回其中参考的一个或者多个文件。一旦所有文件都被下载回来，它就会使用 <command>dscverify</command> 来检查所下载文件的完整性，并提取源码包（除非使用了 <literal>-d</literal> 或者 <literal>--download-only</literal> 选项）。除非提供了 <literal>-u</literal> 选项，否则需要 Debian keyring（钥匙环）。"

msgid "Making Changes"
msgstr "修改源码"

msgid "Let us use the <emphasis role=\"pkg\">samba</emphasis> package as an example."
msgstr "让我们使用 <emphasis role=\"pkg\">samba</emphasis> 软件包作为示例。"

msgid ""
"<computeroutput>$ </computeroutput><userinput>apt source samba\n"
"</userinput><computeroutput>Reading package lists... Done\n"
"NOTICE: 'samba' packaging is maintained in the 'Git' version control system at:\n"
"https://salsa.debian.org/samba-team/samba.git\n"
"Please use:\n"
"git clone https://salsa.debian.org/samba-team/samba.git\n"
"to retrieve the latest (possibly unreleased) updates to the package.\n"
"Need to get 11.7 MB of source archives.\n"
"Get:1 http://security.debian.org/debian-security buster/updates/main samba 2:4.9.5+dfsg-5+deb10u1 (dsc) [4,316 B]\n"
"Get:2 http://security.debian.org/debian-security buster/updates/main samba 2:4.9.5+dfsg-5+deb10u1 (tar) [11.4 MB]\n"
"Get:3 http://security.debian.org/debian-security buster/updates/main samba 2:4.9.5+dfsg-5+deb10u1 (diff) [252 kB]\n"
"Fetched 11.7 MB in 1s (9,505 kB/s)\n"
"dpkg-source: info: extracting samba in samba-4.9.5+dfsg\n"
"dpkg-source: info: unpacking samba_4.9.5+dfsg.orig.tar.xz\n"
"dpkg-source: info: unpacking samba_4.9.5+dfsg-5+deb10u1.debian.tar.xz\n"
"dpkg-source: info: using patch list from debian/patches/series\n"
"dpkg-source: info: applying 07_private_lib\n"
"dpkg-source: info: applying bug_221618_precise-64bit-prototype.patch\n"
"[...]\n"
"</computeroutput>"
msgstr "<computeroutput>$ </computeroutput><userinput>apt source samba\n</userinput><computeroutput>Reading package lists... Done\nNOTICE: 'samba' packaging is maintained in the 'Git' version control system at:\nhttps://salsa.debian.org/samba-team/samba.git\nPlease use:\ngit clone https://salsa.debian.org/samba-team/samba.git\nto retrieve the latest (possibly unreleased) updates to the package.\nNeed to get 11.7 MB of source archives.\nGet:1 http://security.debian.org/debian-security buster/updates/main samba 2:4.9.5+dfsg-5+deb10u1 (dsc) [4,316 B]\nGet:2 http://security.debian.org/debian-security buster/updates/main samba 2:4.9.5+dfsg-5+deb10u1 (tar) [11.4 MB]\nGet:3 http://security.debian.org/debian-security buster/updates/main samba 2:4.9.5+dfsg-5+deb10u1 (diff) [252 kB]\nFetched 11.7 MB in 1s (9,505 kB/s)\ndpkg-source: info: extracting samba in samba-4.9.5+dfsg\ndpkg-source: info: unpacking samba_4.9.5+dfsg.orig.tar.xz\ndpkg-source: info: unpacking samba_4.9.5+dfsg-5+deb10u1.debian.tar.xz\ndpkg-source: info: using patch list from debian/patches/series\ndpkg-source: info: applying 07_private_lib\ndpkg-source: info: applying bug_221618_precise-64bit-prototype.patch\n[...]\n</computeroutput>"

msgid "The source of the package is now available in a directory named after the source package and its version (<emphasis>samba-4.9.5+dfsg</emphasis>); this is where we'll work on our local changes."
msgstr "现在，软件包的源码放在以源码包加上版本号命名的目录中（<emphasis>samba-4.9.5+dfsg</emphasis>）；这是我们将处理本地更改的地方。"

msgid "The first thing to do is to change the package version number, so that the rebuilt packages can be distinguished from the original packages provided by Debian. Assuming the current version is <literal>2:4.9.5+dfsg-5</literal>, we can create version <literal>2:4.9.5+dfsg-5falcot1</literal>, which clearly indicates the origin of the package. This makes the package version number higher than the one provided by Debian, so that the package will easily install as an update to the original package. Such a change is best effected with the <command>dch</command> command (<emphasis>Debian CHangelog</emphasis>) from the <emphasis role=\"pkg\">devscripts</emphasis> package."
msgstr "要做的第一件事是更改软件包的版本号，从而可以从 Debian 原来提供的软件包中区分重构建的软件包。假设当前的版本是 <literal>2:4.9.5+dfsg-5</literal>，那么我们可以创建版本 <literal>2:4.9.5+dfsg-5falcot1</literal>，它可以清晰地指示软件包的来源。这使软件包的版本比 Debian 提供的更高，从而软件包可以容易地作为原来的软件包的更新来安装。这样的更改最好通过来自 <emphasis role=\"pkg\">devscripts</emphasis> 的 <command>dch</command> 命令（<emphasis>Debian CHangelog</emphasis>）来生效。"

msgid ""
"<computeroutput>$ </computeroutput><userinput>cd samba-4.9.5+dfsg\n"
"</userinput><computeroutput>$ </computeroutput><userinput>dch --local falcot</userinput>"
msgstr "<computeroutput>$ </computeroutput><userinput>cd samba-4.9.5+dfsg\n</userinput><computeroutput>$ </computeroutput><userinput>dch --local falcot</userinput>"

msgid "The last command invokes a text editor (<command>sensible-editor</command> — this should be your favorite editor if it is mentioned in the <varname>VISUAL</varname> or <varname>EDITOR</varname> environment variables, and the default editor otherwise) to allow documenting the differences brought by this rebuild. This editor shows us that <command>dch</command> really did change the <filename>debian/changelog</filename> file."
msgstr "最后一个命令调用文本编辑器（<command>sensible-editor</command>——如果在 <varname>VISUAL</varname> 或 <varname>EDITOR</varname> 环境变量中提到的话，它应该是您首选的编辑器，此外也是默认编辑器），允许将这个重新构建导致的差异归档。这个编辑器向我们显示 <command>dch</command> 确实真正地更改了 <filename>debian/changelog</filename> 文件。"

msgid "When a change in build options is required, the changes need to be made in <filename>debian/rules</filename>, which drives the steps in the package build process. In the simplest cases, the lines concerning the initial configuration (<literal>./configure …</literal>) or the actual build (<literal>$(MAKE) …</literal> or <literal>make …</literal>) are easy to spot. If these commands are not explicitly called, they are probably a side effect of another explicit command, in which case please refer to their documentation to learn more about how to change the default behavior. With packages using <command>dh</command>, you might need to add an override for the <command>dh_auto_configure</command> or <command>dh_auto_build</command> commands (see their respective manual pages for explanations on how to achieve this)."
msgstr "当要求构建选项中的更改时，更改需要在 <filename>debian/rules</filename> 中做出，这驱动了软件包构建过程中的步骤。在最简单的情况下，容易发现与初始配置（<literal>./configure …</literal>）或实际构建（<literal>$(MAKE) …</literal> 或 <literal>make …</literal>）相关的行。如果这些命令不被显性调用，那么它们可能是其它显性命令的副作用，在这种情况下请参考它们的文档来进一步了解如何更改默认行为。对于使用 <command>dh</command> 的软件包，会需要将对 <command>dh_auto_configure</command> 或 <command>dh_auto_build</command> 命令添加覆盖（关于如何实现的解释，请参见它们各自的手册页面）。"

msgid "Depending on the local changes to the packages, an update may also be required in the <filename>debian/control</filename> file, which contains a description of the generated packages. In particular, this file contains <literal>Build-Depends</literal> lines controlling the list of dependencies that must be fulfilled at package build time. These often refer to versions of packages contained in the distribution the source package comes from, but which may not be available in the distribution used for the rebuild. There is no automated way to determine if a dependency is real or only specified to guarantee that the build should only be attempted with the latest version of a library — this is the only available way to force an <emphasis>autobuilder</emphasis> to use a given package version during build, which is why Debian maintainers frequently use strictly versioned build-dependencies."
msgstr "依赖于对软件包的本地更改，在 <filename>debian/control</filename> 文件中也会需要更新，这个文件包含了对生成的软件包的描述。特别是，这个文件包含了 <literal>Build-Depends</literal> 行来控制依赖的列表，依赖列表必须在软件包构建时填入。这些经常参考源码包所来自的发布版本中包含的软件包版本，但在用于重新构建的发布版本中会不可用。没有自动的方式来确定依赖是真实的，还是特定的从而保证只通过最新版的库来尝试构建——这是在构建中强制 <emphasis>autobuilder</emphasis> 使用给定的软件包版本的唯一可用方式，这就是为什么 Debian 的维护者频繁地使用严格版本控制的构建依赖的原因。"

msgid "If you know for sure that these build-dependencies are too strict, you should feel free to relax them locally. Reading the files which document the standard way of building the software — these files are often called <filename>INSTALL</filename> — will help you figure out the appropriate dependencies. Ideally, all dependencies should be satisfiable from the distribution used for the rebuild; if they are not, a recursive process starts, whereby the packages mentioned in the <literal>Build-Depends</literal> field must be backported before the target package can be. Some packages may not need backporting, and can be installed as-is during the build process (a notable example is <emphasis role=\"pkg\">debhelper</emphasis>). Note that the backporting process can quickly become complex if you are not careful. Therefore, backports should be kept to a strict minimum when possible."
msgstr "如果确定知道这些构建依赖太过严格，那么自己应该大胆地在本地将其放松。阅读将构建软件归档的文件——这些文件通常被称为 <filename>INSTALL</filename>——这将有助于找到适当的依赖。理想上，所有依赖都应该是重新构建所使用的发布版本能满足的；如果不能满足，那么会开始循环过程，其中 <literal>Build-Depends</literal> 字段提到的软件包在可以成为目标软件包之前必须被逆向移植。一些软件包会不需要逆向移植，而可以在构建过程中原样安装（一个值得注意的例子是 <emphasis role=\"pkg\">debhelper</emphasis>）。注意，如果不小心的话，逆向移植过程会很快变得复杂。这样，逆向移植应该尽可能保持严格最小化。"

msgid "<emphasis>TIP</emphasis> Installing <literal>Build-Depends</literal>"
msgstr "<emphasis>技巧</emphasis> 安装<literal>构建依赖</literal>"

msgid "<primary><literal>Build-Depends</literal>, control field</primary>"
msgstr "<primary><literal>构建依赖</literal>，控制字段</primary>"

msgid "<command>apt-get</command> allows installing all packages mentioned in the <literal>Build-Depends</literal> fields of a source package available in a distribution mentioned in a <literal>deb-src</literal> line of the <filename>/etc/apt/sources.list</filename> file. This is a simple matter of running the <command>apt-get build-dep <replaceable>source-package</replaceable></command> command."
msgstr "在 <filename>/etc/apt/sources.list</filename> 文件的 <literal>deb-src</literal> 行中提到的发布版本中获得源码包，<command>apt-get</command> 允许安装源码包的 <literal>Build-Depends</literal> 字段上提到的所有软件包。这不不过是运行 <command>apt-get build-dep <replaceable>source-package</replaceable></command> 命令的简单事情。"

msgid "Starting the Rebuild"
msgstr "开始重新构建"

msgid "When all the needed changes have been applied to the sources, we can start generating the actual binary package (<filename>.deb</filename> file). The whole process is managed by the <command>dpkg-buildpackage</command> command."
msgstr "当所有需要的更改都应用到源代码后，我们就可以开始生成实际的二进制包了（<filename>.deb</filename>）。整个过程由 <command>dpkg-buildpackage</command> 命令来管理。"

msgid "Rebuilding a package"
msgstr "重新构建软件包"

msgid ""
"<computeroutput>$ </computeroutput><userinput>dpkg-buildpackage -us -uc\n"
"</userinput><computeroutput>[...]\n"
"</computeroutput>"
msgstr ""
"<computeroutput>$ </computeroutput><userinput>dpkg-buildpackage -us -uc\n"
"</userinput><computeroutput>[…]\n"
"</computeroutput>"

msgid "The previous command can fail if the <literal>Build-Depends</literal> fields have not been updated, or if the related packages are not installed. In such a case, it is possible to overrule this check by passing the <literal>-d</literal> option to <command>dpkg-buildpackage</command>. However, explicitly ignoring these dependencies runs the risk of the build process failing at a later stage. Worse, the package may seem to build correctly but fail to run properly: some programs automatically disable some of their features when a required library is not available at build time."
msgstr "如果 <literal>Build-Depends</literal> 字段没有更新，或者如果没有安装相关的软件包的话，那么前面的命令可能会失败。在这种情况下，能够通过将 <literal>-d</literal> 选项传递给 <command>dpkg-buildpackage</command> 来否定这项检查。然而，显性地忽略这些依赖在后面的阶段会有构建失败的风险。更糟的是，软件包可能看来是正确地构建了，但正常运行失败：当所需的库在构建时不可用的情况下，一些程序会自动禁止自己的一些特性。"

msgid "<emphasis>TOOL</emphasis> <command>fakeroot</command>"
msgstr "<emphasis>工具</emphasis><command>fakeroot</command>"

msgid "In essence, the package creation process is a simple matter of gathering in an archive a set of existing (or built) files; most of the files will end up being owned by <emphasis>root</emphasis> in the archive. However, building the whole package under this user would imply increased risks; fortunately, this can be avoided with the <command>fakeroot</command> command. This tool can be used to run a program and give it the impression that it runs as <emphasis>root</emphasis> and creates files with arbitrary ownership and permissions. When the program creates the archive that will become the Debian package, it is tricked into creating an archive containing files marked as belonging to arbitrary owners, including <emphasis>root</emphasis>. This setup is so convenient that <command>dpkg-buildpackage</command> uses <command>fakeroot</command> by default when building packages."
msgstr "本质上，软件包的创建过程是将一组现有（或构建）的文件汇集在一个档案中的简单事情；其中的多数文件将在档案中最终由<emphasis>root</emphasis> 所有。然而，在这个用户下构建整个软件包将暗含着增加的风险；幸运的是，这可以通过 <command>fakeroot</command> 命令来避免。这个工具可以用于运行程序，并给它作为 <emphasis>root</emphasis> 运行并以任意的所有者和权限来创建文件的印象。当程序创建将变为 Debian 软件包的档案时，它欺骗来创建档案，档案包含了标记为属于任意用户的文件，这些用户也包括<emphasis>root</emphasis> 。这个设置非常方便，以至 <command>dpkg-buildpackage</command> 构建软件包时默认使用 <command>fakeroot</command>。"

msgid "Note that the program is only tricked into “believing” that it operates as a privileged account, and the process actually runs as the user running <command>fakeroot <replaceable>program</replaceable></command> (and the files are actually created with that user's permissions). At no time does it actually get root privileges that it could abuse."
msgstr "注意，程序只是被欺骗“相信”它作为有特权的账户来操作，并且作为运行 <command>fakeroot <replaceable>program</replaceable></command>的用户来真正运行进程（而文件以用户的权限真实创建）。它从来也不会真正获得可能被滥用的根特权。"

msgid "More often than not, Debian developers use a higher-level program such as <command>debuild</command>; this runs <command>dpkg-buildpackage</command> as usual, but it also adds an invocation of a program that runs many checks to validate the generated package against the Debian policy. This script also cleans up the environment so that local environment variables do not “pollute” the package build. The <command>debuild</command> command is one of the tools in the <emphasis>devscripts</emphasis> suite, which share some consistency and configuration to make the maintainers' task easier."
msgstr "更多时候，Debian 的开发者使用更高等级的程序，如 <command>debuild</command>；这像通常一样运行 <command>dpkg-buildpackage</command>，但还添加程序的调用，调用的程序运行很多检查，针对 Debian 的政策来验证生成的软件包。这个脚本还清理了环境，从而本地环境变量不会“污染”软件包构建。<command>debuild</command> 命令是 <emphasis>devscripts</emphasis> 套件中的工具之一，这个套件共享一些一致性和配置，而使维护者的任务更容易。"

msgid "<emphasis>QUICK LOOK</emphasis> Building packages in a <emphasis>chrooted</emphasis> environment"
msgstr "<emphasis>速览</emphasis>在 <emphasis>chrooted</emphasis> 环境中构建软件包"

msgid "<primary><command>pbuilder</command></primary>"
msgstr "<primary><command>pbuilder</command></primary>"

msgid "<primary><command>schroot</command></primary>"
msgstr "<primary><command>schroot</command></primary>"

msgid "The <command>pbuilder</command> program (in the similarly named package) allows building a Debian package in a <emphasis>chrooted</emphasis> environment. It first creates a temporary directory containing the minimal system required for building the package (including the packages mentioned in the <emphasis>Build-Depends</emphasis> field). This directory is then used as the root directory (<filename>/</filename>), using the <command>chroot</command> command, during the build process."
msgstr "<command>pbuilder</command> 程序（在相似命名的包中）允许在 <emphasis>chrooted</emphasis> 环境中构建 Debian 软件包。它首先创建临时目录，里面包含了创建软件包（包括 <emphasis>Build-Depends</emphasis> 字段提到的软件包）所需的最小系统。然后在构建过程中使用 <command>chroot</command> 命令，将这个目录用作根目录（<filename>/</filename>）。"

msgid "This tool allows the build process to happen in an environment that is not altered by users' manipulations. This also allows for quick detection of the missing build-dependencies (since the build will fail unless the appropriate dependencies are documented). Finally, it allows building a package for a Debian version that is not the one used by the system as a whole: the machine can be using <emphasis role=\"distribution\">Stable</emphasis> for its normal workload, and a <command>pbuilder</command> running on the same machine can be using <emphasis role=\"distribution\">Unstable</emphasis> for package builds."
msgstr "这个工具允许构建过程在不被用户操作所改变的环境中发生。这还允许迅速检查丢失的构建依赖（因为除非将适当的依赖归档，否则构建会失败）。最后，它允许对于并非由系统作为整体使用的 Debian 版本来构建软件包：机器可以在正常工作负荷下使用 <emphasis role=\"distribution\">稳定版</emphasis>，在同一台机器上运行 <command>pbuilder</command> 可以使用 <emphasis role=\"distribution\">不稳定版</emphasis> 来构建软件包。"

msgid "<command>schroot</command> allows running a command or a login shell in a <emphasis>chrooted</emphasis> environment."
msgstr "<command>schroot</command> 允许运行命令，或在 <emphasis>chrooted</emphasis> 环境中登录 shell。"

msgid "Building your First Package"
msgstr "构建您的第一个软件包"

msgid "Meta-Packages or Fake Packages"
msgstr "元软件包或伪装软件包"

msgid "Fake packages and meta-packages are similar, in that they are empty shells that only exist for the effects their meta-data have on the package handling stack."
msgstr "伪装软件包和元包是相似的，相似点在于它们是空壳，它们只通过其软件包处理栈上的元数据来影响软件包。"

msgid "The purpose of a fake package is to trick <command>dpkg</command> and <command>apt</command> into believing that some package is installed even though it is only an empty shell. This allows satisfying dependencies on a package when the corresponding software was installed outside the scope of the packaging system. Such a method works, but it should still be avoided whenever possible, since there is no guarantee that the manually installed software behaves exactly like the corresponding package would and other packages depending on it would not work properly."
msgstr "假软件包的目的是欺骗 <command>dpkg</command> 和 <command>apt</command>，让它们相信一些软件包已经安装，即使只是个空壳。这允许当对应的软件安装在打包系统的范围之外时满足对软件包的依赖。这样的方法有效，但仍应该尽可能地避免，因为不能保证手动安装的软件包完全像对应的软件包那样工作，并且依赖它的其它软件包会不能正常地工作。"

msgid "On the other hand, a meta-package exists mostly as a collection of dependencies, so that installing the meta-package will actually bring in a set of other packages in a single step."
msgstr "另一方面，元包主要作为一组依赖而存在，从而安装元包将真正一步带进一组其它软件包。"

msgid "Both these kinds of packages can be created by the <command>equivs-control</command> and <command>equivs-build</command> commands (in the <emphasis role=\"pkg\">equivs</emphasis> package). The <command>equivs-control <replaceable>file</replaceable></command> command creates a Debian package header file that should be edited to contain the name of the expected package, its version number, the name of the maintainer, its dependencies, and its description. Other fields without a default value are optional and can be deleted. The <literal>Copyright</literal>, <literal>Changelog</literal>, <literal>Readme</literal> and <literal>Extra-Files</literal> fields are not standard fields in Debian packages; they only make sense within the scope of <command>equivs-build</command>, and they will not be kept in the headers of the generated package."
msgstr "这两种软件包都可以通过 <command>equivs-control</command> 和 <command>equivs-build</command> 命令（在软件包 <emphasis role=\"pkg\">equivs</emphasis> 中）来创建。<command>equivs-control <replaceable>file</replaceable></command> 命令创建了 Debian 软件包头文件，应该编辑它来包含所需要的软件包的名称、其版本号、维护者姓名、其依赖及其描述。没有默认值的其它字段是可选的，并且可以被删除。<literal>Copyright（版权）</literal>、<literal>Changelog（更改日志）</literal>、<literal>Readme（自述文件）</literal> 和 <literal>Extra-Files（补充的文件）</literal> 字段在 Debian 软件包中不是标准字段；它们只在 <command>equivs-build</command> 的范围内是有意义，并且它们不会被保留在生成的软件包的标头中。"

msgid "Header file of the <emphasis>libxml-libxml-perl</emphasis> fake package"
msgstr "<emphasis>libxml-libxml-perl</emphasis> 伪装软件包的头文件"

msgid ""
"\n"
"Section: perl\n"
"Priority: optional\n"
"Standards-Version: 4.4.1\n"
"\n"
"Package: libxml-libxml-perl\n"
"Version: 2.0134-1\n"
"Maintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;\n"
"Depends: libxml2 (&gt;= 2.7.4)\n"
"Architecture: all\n"
"Description: Fake package - module manually installed in site_perl\n"
" This is a fake package to let the packaging system\n"
" believe that this Debian package is installed.\n"
" .\n"
" In fact, the package is not installed since a newer version\n"
" of the module has been manually compiled &amp; installed in the\n"
" site_perl directory."
msgstr "\nSection: perl\nPriority: optional\nStandards-Version: 4.4.1\n\nPackage: libxml-libxml-perl\nVersion: 2.0134-1\nMaintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;\nDepends: libxml2 (&gt;= 2.7.4)\nArchitecture: all\nDescription: Fake package - module manually installed in site_perl\n This is a fake package to let the packaging system\n believe that this Debian package is installed.\n .\n In fact, the package is not installed since a newer version\n of the module has been manually compiled &amp; installed in the\n site_perl directory."

msgid "The next step is to generate the Debian package with the <command>equivs-build <replaceable>file</replaceable></command> command. Voilà: the package is created in the current directory and it can be handled like any other Debian package would."
msgstr "下一步是用 <command>equivs-build <replaceable>file</replaceable></command> 命令生成 Debian 软件包。看：软件包创建在当前目录中，并且可以像任何其它 Debian 软件包那样处理它。"

msgid "Simple File Archive"
msgstr "简单文件档案"

msgid "The Falcot Corp administrators need to create a Debian package in order to ease deployment of a set of documents on a large number of machines. The administrator in charge of this task first reads the “New Maintainer's Guide”, then starts working on their first package. <ulink type=\"block\" url=\"https://www.debian.org/doc/manuals/maint-guide/\" />"
msgstr "Falcot 公司的管理员需要创建 Debian 软件包，从而容易在大量机器上布设一组文档。负责这项任务的管理员首先阅读“New Maintainer's Guide”（新维护者指南），然后开始处理他们的第一个软件包。<ulink type=\"block\" url=\"https://www.debian.org/doc/manuals/maint-guide/\" />"

msgid "The first step is creating a <filename>falcot-data-1.0</filename> directory to contain the target source package. The package will logically, be named <literal>falcot-data</literal> and bear the <literal>1.0</literal> version number. The administrator then places the document files in a <filename>data</filename> subdirectory. Then they invoke the <command>dh_make</command> command (from the <emphasis role=\"pkg\">dh-make</emphasis> package) to add files required by the package generation process, which will all be stored in a <filename>debian</filename> subdirectory:"
msgstr "第一步是创建 <filename>falcot-data-1.0</filename> 目录来包含目标源码包。软件包在本地命名为 <literal>falcot-data</literal> 并带有版本号 <literal>1.0</literal>。然后管理员将文档放置在 <filename>data</filename> 子目录中。然后调用 <command>dh_make</command> 命令（来自 <emphasis role=\"pkg\">dh-make</emphasis> 软件包），来添加软件包生成过程所需的文件，它们将被存储在 <filename>debian</filename> 子目录中："

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cd falcot-data-1.0</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>dh_make --native</userinput>\n"
"<computeroutput>\n"
"Type of package: (single, indep, library, python)\n"
"[s/i/l/p]? </computeroutput><userinput>i</userinput>\n"
"<computeroutput>\n"
"Maintainer Name     : Raphael Hertzog\n"
"Email-Address       : hertzog@debian.org\n"
"Date                : Fri, 04 Sep 2015 12:09:39 -0400\n"
"Package Name        : falcot-data\n"
"Version             : 1.0\n"
"License             : gpl3\n"
"Package Type        : indep\n"
"Are the details correct? [Y/n/q]\n"
"Currently there is not top level Makefile. This may require additional tuning\n"
"Done. Please edit the files in the debian/ subdirectory now.\n"
"\n"
"$</computeroutput>"
msgstr "\n<computeroutput>$ </computeroutput><userinput>cd falcot-data-1.0</userinput>\n<computeroutput>$ </computeroutput><userinput>dh_make --native</userinput>\n<computeroutput>\nType of package: (single, indep, library, python)\n[s/i/l/p]? </computeroutput><userinput>i</userinput>\n<computeroutput>\nMaintainer Name     : Raphael Hertzog\nEmail-Address       : hertzog@debian.org\nDate                : Fri, 04 Sep 2015 12:09:39 -0400\nPackage Name        : falcot-data\nVersion             : 1.0\nLicense             : gpl3\nPackage Type        : indep\nAre the details correct? [Y/n/q]\nCurrently there is not top level Makefile. This may require additional tuning\nDone. Please edit the files in the debian/ subdirectory now.\n\n$</computeroutput>"

msgid "The selected type of package (<emphasis>indep</emphasis>) indicates that this source package will generate a single binary package that can be shared across all architectures (<literal>Architecture: all</literal>). <emphasis>single</emphasis> acts as a counterpart, and leads to a single binary package that is dependent on the target architecture (<literal>Architecture: any</literal>). In this case, the former choice is more relevant since the package only contains documents and no binary programs, so it can be used similarly on computers of all architectures."
msgstr "所选择的软件包类型（<emphasis>indep</emphasis>）指示了这个源码包将生成可以在所有架构（<literal>Architecture: all</literal>）上分享的单一二进制包。<emphasis>single</emphasis> 作为对应，产生依赖于目标架构（<literal>Architecture: any</literal>）的单一二进制包。在这种情况下，前者的选择更相关，因为软件包只包含文档而没有二进制程序，因此可以在所有架构的计算机上相似地使用。"

msgid "<primary>package types</primary>"
msgstr "<primary>软件包类型</primary>"

msgid "<primary>package</primary><secondary>types</secondary>"
msgstr "<primary>软件包</primary><secondary>类型</secondary>"

msgid "The <emphasis>library</emphasis> type corresponds to a source package leading to several binary packages. It is useful for shared libraries, since they need to follow strict packaging rules."
msgstr "<emphasis>library</emphasis> 的类型与产生几个二进制包的源码包对应。它对共享库有用，因为它们需要遵守严格的打包规则。"

msgid "<emphasis>TIP</emphasis> Maintainer's name and email address"
msgstr "<emphasis>技巧</emphasis> 维护者的名称与电子邮箱地址"

msgid "Most of the programs involved in package maintenance will look for your name and email address in the <varname>DEBFULLNAME</varname> and <varname>DEBEMAIL</varname> or <varname>EMAIL</varname> environment variables. Defining them once and for all will avoid you having to type them multiple times. If your usual shell is <command>bash</command>, it is a simple matter of adding the following two lines in your <filename>~/.bashrc</filename> file (you will obviously replace the values with more relevant ones!):"
msgstr "软件包的维护所包括的多数程序会在 <varname>DEBFULLNAME</varname> 与 <varname>DEBEMAIL</varname> 中或 <varname>EMAIL</varname> 环境变量中查找您的姓名和电子邮件地址。为所有定义它们一次将避免将其多次键入。如果您通常的 shell 是 <command>bash</command> 的话，那么这是在您的 <filename>~/.bashrc</filename> 文件中添加后面两行的简单事情（明显您会用更相关的值来替换！）："

msgid ""
"\n"
"export EMAIL=\"hertzog@debian.org\"\n"
"export DEBFULLNAME=\"Raphael Hertzog\""
msgstr "\nexport EMAIL=\"hertzog@debian.org\"\nexport DEBFULLNAME=\"Raphael Hertzog\""

msgid "The <command>dh_make</command> command created a <filename>debian</filename> subdirectory with many files. Some are required, in particular <filename>rules</filename>, <filename>control</filename>, <filename>changelog</filename> and <filename>copyright</filename>. Files with the <filename>.ex</filename> extension are example files that can be used by modifying them (and removing the extension) when appropriate. When they are not needed, removing them is recommended. The <filename>compat</filename> file should be kept, since it is required for the correct functioning of the <emphasis>debhelper</emphasis> suite of programs (all beginning with the <command>dh_</command> prefix) used at various stages of the package build process."
msgstr "<command>dh_make</command> 命令创建带有很多文件的 <filename>debian</filename> 子目录。一些是所需的，特别是 <filename>rules</filename>、<filename>control</filename>、<filename>changelog</filename> 和 <filename>copyright</filename>。带有 <filename>.ex</filename> 后缀的文件是可以在适当时间修改（并删除后缀）来使用的示例文件。当不需要它们时，推荐将其删除。<filename>compat</filename> 文件应该保留，因为它是使在软件包构建过程的各个阶段所使用的 <emphasis>debhelper</emphasis> 程序集（所有名称都是以 <command>dh_</command> 前缀来开始）正常运行所需要的。"

msgid "The <filename>copyright</filename> file must contain information about the authors of the documents included in the package, and the related license. In our case, these are internal documents and their use is restricted to within the Falcot Corp company. The default <filename>changelog</filename> file is generally appropriate; replacing the “Initial release” with a more verbose explanation and changing the distribution from <literal>unstable</literal> to <literal>internal</literal> is enough. The <filename>control</filename> file was also updated: the <literal>Section</literal> field has been changed to <emphasis>misc</emphasis> and the <literal>Homepage</literal>, <literal>Vcs-Git</literal> and <literal>Vcs-Browser</literal> fields were removed. The <literal>Depends</literal> fields was completed with <literal>firefox-esr | www-browser</literal> so as to ensure the availability of a web browser able to display the documents in the package."
msgstr "<filename>copyright</filename> 文件必须包含软件包中包括的文档作者的信息，以及相关的许可包括其中。在我们的情况下，这些是内部文档，并且其使用限制在 Falcot Corp 公司内部。默认的 <filename>changelog</filename> 文件通常是适当的；用更冗长的解释替换“Initial release”（初始发布），并将发布版本从 <literal>unstable</literal> 更改为 <literal>internal</literal> 就足够了。<filename>control</filename> 文件也被更新：<literal>Section</literal> 字段被更改为 <emphasis>misc</emphasis>，而 <literal>Homepage</literal>、<literal>Vcs-Git</literal> 和 <literal>Vcs-Browser</literal> 字段被删除。<literal>Depends</literal> 字段以 <literal>firefox-esr | www-browser</literal> 来填入完成，从而确保 web 浏览器能够显示软件包中的文档。"

msgid "The <filename>control</filename> file"
msgstr "<filename>control</filename> 文件"

msgid ""
"\n"
"Source: falcot-data\n"
"Section: misc\n"
"Priority: optional\n"
"Maintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;\n"
"Build-Depends: debhelper (&gt;= 10)\n"
"Standards-Version: 4.4.1\n"
"\n"
"Package: falcot-data\n"
"Architecture: all\n"
"Depends: firefox-esr | www-browser, ${misc:Depends}\n"
"Description: Internal Falcot Corp Documentation\n"
" This package provides several documents describing the internal\n"
" structure at Falcot Corp.  This includes:\n"
"  - organization diagram\n"
"  - contacts for each department.\n"
" .\n"
" These documents MUST NOT leave the company.\n"
" Their use is INTERNAL ONLY."
msgstr "\nSource: falcot-data\nSection: misc\nPriority: optional\nMaintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;\nBuild-Depends: debhelper (&gt;= 10)\nStandards-Version: 4.4.1\n\nPackage: falcot-data\nArchitecture: all\nDepends: firefox-esr | www-browser, ${misc:Depends}\nDescription: Internal Falcot Corp Documentation\n This package provides several documents describing the internal\n structure at Falcot Corp.  This includes:\n  - organization diagram\n  - contacts for each department.\n .\n These documents MUST NOT leave the company.\n Their use is INTERNAL ONLY."

msgid "The <filename>changelog</filename> file"
msgstr "<filename>changelog</filename> 文件"

msgid ""
"\n"
"falcot-data (1.0) internal; urgency=low\n"
"\n"
"  * Initial Release.\n"
"  * Let's start with few documents:\n"
"    - internal company structure;\n"
"    - contacts for each department.\n"
"\n"
" -- Raphael Hertzog &lt;hertzog@debian.org&gt;  Fri, 04 Sep 2015 12:09:39 -0400"
msgstr "\nfalcot-data (1.0) internal; urgency=low\n\n  * Initial Release.\n  * Let's start with few documents:\n    - internal company structure;\n    - contacts for each department.\n\n -- Raphael Hertzog &lt;hertzog@debian.org&gt;  Fri, 04 Sep 2015 12:09:39 -0400"

msgid "The <filename>copyright</filename> file"
msgstr "<filename>copyright</filename> 文件"

msgid ""
"\n"
"Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/\n"
"Upstream-Name: falcot-data\n"
"\n"
"Files: *\n"
"Copyright: 2004-2019 Falcot Corp\n"
"License:\n"
" All rights reserved."
msgstr "\nFormat: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/\nUpstream-Name: falcot-data\n\nFiles: *\nCopyright: 2004-2019 Falcot Corp\nLicense:\n All rights reserved."

msgid "<emphasis>BACK TO BASICS</emphasis> <filename>Makefile</filename> file"
msgstr "<emphasis>基本知识</emphasis> <filename>Makefile</filename>文件"

msgid "<primary><filename>Makefile</filename></primary>"
msgstr "<primary><filename>Makefile</filename></primary>"

msgid "A <filename>Makefile</filename> file is a script used by the <command>make</command> program; it describes rules for how to build a set of files from each other in a tree of dependencies (for instance, a program can be built from a set of source files). The <filename>Makefile</filename> file describes these rules in the following format:"
msgstr "<filename>Makefile</filename> 文件是 <command>make</command> 程序使用的脚本；它描述了如何构建一组彼此树形依赖的文件（例如，程序可以从一组源码文件构建）。<filename>Makefile</filename> 文件以后面的格式描述了这些规则："

msgid ""
"\n"
"target: source1 source2 ...\n"
"        command1\n"
"        command2"
msgstr "\ntarget: source1 source2 ...\n        command1\n        command2"

msgid "The interpretation of such a rule is as follows: if one of the <literal>source*</literal> files is more recent than the <literal>target</literal> file, then the target needs to be generated, using <command>command1</command> and <command>command2</command>."
msgstr "这样的规则翻译如下：如果 <literal>source*</literal> 文件之一比 <literal>target</literal> 文件更新，那么需要使用 <command>command1</command> 和 <command>command2</command>，来生成目标。"

msgid "Note that the command lines must start with a tab character; also note that when a command line starts with a dash character (<literal>-</literal>), failure of the command does not interrupt the whole process."
msgstr "注意，命令行必须以制表符开始；还要注意当命令行以短破折号（<literal>-</literal>）开始时，失败的命令不会中断整个过程。"

msgid "The <filename>rules</filename> file usually contains a set of rules used to configure, build and install the software in a dedicated subdirectory (named after the generated binary package). The contents of this subdirectory is then archived within the Debian package as if it were the root of the filesystem. In our case, files will be installed in the <filename>debian/falcot-data/usr/share/falcot-data/</filename> subdirectory, so that installing the generated package will deploy the files under <filename>/usr/share/falcot-data/</filename>. The <filename>rules</filename> file is used as a <filename>Makefile</filename>, with a few standard targets (including <literal>clean</literal> and <literal>binary</literal>, used respectively to clean the source directory and generate the binary package)."
msgstr "<filename>rules</filename> 文件通常包含一组用于在专用子目录（以生成的二级制软件包来命令）来配置、构建和安装软件的规则。然后这个子目录的内容在 Debian 软件包内存档，如同这个子目录是文件系统的根。在我们的情况下，文件将安装在 <filename>debian/falcot-data/usr/share/falcot-data/</filename> 子目录中，从而安装生成的软件包将在 <filename>/usr/share/falcot-data/</filename>下部署文件。<filename>rules</filename> 文件用作 <filename>Makefile</filename>，带有一些标准的目标（包括 <literal>clean</literal> 和 <literal>binary</literal>，分别用来清理源目录和生成的二进制软件包）。"

msgid "Although this file is the heart of the process, it increasingly contains only the bare minimum for running a standard set of commands provided by the <command>debhelper</command> tool. Such is the case for files generated by <command>dh_make</command>. To install our files, we simply configure the behavior of the <command>dh_install</command> command by creating the following <filename>debian/falcot-data.install</filename> file:"
msgstr "尽管这个文件是整个过程的中心，它仍然只逐渐包含了运行 <command>debhelper</command> 工具提供的标准组命令的最低限。这是由 <command>dh_make</command> 生成文件的情况。为了安装我们的文件，我们通过创建后面的 <filename>debian/falcot-data.install</filename> 文件，来简单地配置 <command>dh_install</command> 命令的行为："

msgid ""
"\n"
"data/* usr/share/falcot-data/"
msgstr "\ndata/* usr/share/falcot-data/"

msgid "At this point, the package can be created. We will, however, add a lick of paint. Since the administrators want the documents to be easily accessed from the menus of graphical desktop environments, we add a <filename>falcot-data.desktop</filename> file and get it installed in <filename>/usr/share/applications</filename> by adding a second line to <filename>debian/falcot-data.install</filename>."
msgstr "这时可以创建软件包。然而，我们将加点涂料。由于管理员想要文档从图形化桌面环境的菜单中容易地访问，我们添加了 <filename>falcot-data.desktop</filename> 文件，并通过在 <filename>debian/falcot-data.install</filename> 中添加第二行，而将它安装在 <filename>/usr/share/applications</filename> 中。"

msgid "The <filename>falcot-data.desktop</filename> file"
msgstr "<filename>falcot-data.desktop</filename>文件"

msgid ""
"\n"
"[Desktop Entry]\n"
"Name=Internal Falcot Corp Documentation\n"
"Comment=Starts a browser to read the documentation\n"
"Exec=x-www-browser /usr/share/falcot-data/index.html\n"
"Terminal=false\n"
"Type=Application\n"
"Categories=Documentation;"
msgstr "\n[Desktop Entry]\nName=Internal Falcot Corp Documentation\nComment=Starts a browser to read the documentation\nExec=x-www-browser /usr/share/falcot-data/index.html\nTerminal=false\nType=Application\nCategories=Documentation;"

msgid "The updated <filename>debian/falcot-data.install</filename> looks like this:"
msgstr "已更新的 <filename>debian/falcot-data.install</filename> 看起来像这样："

msgid ""
"\n"
"data/* usr/share/falcot-data/\n"
"falcot-data.desktop usr/share/applications/"
msgstr "\ndata/* usr/share/falcot-data/\nfalcot-data.desktop usr/share/applications/"

msgid "Our source package is now ready. All that is left to do is to generate the binary package, with the same method we used previously for rebuilding packages: we run the <command>dpkg-buildpackage -us -uc</command> command from within the <filename>falcot-data-1.0</filename> directory."
msgstr "我们的源码包现在已经准备好了。所有剩下要做的，是通过我们之前用来重新构建软件包的相同方法来生成二进制软件包：我们从 <filename>falcot-data-1.0</filename> 目录内运行 <command>dpkg-buildpackage -us -uc</command> 命令。"

msgid "Creating a Package Repository for APT"
msgstr "创建用于 APT 的软件包仓库"

msgid "<primary>package archive</primary>"
msgstr "<primary>软件包档案</primary>"

msgid "<primary>package</primary><secondary>Debian</secondary><tertiary>archive of</tertiary>"
msgstr "<primary>软件包</primary><secondary>Debian</secondary><tertiary>之档案</tertiary>"

msgid "Falcot Corp gradually started maintaining a number of Debian packages either locally modified from existing packages or created from scratch to distribute internal data and programs."
msgstr "Falcot Corp 公司逐渐开始维护大量的 Debian 软件包，或者是本地从现有软件包修改的，或者从头创建来发布内部数据和程序。"

msgid "To make deployment easier, they want to integrate these packages in a package archive that can be directly used by APT. For obvious maintenance reasons, they wish to separate internal packages from locally-rebuilt packages. The goal is for the matching entries in a <filename>/etc/apt/sources.list.d/falcot.list</filename> file to be as follows:"
msgstr "为了更容易部署，他们想要将这些软件包集成在能够由 APT 直接使用的软件包档案中。明显为了维护的原因，他们希望将内部软件包从本地重建的软件包中分出来。目标是使 <filename>/etc/apt/sources.list.d/falcot.list</filename> 文件中的匹配入口如后面这样："

msgid ""
"\n"
"deb http://packages.falcot.com/ updates/\n"
"deb http://packages.falcot.com/ internal/"
msgstr "\ndeb http://packages.falcot.com/ updates/\ndeb http://packages.falcot.com/ internal/"

msgid "<primary><command>mini-dinstall</command></primary>"
msgstr "<primary><command>mini-dinstall</command></primary>"

msgid "The administrators therefore configure a virtual host on their internal HTTP server, with <filename>/srv/vhosts/packages/</filename> as the root of the associated web space. The management of the archive itself is delegated to the <command>mini-dinstall</command> command (in the similarly-named package). This tool keeps an eye on an <filename>incoming/</filename> directory (in our case, <filename>/srv/vhosts/packages/mini-dinstall/incoming/</filename>) and waits for new packages there; when a package is uploaded, it is installed into a Debian archive at <filename>/srv/vhosts/packages/</filename>. The <command>mini-dinstall</command> command reads the <filename>*.changes</filename> file created when the Debian package is generated. These files contain a list of all other files associated with the version of the package (<filename>*.deb</filename>, <filename>*.dsc</filename>, <filename>*.diff.gz</filename>/<filename>*.debian.tar.gz</filename>, <filename>*.orig.tar.gz</filename>, or their equivalents with other compression tools), and these allow <command>mini-dinstall</command> to know which files to install. <filename>*.changes</filename> files also contain the name of the target distribution (often <literal>unstable</literal>) mentioned in the latest <filename>debian/changelog</filename> entry, and <command>mini-dinstall</command> uses this information to decide where the package should be installed. This is why administrators must always change this field before building a package, and set it to <literal>internal</literal> or <literal>updates</literal>, depending on the target location. <command>mini-dinstall</command> then generates the files required by APT, such as <filename>Packages.gz</filename>."
msgstr "这样管理员在他们的内部 HTTP 服务器上配置虚拟主机，以 <filename>/srv/vhosts/packages/</filename> 作为相关 web 空间的根。档案本身的管理委托给 <command>mini-dinstall</command> 命令（在相似命名的软件包中）。这个工具照看 <filename>incoming/</filename> 目录（在我们的情况下是 <filename>/srv/vhosts/packages/mini-dinstall/incoming/</filename>），并在那里等待新的软件包；软件包当上传时，就安装在 <filename>/srv/vhosts/packages/</filename> 的 Debian 档案中。<command>mini-dinstall</command> 命令读取 Debian 软件包生成时创建的 <filename>*.changes</filename> 文件。这些文件包含与软件包的版本相关的所有其它文件的列表（<filename>*.deb</filename>、<filename>*.dsc</filename>、<filename>*.diff.gz</filename>/<filename>*.debian.tar.gz</filename>、<filename>*.orig.tar.gz</filename>，或使用其它压缩工具生成的它们的相应文件），并且这些允许 <command>mini-dinstall</command> 知道安装哪些文件。<filename>*.changes</filename> 文件还包含目标发布版本（通常是 <literal>unstable</literal>）的名称，这些目标发布版本在最新的 <filename>debian/changelog</filename> 入口被提到，并且 <command>mini-dinstall</command> 使用这个信息来确定软件包应该安装在哪里。这就是为什么管理员在构建软件包前必须总是更改这个字段，并依赖于目标位置，将它设置为 <literal>internal</literal> 或 <literal>updates</literal>。然后 <command>mini-dinstall</command> 生成 APT 所需的文件，如 <filename>Packages.gz</filename>。"

msgid "<emphasis>ALTERNATIVE</emphasis> <command>apt-ftparchive</command> and <command>reprepro</command>"
msgstr "<emphasis>替代</emphasis> <command>apt-ftparchive</command> 和 <command>reprepro</command>"

msgid "<primary><command>apt-ftparchive</command></primary>"
msgstr "<primary><command>apt-ftparchive</command></primary>"

msgid "If <command>mini-dinstall</command> seems too complex for your Debian archive needs, you can also use the <command>apt-ftparchive</command> command. This tool scans the contents of a directory and displays (on its standard output) a matching <filename>Packages</filename> file. In the Falcot Corp case, administrators could upload the packages directly into <filename>/srv/vhosts/packages/updates/</filename> or <filename>/srv/vhosts/packages/internal/</filename>, then run the following commands to create the <filename>Packages.gz</filename> files:"
msgstr "如果 <command>mini-dinstall</command> 对您的 Debian 档案需求看起来太复杂，那么还可以使用 <command>apt-ftparchive</command> 命令。这个工具扫描目录的内容，并（在其标准输出上）显示匹配的 <filename>Packages</filename> 文件。在 Falcot Corp 公司的情况下，管理员应该将软件包直接上传到 <filename>/srv/vhosts/packages/updates/</filename> 或 <filename>/srv/vhosts/packages/internal/</filename>，然后运行后面的命令来创建 <filename>Packages.gz</filename> 文件："

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cd /srv/vhosts/packages</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages updates &gt;updates/Packages</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>gzip updates/Packages</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages internal &gt;internal/Packages</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>gzip internal/Packages</userinput>"
msgstr "\n<computeroutput>$ </computeroutput><userinput>cd /srv/vhosts/packages</userinput>\n<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages updates &gt;updates/Packages</userinput>\n<computeroutput>$ </computeroutput><userinput>gzip updates/Packages</userinput>\n<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages internal &gt;internal/Packages</userinput>\n<computeroutput>$ </computeroutput><userinput>gzip internal/Packages</userinput>"

msgid "The <command>apt-ftparchive sources</command> command allows creating <filename>Sources.gz</filename> files in a similar fashion."
msgstr "<command>apt-ftparchive sources</command> 命令允许以相似的方式创建 <filename>Sources.gz</filename> 文件。"

msgid "<command>reprepro</command> is a more advanced tool for the same purpose. It can produce, manage and synchronize a local repository of packages. It stores packages and checksums in a Berkeley DB database file, so no database server is needed. With <command>reprepro</command> you can check signatures of mirrored repositories and create signatures of the generated package indices."
msgstr "<command>reprepro</command> 是用于相同目的更高级的工具。它可以产生、管理并同步软件包的本地仓库。它将软件包和校验和存储在 Berkeley DB 数据库文件中，所以不需要数据库服务器。通过 <command>reprepro</command>，可以检查镜像仓库的签名，并创建生成的软件包索引的签名。"

msgid "Configuring <command>mini-dinstall</command> requires setting up a <filename>~/.mini-dinstall.conf</filename> file; in the Falcot Corp case, the contents are as follows:"
msgstr "配置 <command>mini-dinstall</command> 需要设置 <filename>~/.mini-dinstall.conf</filename> 文件；在 Falcot Corp 公司的情况下，内容如下："

msgid ""
"\n"
"[DEFAULT]\n"
"archive_style = flat\n"
"archivedir = /srv/vhosts/packages\n"
"\n"
"verify_sigs = 0\n"
"mail_to = admin@falcot.com\n"
"\n"
"generate_release = 1\n"
"release_origin = Falcot Corp\n"
"release_codename = stable\n"
"\n"
"[updates]\n"
"release_label = Recompiled Debian Packages\n"
"\n"
"[internal]\n"
"release_label = Internal Packages"
msgstr "\n[DEFAULT]\narchive_style = flat\narchivedir = /srv/vhosts/packages\n\nverify_sigs = 0\nmail_to = admin@falcot.com\n\ngenerate_release = 1\nrelease_origin = Falcot Corp\nrelease_codename = stable\n\n[updates]\nrelease_label = Recompiled Debian Packages\n\n[internal]\nrelease_label = Internal Packages"

msgid "One decision worth noting is the generation of <filename>Release</filename> files for each archive. This can help manage package installation priorities using the <filename>/etc/apt/preferences</filename> configuration file (see <xref linkend=\"sect.apt.priorities\" /> for details)."
msgstr "值得注意的一个决定是为每个档案生成 <filename>Release</filename> 文件。这可以使用 <filename>/etc/apt/preferences</filename> 配置文件来帮助管理软件包安装的优先性（细节请参见 <xref linkend=\"sect.apt.priorities\" /> ）。"

msgid "<emphasis>SECURITY</emphasis> <command>mini-dinstall</command> and permissions"
msgstr "<emphasis>安全</emphasis> <command>mini-dinstall</command> 与权限"

msgid "Since <command>mini-dinstall</command> has been designed to run as a regular user, there is no need to run it as root. The easiest way is to configure everything within the user account belonging to the administrator in charge of creating the Debian packages. Since only this administrator has the required permissions to put files in the <filename>incoming/</filename> directory, we can deduce that the administrator authenticated the origin of each package prior to deployment and <command>mini-dinstall</command> does not need to do it again. This explains the <literal>verify_sigs = 0</literal> parameter (which means that signatures need not be verified). However, if the contents of packages are sensitive, we can reverse the setting and elect to authenticate with a keyring containing the public keys of persons allowed to create packages (configured with the <literal>extra_keyrings</literal> parameter); <command>mini-dinstall</command> will then check the origin of each incoming package by analyzing the signature integrated to the <filename>*.changes</filename> file."
msgstr "由于 <command>mini-dinstall</command> 设计来作为常规用户运行，因此不需要作为根来运行它。最简单的方式是，在属于负责创建 Debian 软件包的管理员的用户账户内，配置所有内容。由于只有这位管理员具有所需的权限将文件放置在 <filename>incoming/</filename> 目录中，我们可以推断，管理员在部署前认证每个软件包的来源，而 <command>mini-dinstall</command> 不需要再做一次。这解释了 <literal>verify_sigs = 0</literal> 参数（它意味着不需要核实签名）。然而，如果软件包的内容是敏感的，那么我们可以相反地设置，并通过包含允许公钥的钥匙环来允许创建软件包，这个公钥属于创建软件包的人员（以 <literal>extra_keyrings</literal> 参数来配置）；<command>mini-dinstall</command> 然后通过分析集成到 <filename>*.changes</filename> 文件中的签名，来检查每个到来的软件包的来源。"

msgid "Invoking <command>mini-dinstall</command> actually starts a daemon in the background. As long as this daemon runs, it will check for new packages in the <filename>incoming/</filename> directory every half-hour; when a new package arrives, it will be moved to the archive and the appropriate <filename>Packages.gz</filename> and <filename>Sources.gz</filename> files will be regenerated. If running a daemon is a problem, <command>mini-dinstall</command> can also be manually invoked in batch mode (with the <literal>-b</literal> option) every time a package is uploaded into the <filename>incoming/</filename> directory. Other possibilities provided by <command>mini-dinstall</command> are documented in its <citerefentry><refentrytitle>mini-dinstall</refentrytitle> <manvolnum>1</manvolnum></citerefentry> manual page."
msgstr "调用 <command>mini-dinstall</command> 实际上在后端启动了守护程序。只要这个守护程序运行，它就将每半个小时检查一次 <filename>incoming/</filename> 目录中的新软件包；新软件包当到达时，将被移动到档案中，并生成适当的 <filename>Packages.gz</filename> 和 <filename>Sources.gz</filename> 文件。如果运行守护程序是个问题，那么软件包每次上传到 <filename>incoming/</filename> 目录中时， <command>mini-dinstall</command> 也能够以批处理模式手动调用（通过 <literal>-b</literal> 选项）。由 <command>mini-dinstall</command> 提供的其它可能性归档在其 <citerefentry><refentrytitle>mini-dinstall</refentrytitle><manvolnum>1</manvolnum></citerefentry> 手册页面中。"

msgid "<emphasis>EXTRA</emphasis> Generating a signed archive"
msgstr "<emphasis>补充</emphasis> 生成签名的档案"

msgid "The APT suite checks a chain of cryptographic signatures on the packages it handles before installing them, in order to ensure their authenticity (see <xref linkend=\"sect.package-authentication\" />). Private APT archives can then be a problem, since the machines using them will keep displaying warnings about unsigned packages. A diligent administrator will therefore integrate private archives with the secure APT mechanism."
msgstr "APT 套件在安装它处理的软件包之前，检查它们的加密签名链，从而确保它们的真实性（请参见 <xref linkend=\"sect.package-authentication\" />）。然后私有 APT 档案会有问题，因为使用它们的机器会一直显示未签名软件包的警告。这样勤奋的管理员将私有档案集成带有安全 APT 机制。"

msgid "To help with this process, <command>mini-dinstall</command> includes a <literal>release_signscript</literal> configuration option that allows specifying a script to use for generating the signature. A good starting point is the <filename>sign-release.sh</filename> script provided by the <emphasis role=\"pkg\">mini-dinstall</emphasis> package in <filename>/usr/share/doc/mini-dinstall/examples/</filename>; local changes may be relevant."
msgstr "为了帮助这个过程，<command>mini-dinstall</command> 包括 <literal>release_signscript</literal> 配置选项，允许指定脚本来产生签名。好的起点是 <filename>sign-release.sh</filename> 脚本，由 <filename>/usr/share/doc/mini-dinstall/examples/</filename> 中的 <emphasis role=\"pkg\">mini-dinstall</emphasis> 软件包来提供； 本地更改会是相关的。"

msgid "Becoming a Package Maintainer"
msgstr "成为软件包的维护者"

msgid "Learning to Make Packages"
msgstr "学习制作软件包"

msgid "Creating a quality Debian package is not always a simple task, and becoming a package maintainer takes some learning, both with theory and practice. It is not a simple matter of building and installing software; rather, the bulk of the complexity comes from understanding the problems and conflicts, and more generally the interactions, with the myriad of other packages available."
msgstr "创建有质量的 Debian 软件包并不总是个简单的任务，而成为软件包的维护者需要一些学习，既在理论上也在实践上。这不是创建与安装软件的简单事情；而是，大量的复杂性来自对问题和冲突的理解，而一般的是与其它无数可用软件包的相互作用。"

msgid "Rules"
msgstr "规则"

msgid "A Debian package must comply with the precise rules compiled in the Debian policy, and each package maintainer must know them. There is no requirement to know them by heart, but rather to know they exist and to refer to them whenever a choice presents a non-trivial alternative. Every Debian maintainer has made mistakes by not knowing about a rule, but this is not a huge problem as long as the error gets fixed when a user reports it as a bug report (which tends to happen fairly soon thanks to advanced users). The <literal>Standards-Version</literal> field in <filename>debian/control</filename> specifies the version of the Debian policy with which a package complies. Maintainers should comply to the latest version of the Debian policy. <ulink type=\"block\" url=\"https://www.debian.org/doc/debian-policy/\" />"
msgstr "Debian 软件包必须遵守 Debian 政策中编译的精确规则，并且每位软件包维护者必须知道这些规则。并不要求把它们记在心理，而无论何时选项中出现了不那么琐碎的替代方案，都要知道它们存在并去查阅它们。每位 Debian 维护者都会因为不知道规则而犯错误，但只要当用户将其作为故障报告而汇报时错误能得到修复（这由于高级用户而趋于迅速发生），这就不是个大问题。<filename>debian/control</filename> 中的 <literal>Standards-Version</literal> 字段指示了软件包所遵守的 Debian 政策的版本。维护者应该遵守最新版本的 Debian 政策。<ulink type=\"block\" url=\"https://www.debian.org/doc/debian-policy/\" />"

msgid "Procedures"
msgstr "过程"

msgid "<primary>Debian Developer's Reference</primary>"
msgstr "<primary>Debian 开发者的参考</primary>"

msgid "Debian is not a simple collection of individual packages. Everyone's packaging work is part of a collective project; being a Debian developer involves knowing how the Debian project operates as a whole. Every developer will, sooner or later, interact with others. The Debian Developer's Reference (in the <emphasis role=\"pkg\">developers-reference</emphasis> package) summarizes what every developer must know in order to interact as smoothly as possible with the various teams within the project, and to take the best possible advantages of the available resources. This document also enumerates a number of duties a developer is expected to fulfill. <ulink type=\"block\" url=\"https://www.debian.org/doc/manuals/developers-reference/\" />"
msgstr "Debian 不是独立软件包的简单集合。每个人的打包工作都是集体项目的一部分；成为 Debian 开发者包括了解 Debian 项目作为整体如何运作。每位开发者迟早都会与他人互动。Debian 开发者参考（在 <emphasis role=\"pkg\">developers-reference</emphasis> 软件包中）总结了每位开发者都必须知道的内容，从而尽可能平滑地在项目中与各个团队互动，并尽获得可用资源尽可能多的优点。本文档还列举了一些开发者必须尽到的责任。<ulink type=\"block\" url=\"https://www.debian.org/doc/manuals/developers-reference/\" />"

msgid "Tools"
msgstr "工具"

msgid "Many tools help package maintainers in their work. This section describes them quickly, but does not give the full details, since they all have comprehensive documentation of their own."
msgstr "很多工具帮助软件包的维护人员进行他们的工作。这一节快速地描述了这些工具，但没有给出完整细节，因为它们各自都有详细的文档。"

msgid "The <command>lintian</command> Program"
msgstr "<command>lintian</command> 程序"

msgid "<primary><command>lintian</command></primary>"
msgstr "<primary><command>lintian</command></primary>"

msgid "This tool is one of the most important: it is the Debian package checker. It is based on a large array of tests created from the Debian policy, and detects quickly and automatically many errors that can then be fixed before packages are released."
msgstr "这是最重要的工具之一：它是 Debian 软件包检查程序。它基于从 Debian 政策创立的大量测试，并快速且自动地检测很多错误，然后可以在软件包发布前修复。"

msgid "This tool is only a helper, and it sometimes gets it wrong (for instance, since the Debian policy changes over time, <command>lintian</command> is sometimes outdated). It is also not exhaustive: not getting any Lintian error should not be interpreted as a proof that the package is perfect; at most, it avoids the most common errors."
msgstr "这个工具只是个帮手，它有时会犯错误（例如，由于 Debian 政策不时更改，<command>lintian</command> 有时会过时）。它有时还不够详细：没有得到任何 Lintian 错误不应该被理解成软件包被证明是完美的；最多不过是避免了最常见的错误。"

msgid "The <command>piuparts</command> Program"
msgstr "<command>piuparts</command> 程序"

msgid "<primary><command>piuparts</command></primary>"
msgstr "<primary><command>piuparts</command></primary>"

msgid "This is another important tool: it automates the installation, upgrade, removal and purge of a package (in an isolated environment), and checks that none of these operations leads to an error. It can help in detecting missing dependencies, and it also detects when files are incorrectly left over after the package got purged."
msgstr "这是另一个重要工具：它（在隔离的环境中）自动安装、升级、删除并净化软件包，并且检查这些操作不会导致错误。它可以帮助检查丢失的依赖，并且还可以检查在软件包净化后文件在什么时候不正确地留下来。"

msgid "devscripts"
msgstr "devscripts"

msgid "<primary><emphasis role=\"pkg\">devscripts</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">devscripts</emphasis></primary>"

msgid "<primary><command>debuild</command></primary>"
msgstr "<primary><command>debuild</command></primary>"

msgid "<primary><command>dch</command></primary>"
msgstr "<primary><command>dch</command></primary>"

msgid "<primary><command>uscan</command></primary>"
msgstr "<primary><command>uscan</command></primary>"

msgid "<primary><command>debi</command></primary>"
msgstr "<primary><command>debi</command></primary>"

msgid "<primary><command>debc</command></primary>"
msgstr "<primary><command>debc</command></primary>"

msgid "The <emphasis role=\"pkg\">devscripts</emphasis> package contains many programs helping with a wide array of a Debian developer's job:"
msgstr "<emphasis role=\"pkg\">devscripts</emphasis> 软件包包含很多程序来帮助大范围的 Debian 开发者的工作："

msgid "<command>debuild</command> allows generating a package (with <command>dpkg-buildpackage</command>) and running <command>lintian</command> to check its compliance with the Debian policy afterwards."
msgstr "<command>debuild</command> 允许（以 <command>dpkg-buildpackage</command>）来生成软件包，此后允许运行<command>lintian</command> 来检查它与 Debian 政策的兼容性。"

msgid "<command>debclean</command> cleans a source package after a binary package has been generated."
msgstr "<command>debclean</command> 在生成二进制包后清除源码包。"

msgid "<command>dch</command> allows quick and easy editing of a <filename>debian/changelog</filename> file in a source package."
msgstr "<command>dch</command> 允许快速且容易地编辑源码包中的 <filename>debian/changelog</filename> 文件。"

msgid "<command>uscan</command> checks whether a new version of a software has been released by the upstream author; this requires a <filename>debian/watch</filename> file with a description of the location of such releases."
msgstr "<command>uscan</command> 检查新版本的软件是否已经由上游作者发布；这需要 <filename>debian/watch</filename> 文件具有这个发布位置的描述。"

msgid "<command>debi</command> allows installing (with <command>dpkg -i</command>) the Debian package that was just generated without the need to type its full name and path."
msgstr "<command>debi</command> 允许（以 <command>dpkg -i</command>）来安装刚生成的 Debian 软件包，而无需键入其完整名称与路径。"

msgid "In a similar fashion, <command>debc</command> allows scanning the contents of the recently-generated package (with <command>dpkg -c</command>), without needing to type its full name and path."
msgstr "<command>debc</command> 允许以相似的方式（用 <command>dpkg -c</command>）来扫描最近生成的软件包，而无需键入其完整名称与路径。"

msgid "<command>bts</command> controls the bug tracking system from the command line; this program automatically generates the appropriate emails."
msgstr "<command>bts</command> 从命令行控制缺陷跟踪系统；这个程序自动生成适当的电子邮件。"

msgid "<command>debrelease</command> uploads a recently-generated package to a remote server, without needing to type the full name and path of the related <filename>.changes</filename> file."
msgstr "<command>debrelease</command> 将最近生成的软件包上传到远端的服务器，而无需键入相关的 <filename>.changes</filename> 文件的完整名称与路径。"

msgid "<command>debsign</command> signs the <filename>*.dsc</filename> and <filename>*.changes</filename> files."
msgstr "<command>debsign</command> 签署 <filename>*.dsc</filename> 和 <filename>*.changes</filename> 文件。"

msgid "<command>uupdate</command> automates the creation of a new revision of a package when a new upstream version has been released."
msgstr "当上游版本发布时，<command>uupdate</command> 自动创建新版本的软件包。"

msgid "<emphasis role=\"pkg\">debhelper</emphasis> and <emphasis role=\"pkg\">dh-make</emphasis>"
msgstr "<emphasis role=\"pkg\">debhelper</emphasis> 和 <emphasis role=\"pkg\">dh-make</emphasis>"

msgid "<primary><emphasis>debhelper</emphasis></primary>"
msgstr "<primary><emphasis>debhelper</emphasis></primary>"

msgid "<primary><emphasis>dh-make</emphasis></primary>"
msgstr "<primary><emphasis>dh-make</emphasis></primary>"

msgid "Debhelper is a set of scripts easing the creation of policy-compliant packages; these scripts are invoked from <filename>debian/rules</filename>. Debhelper has been widely adopted within Debian, as evidenced by the fact that it is used by the majority of official Debian packages. All the commands it contains have a <command>dh_</command> prefix."
msgstr "Debhelper 是一组脚本，使创建政策兼容的软件包更容易；这些脚本从 <filename>debian/rules</filename> 中调用。Debhelper 已经在 Debian 中广泛采用，主要的 Debian 官方软件包都使用它就是证明。它包含的所有命令都具有 <command>dh_</command> 前缀。"

msgid "The <command>dh_make</command> script (in the <emphasis>dh-make</emphasis> package) creates files required for generating a Debian package in a directory initially containing the sources for a piece of software. As can be guessed from the name of the program, the generated files use debhelper by default."
msgstr "<command>dh_make</command> 脚本（位于 <emphasis>dh-make</emphasis> 软件包中）创建文件，在初始包含一块软件的源代码的目录中生成 Debian 软件包需要这些创建文件。可以从程序的名称猜到，生成的文件默认使用 debhelper。"

msgid "<emphasis role=\"pkg\">autopkgtest</emphasis>"
msgstr "<emphasis role=\"pkg\">autopkgtest</emphasis>"

msgid "<primary><emphasis>autopkgtest</emphasis></primary>"
msgstr "<primary><emphasis>autopkgtest</emphasis></primary>"

msgid "<command>autopkgtest</command> runs tests on binary packages, using the tests supplied in the source package."
msgstr "<command>autopkgtest</command> 使用源码包中提供的测试，来测试二进制包。"

msgid "<emphasis role=\"pkg\">reprotest</emphasis>"
msgstr "<emphasis role=\"pkg\">reprotest</emphasis>"

msgid "<primary><emphasis>reprotest</emphasis></primary>"
msgstr "<primary><emphasis>reprotest</emphasis></primary>"

msgid "<command>reprotest</command> builds the same source code twice in different environments, and then checks the binaries produced by each build for differences. If any are found, then <command>diffoscope</command> (if unavailable, <command>diff</command>) is used to display them in detail for later analysis."
msgstr "<command>reprotest</command> 在不同的环境中两次构建相同的源代码，然后检查每次构建的二进制文件的差异。如果发现任何差异，那么 <command>diffoscope</command>（如果可用的话则用 <command>diff</command>）来具体显示它们供后面进行分析。"

msgid "<command>dupload</command> and <command>dput</command>"
msgstr "<command>dupload</command> 和 <command>dput</command>"

msgid "<primary><command>dupload</command></primary>"
msgstr "<primary><command>dupload</command></primary>"

msgid "<primary><command>dput</command></primary>"
msgstr "<primary><command>dput</command></primary>"

msgid "The <command>dupload</command> and <command>dput</command> commands allow uploading a Debian package to a (possibly remote) server. This allows developers to publish their package on the main Debian server (<literal>ftp-master.debian.org</literal>) so that it can be integrated to the archive and distributed by mirrors. These commands take a <filename>*.changes</filename> file as a parameter, and deduce the other relevant files from its contents."
msgstr "<command>dupload</command> 和 <command>dput</command> 命令允许将 Debian 软件包上传到（可能是远端的）服务器上。这允许开发者将他们的软件包发布在主 Debian 服务器（<literal>ftp-master.debian.org</literal>）上，从而可以集成到档案中并通过镜像发布。这些命令将 <filename>*.changes</filename> 文件作为参数，并从其内容中推断出其它相关文件。"

msgid "Acceptance Process"
msgstr "接受过程"

msgid "Becoming a “Debian developer” is not a simple administrative matter. The process comprises several steps, and is as much an initiation as it is a selection process. In any case, it is formalized and well-documented, so anyone can track their progression on the website dedicated to the new member process. <ulink type=\"block\" url=\"https://nm.debian.org/\" />"
msgstr "称为 “Debian 开发者”不是个简单的管理性事情。这个过程包含几个步骤，从开始就更是一个选择过程。在任何情况下，这个过程形成并良好地归档，因此任何人都可以在专供新的成员处理的网站上跟踪其进展。 <ulink type=\"block\" url=\"https://nm.debian.org/\" />"

msgid "<emphasis>EXTRA</emphasis> Lightweight process for “Debian Maintainers”"
msgstr "<emphasis>补充</emphasis> “Debian 维护者”的瘦身过程"

msgid "“Debian Maintainer” is another status that gives less privileges than “Debian developer” but whose associated process is quicker. With this status, the contributors can maintain their own packages only. A Debian developer only needs to perform a check on an initial upload, and issue a statement to the effect that they trust the prospective maintainer with the ability to maintain the package on their own."
msgstr "“Debian 维护者”是另一种状态，比“Debian 开发者”给出更少特权，但他们的相关过程更迅速。通过这个状态，贡献者只可以维护其自己的软件包。Debian 开发者只需要在初始上传时执行检查，并对后果发布声明，他们信任那些自己有能力维护软件包的潜在维护者。"

msgid "<primary>Debian Maintainer</primary>"
msgstr "<primary>Debian维护者</primary>"

msgid "Prerequisites"
msgstr "先决条件"

msgid "All candidates are expected to have at least a working knowledge of the English language. This is required at all levels: for the initial communications with the examiner, of course, but also later, since English is the preferred language for most of the documentation; also, package users will be communicating in English when reporting bugs, and they will expect replies in English."
msgstr "希望所有的志愿者都至少具有英语的工作知识。在所有层面都对此有要求：用于与检查者的初始沟通，当然同样也用于后面的进一步沟通，因为英语是多数文档的首选语言；同样，软件包的用户当汇报缺陷时也用英语沟通，并且他们希望以英语回复。"

msgid "The other prerequisite deals with motivation. Becoming a Debian developer is a process that only makes sense if the candidate knows that their interest in Debian will last for many months. The acceptance process itself may last for several months, and Debian needs developers for the long haul; each package needs permanent maintenance, and not just an initial upload."
msgstr "其它先决条件涉及动机。成为 Debian 开发者是个过程，如果志愿者知道他们对 Debian 的兴趣会持续很长时间时才有意义。接受过程本身会持续几个月，而 Debian 需要开发者进行长时间费时费力的工作；每个软件包需要永久维护，而不只是初始的上传。"

msgid "Registration"
msgstr "注册"

msgid "The first (real) step consists in finding a sponsor or advocate; this means an official developer willing to state that they believe that accepting <emphasis>X</emphasis> would be a good thing for Debian. This usually implies that the candidate has already been active within the community, and that their work has been appreciated. If the candidate is shy and their work is not publicly touted, they can try to convince a Debian developer to advocate them by showing their work in a private way."
msgstr "第一个（真实的）步骤包括找到赞助者或拥护者；这意味着官方开发者愿意声明，他们相信接受<emphasis>某个项目</emphasis>对于 Debian 是件好事。这通常意味着志愿者在社区内已经是活跃的，并且他们的工作已经受到欢迎。如果志愿者太羞涩并且他们的工作没有公开宣传，他们可以尝试以私下的方式展示他们的工作，来说服 Debian 开发者支持他们。"

msgid "<primary>key pair</primary>"
msgstr "<primary>密钥对</primary>"

msgid "At the same time, the candidate must generate a public/private RSA key pair with GnuPG, which should be signed by at least two official Debian developers. The signature authenticates the name on the key. Effectively, during a key signing party, each participant must show an official identification (usually an ID card or passport) together with their key identifiers. This step confirms the link between the human and the keys. This signature thus requires meeting in real life. If you have not yet met any Debian developers in a public free software conference, you can explicitly seek developers living nearby using the list on the following webpage as a starting point. <ulink type=\"block\" url=\"https://wiki.debian.org/Keysigning\" />"
msgstr "同时，志愿者必须以 GnuPG 来生成 RSA 公钥/私钥对，这必须由至少两名官方 Debian 开发者签署。签名验证了密钥上的名称。在密钥签发组中，每位参加者必须有效地将官方身份（通常是身份证或护照）与他们的密钥识别符一起展示。这一步确认了真人与密钥之间的联系。这样，这个签名需要真实生活中的会面。如果还没有在公开的自由软件会议中遇到任何 Debian 开发者，那么必须使用后面的网页上的列表作为起点，来明确地寻找生活在附近的开发者。<ulink type=\"block\" url=\"https://wiki.debian.org/Keysigning\" />"

msgid "Once the registration on <literal>nm.debian.org</literal> has been validated by the advocate, an <emphasis>Application Manager</emphasis> is assigned to the candidate. The application manager will then drive the process through multiple pre-defined steps and checks."
msgstr "一旦 <literal>nm.debian.org</literal> 上的注册被拥护者验证，那么 <emphasis>Application Manager（申请管理者）</emphasis> 就被指定给志愿者。然后申请管理者通过多个预定的步骤和检查来驱动这个过程。"

msgid "The first verification is an identity check. If you already have a key signed by two Debian developers, this step is easy; otherwise, the application manager will try and guide you in your search for Debian developers close by to organize a meet-up and a key signing."
msgstr "第一项验证是身份检查。如果已经有两名 Debian 开发者签发的密钥，那么这步很容易；否则，申请管理者将通过组织会见和密钥签发来尝试并引导您搜索附近的 Debian 开发者。"

msgid "Accepting the Principles"
msgstr "接受的原则"

msgid "These administrative formalities are followed by philosophical considerations. The point is to make sure that the candidate understands and accepts the social contract and the principles behind Free Software. Joining Debian is only possible if one shares the values that unite the current developers, as expressed in the founding texts (and summarized in <xref linkend=\"the-debian-project\" />)."
msgstr "这些管理手续经过哲学性的思考而来。要点是确定志愿者理解并接受社会接触与自由软件背后的原则。只有分享了将当前的开发者团结在一起这个价值观，如在奠基文本中所表达的（并且在 <xref linkend=\"the-debian-project\" /> 中总结），加入 Debian 才是可能的。"

msgid "In addition, each candidate wishing to join the Debian ranks is expected to know the workings of the project, and how to interact appropriately to solve the problems they will doubtless encounter as time passes. All of this information is generally documented in manuals targeting the new maintainers, and in the Debian developer's reference. An attentive reading of this document should be enough to answer the examiner's questions. If the answers are not satisfactory, the candidate will be informed. They will then have to read (again) the relevant documentation before trying again. In the cases where the existing documentation does not contain the appropriate answer for the question, the candidate can usually reach an answer with some practical experience within Debian, or potentially by discussing with other Debian developers. This mechanism ensures that candidates get involved somewhat in Debian before becoming a full part of it. It is a deliberate policy, by which candidates who eventually join the project are integrated as another piece of an infinitely extensible jigsaw puzzle."
msgstr "此外，希望每位想要加入 Debian 序列的志愿者都知道项目的工作，以及如何适当地互动，来解决随着时间的前进他们将无疑会遇到的问题。所有这些信息都存档在针对新维护者的手册中，以及在 Debian 开发者的参考手册中。仔细阅读这个文档应该足以回答检查者的问题。如果回答不够令人满意，那么将会通知志愿者。然后他们在尝试前必须（再次）阅读相关文档。在现有的文档没有包含问题的适当答案的情况下，志愿者通常可以通过 Debian 内的实践经验，或者可能潜在地通过与其他 Debian 开发者讨论来找到答案。这个机制确保了志愿者在成为真正的成员前在某种程度上参与进去。这是个深思熟虑的政策，最终加入项目的志愿者通过它组成了无限扩展的拼图的一部分。"

msgid "<primary><emphasis>Philosophy &amp; Procedures</emphasis></primary>"
msgstr "<primary><emphasis>哲学 &amp; 步骤</emphasis></primary>"

msgid "This step is usually known as the <emphasis>Philosophy &amp; Procedures</emphasis> (P&amp;P for short) in the lingo of the developers involved in the new member process."
msgstr "在新成员过程的术语中，这一步通常称为<emphasis>哲学 &amp; 步骤</emphasis>（简写为 P&amp;P）。"

msgid "Checking Skills"
msgstr "技能检查"

msgid "Each application to become an official Debian developer must be justified. Becoming a project member requires showing that this status is legitimate, and that it facilitates the candidate's job in helping Debian. The most common justification is that being granted Debian developer status eases maintenance of a Debian package, but it is not the only one. Some developers join the project to contribute to porting to a specific architecture, others want to improve documentation, and so on."
msgstr "每一份成为官方 Debian 开发者的申请都必须被证明。成为项目成员需要显示这个状态是合法的，并且促进了志愿者的工作来帮助 Debian。最通常的证明是授予了 Debian 开发者的状态使 Debian 软件包的维护更容易了，但不只是这一点。一些开发者加入项目，为导出到特定架构做出了贡献，另一些人想要改进文档，以及诸如此类。"

msgid "This step represents the opportunity for the candidate to state what they intend to do within the Debian project and to show what they have already done towards that end. Debian is a pragmatic project and saying something is not enough, if the actions do not match what is announced. Generally, when the intended role within the project is related to package maintenance, a first version of the prospective package will have to be validated technically and uploaded to the Debian servers by a sponsor among the existing Debian developers."
msgstr "这一步代表了志愿者的机会来声明想要在 Debian 项目中做什么，以及显示他们向终点已经做了什么。Debian 是务实的项目，如果行动与所宣称的不陪陪，那么只是说些什么是不够的。通常，当项目中期望的角色与项目维护相关时，预期的软件包的第一版必须通过现有的 Debian 开发者中的赞助者在技术上验证，并且上传到 Debian 服务器上。"

msgid "<emphasis>COMMUNITY</emphasis> Sponsoring"
msgstr "<emphasis>社区</emphasis> 赞助"

msgid "<primary>sponsoring</primary>"
msgstr "<primary>赞助</primary>"

msgid "Debian developers can “sponsor” packages prepared by someone else, meaning that they publish them in the official Debian repositories after having performed a careful review. This mechanism enables external persons, who have not yet gone through the new member process, to contribute occasionally to the project. At the same time, it ensures that all packages included in Debian have always been checked by an official member."
msgstr "Debian 开发者可以“赞助”其他人准备的软件包，这意味着在执行仔细的复核后，他们将软件包发布在官方 Debian 仓库中。这个机制允许还没有通过新成员过程的外部人员偶尔为项目做贡献。同时，它确保了 Debian 中包括的所有软件包总是由官方成员检查。"

msgid "Finally, the examiner checks the candidate's technical (packaging) skills with a detailed questionnaire. Bad answers are not permitted, but the answer time is not limited. All the documentation is available and several tries are allowed if the first answers are not satisfactory. This step does not intend to discriminate, but to ensure at least a modicum of knowledge common to new contributors."
msgstr "最后，检查者通过具体的调查表来检查志愿者的技术（打包）技能。答案不能不好，但答题时间没有限制。可以使用所有的文档，如果第一次回答不令人满意的话，允许尝试几次。这一步不是用来甄别的，而是确保新的贡献者都至少具有少量知识。"

msgid "<primary><emphasis>Tasks &amp; Skills</emphasis></primary>"
msgstr "<primary><emphasis>任务 &amp; 技能</emphasis></primary>"

msgid "This step is known as the <emphasis>Tasks &amp; Skills</emphasis> step (T&amp;S for short) in the examiners' jargon."
msgstr "这一步在检查者的行话中被称 <emphasis>任务 &amp; 技巧</emphasis> 步骤（简写为 T&amp;S）。"

msgid "Final Approval"
msgstr "最终确认"

msgid "At the very last step, the whole process is reviewed by a DAM (<emphasis>Debian Account Manager</emphasis>). The DAM will review all the information about the candidate that the examiner collected, and makes the decision on whether or not to create an account on the Debian servers. In cases where extra information is required, the account creation may be delayed. Refusals are rather rare if the examiner does a good job of following the process, but they sometimes happen. They are never permanent, and the candidate is free to try again at a later time."
msgstr "在最后一步，整个过程由 DAM （<emphasis>Debian Account Manager——Debian 账户管理者</emphasis>）复查。DAM 将复查检查者搜集的关于志愿者的所有信息，并决定是否在 Debian 服务器上创建账户。在需要补充信息的情况下，会推迟创建账户。 如果检查者在后面的过程中做了很好的工作的话，拒绝会很罕见，但有时也会发生。拒绝不是永久性的，志愿者后面可以任意尝试。"

msgid "The DAM's decision is authoritative and (almost) without appeal, which explains why the people in that seat have often been criticized in the past."
msgstr "DAM 的决定是权威性的，并且（几乎）不得上诉，这解释了为什么上位者过去经常被批评。"

#, fuzzy
#~ msgid "<emphasis>QUICK LOOK</emphasis> <command>pbuilder</command>"
#~ msgstr "<emphasis>速览</emphasis> <command>pbuilder</command>"
