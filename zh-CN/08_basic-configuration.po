# AUTHOR <EMAIL@ADDRESS>, YEAR.
msgid ""
msgstr "Project-Id-Version: 0\nPOT-Creation-Date: 2020-08-28 10:15+0200\nPO-Revision-Date: 2021-01-22 02:32+0000\nLast-Translator: Keen <keen_kwuo@msn.com>\nLanguage-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/debian-handbook/08_basic-configuration/zh_Hans/>\nLanguage: zh-CN\nMIME-Version: 1.0\nContent-Type: application/x-publican; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nPlural-Forms: nplurals=1; plural=0;\nX-Generator: Weblate 4.5-dev\n"

msgid "Configuration"
msgstr "配置"

msgid "Localization"
msgstr "本地化"

msgid "Locales"
msgstr "地区设置"

msgid "Network"
msgstr "网络"

msgid "Name resolution"
msgstr "名称解析"

msgid "Users"
msgstr "用户"

msgid "Groups"
msgstr "用户组"

msgid "Accounts"
msgstr "账户"

msgid "Command-line interpreter"
msgstr "命令行解释器"

msgid "Shell"
msgstr "Shell"

msgid "Printing"
msgstr "打印"

msgid "Bootloader"
msgstr "Bootloader"

msgid "Kernel compiling"
msgstr "内核编译"

msgid "Basic Configuration: Network, Accounts, Printing..."
msgstr "基础配置：网络，账户，打印……"

msgid "A computer with a new installation created with <command>debian-installer</command> is intended to be as functional as possible, but many services still have to be configured. Furthermore, it is always good to know how to change certain configuration elements defined during the initial installation process."
msgstr "以 <command>debian-installer</command> 命令安装的电脑是尽可能的可用，但仍有若干服务需要配置。而且，了解修改初始安装进程的配置是件好事。"

msgid "This chapter reviews everything included in what we could call the “basic configuration”: networking, language and locales, users and groups, printing, mount points, etc."
msgstr "这章综述我们称之为“基础配置”所包括的任何事项：网络、语言、地区、用户、用户组、打印、挂载点等。"

msgid "Configuring the System for Another Language"
msgstr "用其他语言进行配置"

msgid "<primary>French localization</primary>"
msgstr "<primary>法语环境</primary>"

msgid "If the system was installed using French, the machine will probably already have French set as the default language. But it is good to know what the installer does to set the language, so that later, if the need arises, you can change it."
msgstr "如果你在法语环境下安装了系统，那么默认语言可能会被设置为法语。所以你最好知道你的安装器使用的是什么语言。如果对语言有要求而又设置错误了，你可以自己进行修改。"

msgid "<emphasis>TOOL</emphasis> The <command>locale</command> command to display the current configuration"
msgstr "<emphasis>工具</emphasis> <command>locale</command> 命令显示当前配置"

msgid "The <command>locale</command> command lists a summary of the current configuration of various locale parameters (date format, numbers format, etc.), presented in the form of a group of standard environment variables dedicated to the dynamic modification of these settings."
msgstr "<command>locale</command> 命令会列出当前配置的语言环境参数（比如日期格式，数字格式），以一组标准环境变量表格的形式呈现当前的语言环境变量配置。"

msgid "Setting the Default Language"
msgstr "设置默认语言"

msgid "<primary>locales</primary>"
msgstr "<primary>地区</primary>"

msgid "<primary>language</primary>"
msgstr "<primary>语言</primary>"

msgid "<primary><command>locale-gen</command></primary>"
msgstr "<primary><command>locale-gen</command></primary>"

msgid "A locale is a group of regional settings. This includes not only the language for text, but also the format for displaying numbers, dates, times, and monetary sums, as well as the alphabetical comparison rules (to properly account for accented characters). Although each of these parameters can be specified independently from the others, we generally use a locale, which is a coherent set of values for these parameters corresponding to a “region” in the broadest sense. These locales are usually indicated under the form, <literal><replaceable>language-code</replaceable>_<replaceable>COUNTRY-CODE</replaceable></literal>, sometimes with a suffix to specify the character set and encoding to be used. This enables consideration of idiomatic or typographical differences between different regions with a common language."
msgstr "一个 locale 指一系列的区域设置。它不仅包括对文字语言的设置，也包括数字、日期、时间和货币的显示格式，以及“按字母顺序排列规则”（正确地处理重音字符）。虽然这些参数可以被独立配置，我们仍建议您使用 locale 这个从地区形式最大化匹配一连贯参数的工具。这些 locales 一般以以下格式 <literal><replaceable>语言代码</replaceable>_<replaceable>城市代码</replaceable></literal>，有时后缀也在指定字符集和编码中被使用。这是考虑到同一语言在不同区域之间使用习惯和印刷差异。"

msgid "<emphasis>CULTURE</emphasis> Character sets"
msgstr "<emphasis>文化</emphasis> 字符集"

msgid "<primary>character set</primary>"
msgstr "<primary>字符集</primary>"

msgid "<primary>encoding</primary>"
msgstr "<primary>编码</primary>"

msgid "<primary>ISO-8859-1</primary>"
msgstr "<primary>ISO-8859-1</primary>"

msgid "<primary>ISO-8859-15</primary>"
msgstr "<primary>ISO-8859-15</primary>"

msgid "<primary>Latin 1</primary>"
msgstr "<primary>Latin 1</primary>"

msgid "<primary>Latin 9</primary>"
msgstr "<primary>Latin 9</primary>"

msgid "Historically, each locale has an associated “character set” (group of known characters) and a preferred “encoding” (internal representation for characters within the computer)."
msgstr "历史上看，每一个 locale 都有一个相关联的字符集（一组已知的字符集）和一个特定的编码（为计算机内部的字符表达）。"

msgid "The most popular encodings for latin-based languages were limited to 256 characters because they opted to use a single byte for each character. Since 256 characters was not enough to cover all European languages, multiple encodings were needed, and that is how we ended up with <emphasis>ISO-8859-1</emphasis> (also known as “Latin 1”) up to <emphasis>ISO-8859-15</emphasis> (also known as “Latin 9”), among others."
msgstr "最广泛使用的字符编码是基于拉丁字母、使用单个 byte 表达一个字符，被限制为最多256个字符。256个字符不足以覆盖所有欧洲语言，因此多编码系统非常有必要，这就是为何我们有 <emphasis>ISO-8859-1</emphasis> （即“Latin 1”）到 <emphasis>ISO-8859-15</emphasis> （即“Latin 9”）的原因。"

msgid "Working with foreign languages often implied regular switches between various encodings and character sets. Furthermore, writing multilingual documents led to further, almost intractable problems. Unicode (a super-catalog of nearly all writing systems from all of the world's languages) was created to work around this problem. One of Unicode's encodings, UTF-8, retains all 128 ASCII symbols (7-bit codes), but handles other characters differently. Those are preceded by a specific escape sequence of a few bits, which implicitly defines the length of the character. This allows encoding all Unicode characters on a sequence of one or more bytes. Its use has been popularized by the fact that it is the default encoding in XML documents."
msgstr "包含外国语言的工作状态隐含着字符集和字符设置的切换。此外一个几乎无法解决的问题，如何编写一个多语言文档？ Unicode（一个几乎包括世界所有书写系统的超集）被创建用于解决该问题。其中一个 Unicode 编码， UTF-8 ，保留了全部128个 ASCII 符号（7位代码），还以不同的方式处理了其他字符。它们通过前面几个位的特定转义序列，隐式定义了字符的长度。它们允许在一个或者多个字节序列使用所有的 Unicode 字符。因为它是 XML 文件的默认编码而被广泛推广。"

msgid "<primary>ASCII</primary>"
msgstr "<primary>ASCII</primary>"

msgid "<primary>UTF-8</primary>"
msgstr "<primary>UTF-8</primary>"

msgid "<primary>Unicode</primary>"
msgstr "<primary>Unicode</primary>"

msgid "This is the encoding that should generally be used, and is thus the default on Debian systems."
msgstr "它是最广泛使用的编码，也是 Debian 发行版系统的默认选项。"

msgid "The <emphasis role=\"pkg\">locales</emphasis> package includes all the elements required for proper functioning of “localization” of various applications. During installation, this package will ask to select a set of supported languages. This set can be changed at any time by running <command>dpkg-reconfigure locales</command> as root."
msgstr "<emphasis role=\"pkg\">locales</emphasis> 包括所有应用“本地化”所需要的所有元素。安装过程中，该包将要求使用者选择一系列支持语言。该选择能在使用root帐号运行 <command>dpkg-reconfigure locales</command> 改变。"

msgid "The first question invites you to select “locales” to support. Selecting all English locales (meaning those beginning with “<literal>en_</literal>”) is a reasonable choice. Do not hesitate to also enable other locales if the machine will host foreign users. The list of locales enabled on the system is stored in the <filename>/etc/locale.gen</filename> file. It is possible to edit this file by hand, but you should run <command>locale-gen</command> after any modifications. It will generate the necessary files for the added locales to work, and remove any obsolete files."
msgstr "第一个让您回答的问题是选哪些“ locales ”来支持。选择所有英语国家（所有以<literal>en_</literal>开始的环境）是一种可能。如果主机上有外国用户，打开对应的语言环境支持不要犹豫。所有在本系统被打开支持的语言环境存储在 <filename>/etc/locale.gen</filename> 。它可以被手动编辑，但需要在你做任何改动后运行 <command>locale-gen</command> 使改动生效。该命令将创建新添加的语言环境及其关联文件并移除过期的文件。"

msgid "The second question, entitled “Default locale for the system environment”, requests a default locale. The recommended choice in the U.S.A. is “<literal>en_US.UTF-8</literal>”. British English speakers will prefer “<literal>en_GB.UTF-8</literal>”, and Canadians will prefer either “<literal>en_CA.UTF-8</literal>” or, for French, “<literal>fr_CA.UTF-8</literal>”. The <filename>/etc/default/locale</filename> file will then be modified to store this choice. From there, it is picked up by all user sessions since PAM will inject its content in the <varname>LANG</varname> environment variable."
msgstr "第二个问题，标题 “系统环境的默认字符环境”请求设置默认的字符系统。在美国推荐的选择是 <literal>en_US.UTF-8</literal>，英式发音者更习惯于 <literal>en_GB.UTF-8</literal> ，加拿大人喜欢 <literal>en_CA.UTF-8</literal> 或者对于法国人来说 <literal>fr_CA.UTF-8</literal>。<filename>/etc/default/locale</filename> 文件会保存这个变更。该设置将由 PAM 系统写入到所有登录用户会话的 <varname>LANG</varname> 环境变量。"

msgid "<primary>environment</primary>"
msgstr "<primary>环境</primary>"

msgid "<primary>locale</primary>"
msgstr "<primary>locale</primary>"

msgid "<primary><varname>LANG</varname></primary>"
msgstr "<primary><varname>LANG</varname></primary>"

msgid "The <emphasis role=\"pkg\">locales-all</emphasis> package contains the precompiled locale data for all supported locales."
msgstr "<emphasis role=\"pkg\">locales-all</emphasis> 包含有所有支持locale的预编译local数据。"

msgid "<emphasis>BEHIND THE SCENES</emphasis> <filename>/etc/environment</filename> and <filename>/etc/default/locale</filename>"
msgstr "<emphasis>幕后</emphasis><filename>/etc/environment</filename> 和 <filename>/etc/default/locale</filename>"

msgid "The <filename>/etc/environment</filename> file provides the <command>login</command>, <command>gdm</command>, or even <command>ssh</command> programs with the correct environment variables to be created."
msgstr "<filename>/etc/environment</filename> 文件为 <command>login</command> 、 <command>gdm</command>、 <command>ssh</command> 程序提供正确的环境变量。"

msgid "These applications do not create these variables directly, but rather via a PAM (<filename>pam_env.so</filename>) module. PAM (Pluggable Authentication Module) is a modular library centralizing the mechanisms for authentication, session initialization, and password management. See <xref linkend=\"sect.config-pam\" /> for an example of PAM configuration."
msgstr "这些应用不直接创建这些变量，而通过 PAM 系统的 <filename>pam_env.so</filename> 模块。PAM（插入式验证模块）是一个提供身份验证、会话初始化和密码管理的模块库。<xref linkend=\"sect.config-pam\" /> 是一个 PAM 配置样式。"

msgid "The <filename>/etc/default/locale</filename> file works in a similar manner, but contains only the <varname>LANG</varname> environment variable. Thanks to this split, some PAM users can inherit a complete environment without localization. Indeed, it is generally discouraged to run server programs with localization enabled; on the other hand, localization and regional settings are recommended for programs that open user sessions."
msgstr "<filename>/etc/default/locale</filename> 文件的工作方式非常简单，仅包含 <varname>LANG</varname> 环境变量。得益于这种分开的配置，一些 PAM 用户可以在没有本地化设置的情况下继承一个完整环境。事实上，并不鼓励启用本地化来运行服务器程序；另一方面，对于开放用户会话的程序，推荐打开本地化和地区设置。"

msgid "<primary>PAM</primary>"
msgstr "<primary>PAM</primary>"

msgid "<primary><filename>pam_env.so</filename></primary>"
msgstr "<primary><filename>pam_env.so</filename></primary>"

msgid "Configuring the Keyboard"
msgstr "键盘配置"

msgid "<primary>keyboard layout</primary>"
msgstr "<primary>键盘布局</primary>"

msgid "<primary>layout, keyboard</primary>"
msgstr "<primary> 布局，键盘</primary>"

msgid "Even if the keyboard layout is managed differently in console and graphical mode, Debian offers a single configuration interface that works for both: it is based on debconf and is implemented in the <emphasis role=\"pkg\">keyboard-configuration</emphasis> package. Thus the <command>dpkg-reconfigure keyboard-configuration</command> command can be used at any time to reset the keyboard layout."
msgstr "甚至如果键盘布局在终端和图形模式中被设置成不同， Debian 也提供了一个简单的配置让它们都工作：它基于 debconf 并由<emphasis role=\"pkg\">keyboard-configuration</emphasis> 包实现。使用 <command>dpkg-reconfigure keyboard-configuration</command> 命令来重新设置键盘布局。"

msgid "<primary><emphasis>console-data</emphasis></primary>"
msgstr "<primary><emphasis>终端数据</emphasis></primary>"

msgid "<primary><emphasis>console-tools</emphasis></primary>"
msgstr "<primary><emphasis>终端工具</emphasis></primary>"

msgid "<primary><emphasis role=\"pkg\">keyboard-configuration</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">keyboard-configuration</emphasis></primary>"

msgid "<indexterm><primary><literal>azerty</literal></primary></indexterm>The questions are relevant to the physical keyboard layout (a standard PC keyboard in the US will be a “Generic 104 key”), then the layout to choose (generally “US”), and then the position of the AltGr key (right Alt). Finally comes the question of the key to use for the “Compose key”, which allows for entering special characters by combining keystrokes. Type successively <keycombo action=\"seq\"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> and produce an e-acute (“é”). All these combinations are described in the <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> file (or another file, determined according to the current locale indicated by <filename>/usr/share/X11/locale/compose.dir</filename>)."
msgstr "<indexterm><primary><literal>azerty（一种法文键盘布局）</literal></primary></indexterm> 有关物理键盘布局（一个标准 US 键盘是 “Generic 104 key” ）的解决方式，布局选择一般的 US， AltGr 键则定位到右 Alt。最后一个，允许使用组合按键输入特殊字符的快捷键 Compose 键，先后使用 <keycombo action=\"seq\"><keycap>Compose</keycap> <keycap>'</keycap><keycap>e</keycap></keycombo>产生一个 e-acute（“é”）。这些组合在 <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> 中被定义（或者其他文件，可由 <filename>/usr/share/X11/locale/compose.dir</filename> 说明）。"

msgid "<primary><literal>Compose</literal>, key</primary>"
msgstr "<primary><literal>Compose</literal> 键</primary>"

msgid "<primary><literal>Meta</literal>, key</primary>"
msgstr "<primary><literal> Meta </literal>键</primary>"

msgid "<primary>key</primary><secondary><literal>Meta</literal></secondary>"
msgstr "<primary>按键</primary><secondary><literal>Meta</literal></secondary>"

msgid "<primary>key</primary><secondary><literal>Compose</literal></secondary>"
msgstr "<primary>按键</primary><secondary><literal>Compose</literal></secondary>"

msgid "Note that the keyboard configuration for graphical mode described here only affects the default layout; the GNOME and KDE Plasma environments, among others, provide a keyboard control panel in their preferences allowing each user to have their own configuration. Some additional options regarding the behavior of some particular keys are also available in these control panels."
msgstr "注意，该处说明的是默认键盘布局下图形模式的键盘设定； GNOME 和 KDE Plasma 等环境，为每一个用户提供一个键位控制面板去设置他们的喜好键位。面板中也能提供一些特殊键位的扩展选项。"

msgid "Migrating to UTF-8"
msgstr "迁移到 UTF-8"

msgid "The generalization of UTF-8 encoding has been a long awaited solution to numerous difficulties with interoperability, since it facilitates international exchange and removes the arbitrary limits on characters that can be used in a document. The one drawback is that it had to go through a rather difficult transition phase. Since it could not be completely transparent (that is, it could not happen at the same time all over the world), two conversion operations were required: one on file contents, and the other on filenames. Fortunately, the bulk of this migration has been completed and we discuss it largely for reference."
msgstr "尽管它去除字符上的任何限制使之在文档使用上没有任何问题，促进了国际化交换 ，但是总体上 UTF-8 编码作为一个期待已久的解决方案在互通上困难重重。其中一个弊端是它必须经历一个相当困难的过渡过程。它并不能做到完全透明（这是说，它无法做到整个世界同时切换），需要两个转换操作：一个是在文件内容，一个在文件名。幸运的是大部分工作已经完成了，在更很大程度上我们讨论它作为一种参考。"

msgid "<emphasis>CULTURE</emphasis> <foreignphrase>Mojibake</foreignphrase> and interpretation errors"
msgstr "<emphasis>文化</emphasis><foreignphrase> 乱码</foreignphrase>以及谬误"

msgid "When a text is sent (or stored) without encoding information, it is not always possible for the recipient to know with certainty what convention to use for determining the meaning of a set of bytes. You can usually get an idea by getting statistics on the distribution of values present in the text, but that doesn't always give a definite answer. When the encoding system chosen for reading differs from that used in writing the file, the bytes are mis-interpreted, and you get, at best, errors on some characters, or, at worst, something completely illegible."
msgstr "当一个文本发送（或者接收）但是却没有携带编码信息，接收者并不是常常能确切地知道如何去确定一组字节的含义。你通常能通过对文本进行统计获得一些帮助，但是并不是总得到一个确切的答案。当编码系统选择了不同于写入文件时使用的编码时，字节就被曲解了，当你获取它时，最好的结果是一些字符错了，最坏的结果，一些变得完全无法识别了。"

msgid "Thus, if a French text appears normal with the exception of accented letters and certain symbols which appear to be replaced with sequences of characters like “Ã©” or Ã¨” or “Ã§”, it is probably a file encoded as UTF-8 but interpreted as ISO-8859-1 or ISO-8859-15. This is a sign of a local installation that has not yet been migrated to UTF-8. If, instead, you see question marks instead of accented letters — even if these question marks seem to also replace a character that should have followed the accented letter — it is likely that your installation is already configured for UTF-8 and that you have been sent a document encoded in Western ISO."
msgstr "因此，如果一个法文文本其他字符都显示正常，但是重音字母却被像 “Ã©” or Ã¨” or “Ã§” 这样的字符取代，那么很有可能这个文件使用的编码是 UTF-8 但系统解释的时候用的是 ISO-8859-1 或者 ISO-8859-15 编码。很有可能你的本地语言环境没有转换到 UTF-8；相反，如果你看到的是一连串的问号，即使这些问号看上去像是被重音字母取代，很有可能你的本地语言系统确实配置了UTF-8，但是您获取到的是一个西方 ISO 格式编码的文档。"

msgid "So much for “simple” cases. These cases only appear in Western culture, since Unicode (and UTF-8) was designed to maximize the common points with historical encodings for Western languages based on the Latin alphabet, which allows recognition of parts of the text even when some characters are missing."
msgstr "一些“简单”的例子。这些例子限定在西方文化下，Unicode（以及 UTF-8）的设计最大兼容基于拉丁语系西方语言的历史编码，允许在部分字符缺失的情况下识别部分文本。"

msgid "In more complex configurations, which, for example, involve two environments corresponding to two different languages that do not use the same alphabet, you often get completely illegible results — a series of abstract symbols that have nothing to do with each other. This is especially common with Asian languages due to their numerous languages and writing systems. The Japanese word <foreignphrase>mojibake</foreignphrase> has been adopted to describe this phenomenon. When it appears, diagnosis is more complex and the simplest solution is often to simply migrate to UTF-8 on both sides."
msgstr "在较复杂的环境中，例如，使用字母表不同的两种语言，通常得到完全不同的结果 — 一系列彼此毫无关联的抽象符号。这种情况在拥有繁复语言和书写系统的亚洲语言中尤为常见。日语中的单词 <foreignphrase>mojibake</foreignphrase>（乱码）被用来描述这一现象。当这种现象出现时，诊断将非常困难。最简单的解决方案就是将两端都移植到UTF-8."

msgid "As far as file names are concerned, the migration can be relatively simple. The <command>convmv</command> tool (in the package with the same name) was created specifically for this purpose; it allows renaming files from one encoding to another. The use of this tool is relatively simple, but we recommend doing it in two steps to avoid surprises. The following example illustrates a UTF-8 environment containing directory names encoded in ISO-8859-15, and the use of <command>convmv</command> to rename them."
msgstr "就文件名而言，转换工作还算简单。<command>convmv</command>工具就是为这一场景设计的，它可以转换文件名编码。此工具的使用相对简单，但是我们推荐分两个步骤来使用，以避免意外。下例演示了一个包含ISO-8859-15编码目录名的UTF-8环境，并使用<command>convmv</command> 重命名的过程。"

msgid ""
"<computeroutput>$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Ic?nes  ?l?ments graphiques  Textes\n"
"$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>Starting a dry run without changes...\n"
"mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"No changes to your files done. Use --notest to finally rename the files.\n"
"$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>\n"
"<computeroutput>mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\n"
"mv \"travail/Ic�nes\"     \"travail/Icônes\"\n"
"Ready!\n"
"$ </computeroutput><userinput>ls travail/</userinput>\n"
"<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput>"
msgstr "<computeroutput>$ </computeroutput><userinput>ls travail/</userinput>\n<computeroutput>Ic?nes  ?l?ments graphiques  Textes\n$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>\n<computeroutput>Starting a dry run without changes...\nmv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\nmv \"travail/Ic�nes\"     \"travail/Icônes\"\nNo changes to your files done. Use --notest to finally rename the files.\n$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>\n<computeroutput>mv \"travail/�l�ments graphiques\"        \"travail/Éléments graphiques\"\nmv \"travail/Ic�nes\"     \"travail/Icônes\"\nReady!\n$ </computeroutput><userinput>ls travail/</userinput>\n<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput>"

msgid "For the file content, conversion procedures are more complex due to the vast variety of existing file formats. Some file formats include encoding information that facilitates the tasks of the software used to treat them; it is sufficient, then, to open these files and re-save them specifying UTF-8 encoding. In other cases, you have to specify the original encoding (ISO-8859-1 or “Western”, or ISO-8859-15 or “Western (Euro)”, according to the formulations) when opening the file."
msgstr "对文件内容来说，由于既存文件格式的多样性，转换过程会更加复杂。有些文件格式本身包含编码信息帮助软件使用它们。然后，打开这些文件并以UTF-8编码重新保存即可。其它的情况则必须指定原始的编码方式 (ISO-8859-1 或 “Western”、ISO-8859-15或 “Western (Euro)”，视其规则而定) 来打开它们。"

msgid "For simple text files, you can use <command>recode</command> (in the package of the same name) which allows automatic recoding. This tool has numerous options so you can play with its behavior. We recommend you consult the documentation, the <citerefentry> <refentrytitle>recode</refentrytitle> <manvolnum>1</manvolnum> </citerefentry> man page, or the <citerefentry> <refentrytitle>recode</refentrytitle> </citerefentry> info page (more complete)."
msgstr "简单的文本文件，可以使用<command>recode</command>（软件包同名）自动对文件重新编码。该工具有很多选项，您可以自由探索。我们推荐您参考文档， <citerefentry> <refentrytitle>recode</refentrytitle> <manvolnum>1</manvolnum> </citerefentry> man手册，或<citerefentry> <refentrytitle>recode</refentrytitle> </citerefentry> info页面（更为完善）。"

msgid "Configuring the Network"
msgstr "配置网络"

msgid "<emphasis>BACK TO BASICS</emphasis> Essential network concepts (Ethernet, IP address, subnet, broadcast)"
msgstr "<emphasis>基本知识</emphasis>必要的网络概念（以太网、IP地址、子网、广播）"

msgid "<primary>Ethernet</primary>"
msgstr "<primary>以太网</primary>"

msgid "<primary>10BASE-T</primary>"
msgstr "<primary>10BASE-T</primary>"

msgid "<primary>100BASE-T</primary>"
msgstr "<primary>100BASE-T</primary>"

msgid "<primary>1000BASE-T</primary>"
msgstr "<primary>1000BASE-T</primary>"

msgid "<primary>10GBASE-T</primary>"
msgstr "<primary>10GBASE-T</primary>"

msgid "<primary>connector, RJ45</primary>"
msgstr "<primary>连接器, RJ45</primary>"

msgid "<primary>RJ45 connector</primary>"
msgstr "<primary>RJ45 连接器</primary>"

msgid "Most modern local networks use the Ethernet protocol, where data is split into small blocks called frames and transmitted on the wire one frame at a time. Data speeds vary from 10 Mb/s for older Ethernet cards to 100 Gb/s in the newest cards (with the most common rate currently growing from 100 Mb/s to 10 Gb/s). The most widely used cables are called 10BASE-T, 100BASE-T, 1000BASE-T, 10GBASE-T and 40GBASE-T, depending on the throughput they can reliably provide (the T stands for “twisted pair”); those cables end in an RJ45 connector. There are other cable types, used mostly for speeds of 10 Gb/s and above."
msgstr "大多数现代网络使用以太网协议，数据被分成称为帧的小块，并在网络上一帧一帧地传输。传输速度从较古老的网卡的10Mb /s到最新网卡的100Gb /s不等(目前最常见的速率是从100Mb /s到10Gb /s)。最常使用的线缆是10BASE-T、100BASE-T、1000BASE-T、10GBASE-T和40GBASE-T，这取决于它们能够可靠提供的吞吐量(T代表“双绞线”);这些线缆两端是RJ45连接器。还有其他类型的线缆，主要用于10Gb /s以上速度的场景。"

msgid "<primary>address, IP address</primary>"
msgstr "<primary>地址, IP地址</primary>"

msgid "<primary>IP address</primary>"
msgstr "<primary>IP 地址</primary>"

msgid "An IP address is a number used to identify a network interface on a computer on a local network or the Internet. In the currently most widespread version of IP (IPv4), this number is encoded in 32 bits, and is usually represented as 4 numbers separated by periods (e.g. <literal>192.168.0.1</literal>), each number being between 0 and 255 (inclusive, which corresponds to 8 bits of data). The next version of the protocol, IPv6, extends this addressing space to 128 bits, and the addresses are generally represented as a series of hexadecimal numbers separated by colons (e.g., 2001:0db8:13bb:0002:0000:0000:0000:0020, or 2001:db8:13bb:2::20 for short)."
msgstr "IP地址是一串数字，用来识别本地网络或Internet上计算机的网络接口。在目前使用最广泛的IPV4版本中，这串数字由32位二进制数组成，通常表示为以点分隔的4个十进制数字表示（如 <literal>192.168.0.1</literal>），每个数字介于0-255之间（包含本身，对应8位的数据）。IP的下一代版本是IPV6，采用128位二进制数规定一个地址。其地址常用冒号分隔的16进制数字书写 (如 2001:0db8:13bb:0002:0000:0000:0000:0020，或以 2001:db8:13bb:2::20 简化表示)。"

msgid "<primary>subnet</primary>"
msgstr "<primary>子网</primary>"

msgid "<primary>mask</primary><secondary>subnet mask</secondary>"
msgstr "<primary>掩码</primary><secondary>子网掩码</secondary>"

msgid "<primary>network</primary><secondary>address</secondary>"
msgstr "<primary>网络</primary><secondary>地址</secondary>"

msgid "A subnet mask (netmask) defines in its binary code which portion of an IP address corresponds to the network, the remainder specifying the machine. In the example of configuring a static IPv4 address given here, the subnet mask, <literal>255.255.255.0</literal> (24 “1”s followed by 8 “0”s in binary representation) indicates that the first 24 bits of the IP address correspond to the network address, and the other 8 are specific to the machine. In IPv6, for readability, only the number of “1”s is expressed; the netmask for an IPv6 network could, thus, be <literal>64</literal>."
msgstr "子网掩码（网络掩码）通过二进制码来定义IP地址中哪些部分对应网络，剩余部分则对应主机。在这里给出的配置静态IPv4地址的例子中，子网掩码是<literal>255.255.255.0</literal>(二进制表示是24个“1”后面跟着8个“0”)表示IP地址的前24位对应于网络地址，其他8位对应主机。在IPv6中，为了可读性，只表示数字“1”；因此，IPv6网络的掩码可以是<literal>64</literal>。"

msgid "The network address is an IP address in which the part describing the machine's number is 0. The range of IPv4 addresses in a complete network is often indicated by the syntax, <emphasis>a.b.c.d/e</emphasis>, in which <emphasis>a.b.c.d</emphasis> is the network address and <emphasis>e</emphasis> is the number of bits affected to the network part in an IP address. The example network would thus be written: <literal>192.168.0.0/24</literal>. The syntax is similar in IPv6: <literal>2001:db8:13bb:2::/64</literal>."
msgstr "网络地址是主机号全为0的IP地址。一个完整网络的IP地址范围使用该语法表示：<emphasis>a.b.c.d/e</emphasis>；<emphasis>a.b.c.d</emphasis>是网络地址， <emphasis>e</emphasis>指定IP地址中网络位的长度。例如<literal>192.168.0.0/24</literal>可用于指定一个网络。IPV6的语法与之类似，示例可写作<literal>2001:db8:13bb:2::/64</literal>。"

msgid "<primary>router</primary>"
msgstr "<primary>路由器</primary>"

msgid "<primary>bridge</primary>"
msgstr "<primary>桥接</primary>"

msgid "A router is a machine that connects several networks to each other. All traffic coming through a router is guided to the correct network. To do this, the router analyzes incoming packets and redirects them according to the IP address of their destination. The router is often known as a gateway; in this configuration, it works as a machine that helps reach out beyond a local network (towards an extended network, such as the Internet)."
msgstr "路由器用来连接多个网络，所有通过路由器的流量都被引导到正确的网络。要做到这一点，路由器需要分析进入路由器的数据包，并根据目标IP地址将其重定向。路由器通常被称作网关；在这种配置下，路由器用于帮助跳出本地网络（进入外部网络，例如Internet）。"

msgid "<primary>broadcast</primary>"
msgstr "<primary>广播</primary>"

msgid "The special broadcast address connects all the stations in a network. Almost never “routed”, it only functions on the network in question. Specifically, it means that a data packet addressed to the broadcast never passes through the router."
msgstr "广播地址是一类特殊的地址，与网络中的所有主机相连。广播地址几乎从来不被“路由”，只在本地网络内发送信息。也就是说，发往广播地址的数据包从不经过路由器。"

msgid "This chapter focuses on IPv4 addresses, since they are currently the most commonly used. The details of the IPv6 protocol are approached in <xref linkend=\"sect.ipv6\" />, but the concepts remain the same."
msgstr "本章只讨论IPV4地址，因为它是目前最常用的协议。有关IPV6协议在<xref linkend=\"sect.ipv6\" />中讨论，其概念是相同的。"

msgid "The network is automatically configured during the initial installation. If Network Manager gets installed (which is generally the case for full desktop installations), then it might be that no configuration is actually required (for example, if you rely on DHCP on a wired connection and have no specific requirements). If a configuration is required (for example, for a WiFi interface), then it will create the appropriate file in <filename>/etc/NetworkManager/system-connections/</filename>."
msgstr "在初始安装时自动配置网络。如果安装了网络管理器（通常是安装完整桌面的情况），则可能实际不需要任何配置（例如，如果您依赖 DHCP 进行有线连接，并且没有特定要求）。如果需要配置（例如WiFi 接口），它将在 <filename>/etc/NetworkManager/system-connections/</filename>中创建相应的文件。"

msgid "<emphasis>NOTE</emphasis> NetworkManager"
msgstr "<emphasis>说明</emphasis> NetworkManager"

msgid "<primary><emphasis role=\"pkg\">network-manager</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">network-manager</emphasis></primary>"

msgid "If Network Manager is particularly recommended in roaming setups (see <xref linkend=\"sect.roaming-network-config\" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). If you were using ifupdown, just remember to deactivate the entries in <filename>/etc/network/interfaces</filename> that you want Network Manager to handle. <ulink type=\"block\" url=\"https://wiki.gnome.org/Projects/NetworkManager/SystemSettings\" /> <ulink type=\"block\" url=\"https://developer.gnome.org/NetworkManager/1.14/ref-settings.html\" />"
msgstr "如果在漫游设置中特别推荐Network Manager（见 <xref linkend=\"sect.roaming-network-config\" />），它完全可以用作默认网络管理工具。您可以手工创建 <filename>/etc/NetworkManager/system-connections/</filename> 中的类似 <filename>.ini</filename> 文件或通过图形工具（<command>nm-connection-editor</command>）建立计算机启动时使用的 “系统连接”。如果使用 ifupdown，则需要记住禁用 <filename>/etc/network/interfaces</filename> 中希望由 Network Manager 管理的条目。 <ulink type=\"block\" url=\"https://wiki.gnome.org/Projects/NetworkManager/SystemSettings\" /> <ulink type=\"block\" url=\"https://developer.gnome.org/NetworkManager/1.14/ref-settings.html\" />"

msgid "If Network Manager is not installed, then the installer will configure <emphasis role=\"pkg\">ifupdown</emphasis> by creating the <filename>/etc/network/interfaces</filename> file. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by the <literal>networking</literal> service. When there are many interfaces, it is good practice to keep the configuration in different files inside <filename>/etc/network/interfaces.d/</filename>."
msgstr "如果未安装 Network Manager，则安装程序会通过创建 <filename>/etc/network/interfaces</filename> 文件配置 <emphasis role=\"pkg\">ifupdown</emphasis>。 以 <literal>auto</literal> 开始的行列出在启动时 <literal>networking</literal> 服务自动配置的接口。如果有相当多的接口时，将配置放到 <filename>/etc/network/interfaces.d/</filename> 中的不同文件是更好的做法。"

msgid "In a server context, <emphasis role=\"pkg\">ifupdown</emphasis> is thus the network configuration tool that you usually get. That is why we will cover it in the next sections."
msgstr "在服务器环境中， <emphasis role=\"pkg\">ifupdown</emphasis> 通常是实际可用的网络配置工具。因此，我们将在下一节介绍它。"

msgid "<primary>network</primary><secondary>configuration</secondary>"
msgstr "<primary>网络</primary><secondary>配置</secondary>"

msgid "<primary>configuration</primary><secondary>of the network</secondary>"
msgstr "<primary>配置</primary><secondary>网络</secondary>"

msgid "<primary>interface</primary><secondary>network interface</secondary>"
msgstr "<primary>接口</primary><secondary>网络接口</secondary>"

msgid "Ethernet Interface"
msgstr "以太网接口"

msgid "If the computer has an Ethernet card, the IP network that is associated with it must be configured by choosing from one of two methods. The simplest method is dynamic configuration with DHCP, and it requires a DHCP server on the local network. It may indicate a desired hostname, corresponding to the <literal>hostname</literal> setting in the example below. The DHCP server then sends configuration settings for the appropriate network."
msgstr "电脑使用以太网卡时，必须以下列方法之一配置 IP 网络。最简单的方式是以 DHCP 动态配置，需要在本地网络有 DHCP 服务器。可能需要设置 <literal>hostname</literal> 指定主机名称。DHCP 服务器就会送出适当的网络配置。"

msgid "<primary>DHCP</primary>"
msgstr "<primary>DHCP</primary>"

msgid "DHCP configuration"
msgstr "DHCP 配置"

msgid ""
"\n"
"auto enp0s31f6\n"
"iface enp0s31f6 inet dhcp\n"
"  hostname arrakis"
msgstr "\nauto enp0s31f6\niface enp0s31f6 inet dhcp\n  hostname arrakis"

msgid "<emphasis>IN PRACTICE</emphasis> Names of network interfaces"
msgstr "<emphasis>实例</emphasis> 网络接口的名称"

msgid "<primary><literal>eth0</literal></primary>"
msgstr "<primary><literal>eth0</literal></primary>"

msgid "<primary><literal>en*</literal></primary>"
msgstr "<primary><literal>en*</literal></primary>"

msgid "<primary><literal>wlan0</literal></primary>"
msgstr "<primary><literal>wlan0</literal></primary>"

msgid "<primary><literal>wl*</literal></primary>"
msgstr "<primary><literal>wl*</literal></primary>"

msgid "By default, the kernel attributes generic names such a <literal>eth0</literal> (for wired Ethernet) or <literal>wlan0</literal> (for WiFi) to the network interfaces. The number in those names is a simple incremental counter representing the order in which they have been detected. With modern hardware, that order might change for each reboot and thus the default names are not reliable."
msgstr "默认情况下，内核给网络接口配置通用名称，如 <literal>eth0</literal>（有线以太网）或 <literal>wlan0</literal>（WiFi）。名称中的数字是根据检测顺序简单增加的计数器。对于较新的硬件，每次启动的检测顺序可能不一致，因此，默认名称不确定。"

msgid "Fortunately, systemd and udev are able to rename the interfaces as soon as they appear. The default name policy is defined by <filename>/lib/systemd/network/99-default.link</filename> (see <citerefentry><refentrytitle>systemd.link</refentrytitle><manvolnum>5</manvolnum></citerefentry> for an explanation of the <literal>NamePolicy</literal> entry in that file). In practice, the names are often based on the device's physical location (as guessed by where they are connected) and you will see names starting with <literal>en</literal> for wired ethernet and <literal>wl</literal> for WiFi. In the example above, the rest of the name indicates, in abbreviated form, a PCI (<literal>p</literal>) bus number (<literal>0</literal>), a slot number (<literal>s31</literal>), a function number (<literal>f6</literal>)."
msgstr "幸运的是，systemd 和 udev 可以在接口一出现就重命名。默认命名规则由 <filename>/lib/systemd/network/99-default.link</filename>（有关解释见 <citerefentry><refentrytitle>systemd.link</refentrytitle><manvolnum>5</manvolnum></citerefentry> 中的 <literal>NamePolicy</literal> 条目）定义。实际上，命名通常基于设备的物理位置（根据连接的位置猜测），您会看到有线以太网以 <literal>en</literal> 开头，WiFi 以 <literal>wl</literal> 开头。在上面的示例中， 名称的剩余部分以缩写的形式 the re表示，PCI 总线编号 (<literal>p0</literal>)，插槽编号 (<literal>s31</literal>)，功能编号 (<literal>f6</literal>)。"

msgid "Obviously, you are free to override this policy and/or to complement it to customize the names of some specific interfaces. You can find out the names of the network interfaces in the output of <command>ip addr</command> (or as filenames in <filename>/sys/class/net/</filename>)."
msgstr "显然，您可以自已重写此规则和/或补充一些自定义的接口名称。可以在 <command>ip addr</command> 的输出 (或 <filename>/sys/class/net/</filename>中的文件名)中找到网络接口的名称。"

msgid "In some corner cases it might be necessary to disable the consistent naming of network devices as described above. Besides changing the default <emphasis role=\"pkg\">udev</emphasis> rule it is also possible to boot the system using the <command>net.ifnames=0</command> and <command>biosdevname=0</command> kernel parameters to achieve that."
msgstr "在某些特殊情况下，可能需要禁用上面的网络设备统一命名。除了更改默认 <emphasis role=\"pkg\">udev</emphasis> 规则外，还可以使用内核参数 <command>net.ifnames=0</command> 和 <command>biosdevname=0</command> 来实现。"

msgid "A “static” configuration must indicate network settings in a fixed manner. This includes at least the IP address and subnet mask; network and broadcast addresses are also sometimes listed. A router connecting to the exterior will be specified as a gateway."
msgstr "“静态” 配置必须以固定方式指明网络设置。至少包括 IP 网址及子网掩码；有时也列出网络及广播地址。链接外部的路由器作为网关。"

msgid "Static configuration"
msgstr "静态配置"

msgid ""
"\n"
"auto enp0s31f6\n"
"iface enp0s31f6 inet static\n"
"  address 192.168.0.3/24\n"
"  broadcast 192.168.0.255\n"
"  network 192.168.0.0\n"
"  gateway 192.168.0.1"
msgstr "\nauto enp0s31f6\niface enp0s31f6 inet static\n  address 192.168.0.3/24\n  broadcast 192.168.0.255\n  network 192.168.0.0\n  gateway 192.168.0.1"

msgid "<emphasis>NOTE</emphasis> Multiple addresses"
msgstr "<emphasis>说明</emphasis> 多地址"

msgid "It is possible not only to associate several interfaces to a single, physical network card, but also several IP addresses to a single interface. Remember also that an IP address may correspond to any number of names via DNS, and that a name may also correspond to any number of numerical IP addresses."
msgstr "在一个实体网络卡上可以链接多个接口，而且可以设置多个 IP 地址。IP 地址本身可以经由 DNS 对应至多个网域名称，名称本身可以对应至多个 IP 地址。"

msgid "As you can guess, the configurations can be rather complex, but these options are only used in very special cases. The examples cited here are typical of the usual configurations."
msgstr "如您所想，配置可以极为复杂，不过只限于极为特殊的例子。此处引用的例子都是一般常见的配置。"

msgid "Wireless Interface"
msgstr "无线网络接口"

msgid "<primary>wireless</primary>"
msgstr "<primary>无线网络</primary>"

msgid "Getting wireless network cards to work can be a bit more challenging. First of all, they often require the installation of proprietary firmwares which are not installed by default in Debian. Then wireless networks rely on cryptography to restrict access to authorized users only, this implies storing some secret key in the network configuration. Let's tackle those topics one by one."
msgstr "使无线网卡工作会有一点复杂。首先，通常需要安装Debian默认未安装的合适的专有固件。然后无线网络依靠加密来限制授权用户的访问，这意味着需要在网络配置中存储一些密钥。我们一步一步讨论这些问题。"

msgid "Installing the required firmwares"
msgstr "安装需要的专有固件"

msgid "<primary>firmware</primary>"
msgstr "<primary>固件</primary>"

msgid "<primary>isenkram</primary>"
msgstr "<primary>isenkram</primary>"

msgid "First you have to enable the non-free repository in APT's sources.list file: see <xref linkend=\"sect.apt-sources.list\" /> for details about this file. Many firmware are proprietary and are thus located in this repository. You can try to skip this step if you want, but if the next step doesn't find the required firmware, retry after having enabled the non-free section."
msgstr "首先，需要启用APT sources.list 文件中的 non-free 仓库。有关此文件的详细说明见： <xref linkend=\"sect.apt-sources.list\" />。许多固件是专有的，存储在此 for det仓库中。可以尝试跳过此步，但如果在下一步中找不到需要的固件，请返回启用 non-free 仓库。"

msgid "Then you have to install the appropriate <literal>firmware-*</literal> packages. If you don't know which package you need, you can install the <emphasis role=\"pkg\">isenkram</emphasis> package and run its <command>isenkram-autoinstall-firmware</command> command. The packages are often named after the hardware manufacturer or the corresponding kernel module: <emphasis role=\"pkg\">firmware-iwlwifi</emphasis> for Intel wireless cards, <emphasis role=\"pkg\">firmware-atheros</emphasis> for Qualcomm Atheros, <emphasis role=\"pkg\">firmware-ralink</emphasis> for Ralink, etc. A reboot is then recommended because the kernel driver usually looks for the firmware files when it is first loaded and no longer afterwards."
msgstr "然后，需要安装适当的 <literal>firmware-*</literal> 包。如果您不清楚需要哪个包，可以安装 <emphasis role=\"pkg\">isenkram</emphasis> 包，然后运行 <command>isenkram-autoinstall-firmware</command> 命令。这些包通常以硬件制造商或相应内核模块命名：Intel无线网卡是 <emphasis role=\"pkg\">firmware-iwlwifi</emphasis>，Qualcomm Atheros 无线网卡是 <emphasis role=\"pkg\">firmware-atheros</emphasis>，Ralink无线网卡是 <emphasis role=\"pkg\">firmware-ralink</emphasis>，等等。建议重启计算机，因为内核驱动通常在第一次加载时查找固件文件，且之后不再执行。"

msgid "Wireless specific entries in <filename>/etc/network/interfaces</filename>"
msgstr "在 <filename>/etc/network/interfaces</filename> 中启用条目"

msgid "<primary>WPA</primary>"
msgstr "<primary>WPA</primary>"

msgid "<emphasis>ifupdown</emphasis> is able to manage wireless interfaces but it needs the help of the <emphasis role=\"pkg\">wpasupplicant</emphasis> package which provides the required integration between <emphasis>ifupdown</emphasis> and the <command>wpa_supplicant</command> command used to configure the wireless interfaces (when using WPA/WPA2 encryption). The usual entry in <filename>/etc/network/interfaces</filename> needs to be extended with two supplementary parameters to specify the name of the wireless network (aka its SSID) and the <emphasis>Pre-Shared Key</emphasis> (PSK)."
msgstr "<emphasis>ifupdown</emphasis> 能够管理无线网络接口，但仍需要 <emphasis role=\"pkg\">wpasupplicant</emphasis> 包帮助连接，该包提供 <emphasis>ifupdown</emphasis> 管理无线网络接口需要的 <command>wpa_supplicant</command> 命令（使用 WPA/WPA2 加密时）。通常需要在 <filename>/etc/network/interfaces</filename> 中的条目添加两个扩展参数来指定无线网络的名称（也称为 SSID）和 <emphasis>预共享密钥</emphasis> (PSK)。"

msgid "DHCP configuration for a wireless interface"
msgstr "无线网络接口的DHCP配置"

msgid ""
"\n"
"auto wlp4s0\n"
"iface wlp4s0 inet dhcp\n"
"  wpa-ssid Falcot\n"
"  wpa-psk ccb290fd4fe6b22935cbae31449e050edd02ad44627b16ce0151668f5f53c01b"
msgstr "\nauto wlp4s0\niface wlp4s0 inet dhcp\n  wpa-ssid Falcot\n  wpa-psk ccb290fd4fe6b22935cbae31449e050edd02ad44627b16ce0151668f5f53c01b"

msgid "The <literal>wpa-psk</literal> parameter can contain either the plain text passphrase or its hashed version generated with <command>wpa_passphrase <replaceable>SSID</replaceable> <replaceable>passphrase</replaceable></command>. If you use an unencrypted wireless connection, then you should put a <literal>wpa-key-mgmt NONE</literal> and no <literal>wpa-psk</literal> entry. For more information about the possible configuration options, have a look at <filename>/usr/share/doc/wpasupplicant/README.Debian.gz</filename>."
msgstr "<literal>wpa-psk</literal> 参数包含纯文本密码短语或使用 <command>wpa_passphrase <replaceable>SSID</replaceable> <replaceable>passphrase</replaceable></command> 生成的哈希版本。如果使用未加密的无线连接，则应输入 <literal>wpa-key-mgmt NONE</literal> 及不要使用 <literal>wpa-psk</literal> 条目。关于可用配置的详细信息，请参阅 <filename>/usr/share/doc/wpasupplicant/README.Debian.gz</filename>。"

msgid "At this point, you should consider restricting the read permissions on <filename>/etc/network/interfaces</filename> to the root user only since the file contains a private key that not all users should have access to."
msgstr "此时，应将 <filename>/etc/network/interfaces</filename> 的读取权限限制为root用户，因为其中包含不是所有用户可以访问的私钥。"

msgid "<emphasis>HISTORY</emphasis> WEP encryption"
msgstr "<emphasis>历史</emphasis> WEP加密"

msgid "<primary>WEP</primary>"
msgstr "<primary>WEP</primary>"

msgid "Usage of the deprecated WEP encryption protocol is possible with the <emphasis role=\"pkg\">wireless-tools</emphasis> package. See <filename>/usr/share/doc/wireless-tools/README.Debian</filename> for instructions."
msgstr "使用 <emphasis role=\"pkg\">wireless-tools</emphasis> 包可以使用已弃用的WEP加密协议。请参阅 <filename>/usr/share/doc/wireless-tools/README.Debian</filename>。"

msgid "Connecting with PPP through a PSTN Modem"
msgstr "经由 PSTN 调制解调器的 PPP 链接"

msgid "<primary>PPP</primary>"
msgstr "<primary>PPP</primary>"

msgid "<primary>point to point</primary>"
msgstr "<primary>点对点</primary>"

msgid "<primary>connection</primary><secondary>by PSTN modem</secondary>"
msgstr "<primary>链接</primary><secondary>经由 PSTN 调制解调器</secondary>"

msgid "<primary>modem</primary><secondary>PSTN</secondary>"
msgstr "<primary>调制解调器</primary><secondary>PSTN</secondary>"

msgid "A point to point (PPP) connection establishes an intermittent connection; this is the most common solution for connections made with a telephone modem (“PSTN modem”, since the connection goes over the public switched telephone network)."
msgstr "点对点 (PPP) 链接创建断续的链接；这是电话调制解调器最常见的链接方式 (“PSTN 调制解调器”，经由公共交换电话网络)。"

msgid "A connection by telephone modem requires an account with an access provider, including a telephone number, username, password, and, sometimes the authentication protocol to be used. Such a connection is configured using the <command>pppconfig</command> tool in the Debian package of the same name. By default, it sets up a connection named <literal>provider</literal> (as in Internet service provider). When in doubt about the authentication protocol, choose <emphasis>PAP</emphasis>: it is offered by the majority of Internet service providers."
msgstr "电话调制解调器需要帐号才能链接，包括电话号码、用户名、密码、以及认证协定。这种链接 Debian 使用同名软件包 里的 <command>pppconfig</command> 工具。缺省使用的名称是 <literal>provider</literal> (作为互联网服务提供者)。对认证协定有疑义时，选择 <emphasis>PAP</emphasis>：大多数互联网服务提供者使用它。"

msgid "<primary><command>pppconfig</command></primary>"
msgstr "<primary><command>pppconfig</command></primary>"

msgid "<primary>PAP</primary>"
msgstr "<primary>PAP</primary>"

msgid "After configuration, it is possible to connect using the <command>pon</command> command (giving it the name of the connection as a parameter, when the default value of <literal>provider</literal> is not appropriate). The link is disconnected with the <command>poff</command> command. These two commands can be executed by the root user, or by any other user, provided they are in the <literal>dip</literal> group."
msgstr "配置之后，就可以使用 <command>pon</command> 命令 (<literal>provider</literal> 的默认值不适用时，将链接的名称当成参数)。以 <command>poff</command> 命令断线。这两个令可以由root用户或者在 <literal>dip</literal> 群组的其他用户运行。"

msgid "<primary><command>pon</command></primary>"
msgstr "<primary><command>pon</command></primary>"

msgid "<primary><command>poff</command></primary>"
msgstr "<primary><command>poff</command></primary>"

msgid "Connecting through an ADSL Modem"
msgstr "以 ADSL 调制解调器链接"

msgid "<primary>connection</primary><secondary>by ADSL modem</secondary>"
msgstr "<primary>链接</primary><secondary>经由 ADSL 调制解调器</secondary>"

msgid "<primary>modem</primary><secondary>ADSL</secondary>"
msgstr "<primary>调制解调器</primary><secondary>ADSL</secondary>"

msgid "<primary>ADSL, modem</primary>"
msgstr "<primary>ADSL，调制解调器</primary>"

msgid "The generic term “ADSL modem” covers a multitude of devices with very different functions. The modems that are simplest to use with Linux are those that have an Ethernet interface (and not only a USB interface). These tend to be popular; most ADSL Internet service providers lend (or lease) a “box” with Ethernet interfaces. Depending on the type of modem, the configuration required can vary widely."
msgstr "“ADSL 调制解调器” 一词包括不同功能的多种设备。Linux 使用的调制解调器有以太网接口 (不只是 USB 接口)。这是极为普遍的调制解调器；大部份的 ADSL 互联网服务商出借 (或出租) 一个含以太网接口的 “盒子”。视其类型而有不同的设置。"

msgid "Modems Supporting PPPOE"
msgstr "支持 PPPOE 的调制解调器"

msgid "<primary>PPPOE</primary>"
msgstr "<primary>PPPOE</primary>"

msgid "<primary><command>pppoeconf</command></primary>"
msgstr "<primary><command>pppoeconf</command></primary>"

msgid "Some Ethernet modems work with the PPPOE protocol (Point to Point Protocol over Ethernet). The <command>pppoeconf</command> tool (from the package with the same name) will configure the connection. To do so, it modifies the <filename>/etc/ppp/peers/dsl-provider</filename> file with the settings provided and records the login information in the <filename>/etc/ppp/pap-secrets</filename> and <filename>/etc/ppp/chap-secrets</filename> files. It is recommended to accept all modifications that it proposes."
msgstr "部份以太网调制解调器使用 PPPOE 协议 (以太网上的对等协议)。<command>pppoeconf</command> 工具 (位于同名软件包内) 将配置其链接。为此，它修改 <filename>/etc/ppp/peers/dsl-provider</filename> 文件提供的并记录在 <filename>/etc/ppp/pap-secrets</filename> 与 <filename>/etc/ppp/chap-secrets</filename> 文件的内容。建议全盘接纳所有的建议。"

msgid "Once this configuration is complete, you can open the ADSL connection with the command, <command>pon dsl-provider</command> and disconnect with <command>poff dsl-provider</command>."
msgstr "配置完成之后，以命令 <command>pon dsl-provider</command> 开启 ADSL 链接，并以命令 <command>poff dsl-provider</command> 断线。"

msgid "<primary><literal>dsl-provider</literal></primary>"
msgstr "<primary><literal>dsl-provider</literal></primary>"

msgid "<emphasis>TIP</emphasis> Starting <command>ppp</command> at boot"
msgstr "<emphasis>提示</emphasis>开机时启动 <command>ppp</command>"

msgid "<primary><command>systemd</command></primary>"
msgstr "<primary><command>systemd</command></primary>"

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "PPP connections over ADSL are, by definition, intermittent. Since they are usually not billed according to time, there are few downsides to the temptation of keeping them always open. The standard means to do so is to use the init system."
msgstr "PPP 在 ADSL 上的链接，其定义是间歇性的。因为通常不是按照连接时间收费，因此保持始终连接没有坏处。这样做的标准方法是使用 init 系统。"

msgid "With systemd, adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:"
msgstr "使用 systemd 时，为ADSL连接添加自动重新启动任务的方法是创建 “单元文件”，如 <filename>/etc/systemd/system/adsl-connection.service</filename>，内容如下："

msgid ""
"[Unit]\n"
"Description=ADSL connection\n"
"\n"
"[Service]\n"
"Type=forking\n"
"ExecStart=/usr/sbin/pppd call dsl-provider\n"
"Restart=always\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target"
msgstr "[Unit]\nDescription=ADSL connection\n\n[Service]\nType=forking\nExecStart=/usr/sbin/pppd call dsl-provider\nRestart=always\n\n[Install]\nWantedBy=multi-user.target"

msgid "Once this unit file has been defined, it needs to be enabled with <command>systemctl enable adsl-connection</command>. Then the loop can be started manually with <command>systemctl start adsl-connection</command>; it will also be started automatically on boot."
msgstr "设置这个单元文件之后，还需以 <command>systemctl enable adsl-connection</command> 命令启动它。然后用命令 <command>systemctl start adsl-connection</command> 以手动方式启动；在开机时可自动启动。"

msgid "On systems not using <command>systemd</command> (including <emphasis role=\"distribution\">Wheezy</emphasis> and earlier versions of Debian), the standard SystemV init works differently. On such systems, all that is needed is to add a line such as the following at the end of the <filename>/etc/inittab</filename> file; then, any time the connection is disconnected, <command>init</command> will reconnect it."
msgstr "在未使用 <command>systemd</command> 的系统中 (包括 <emphasis role=\"distribution\">Wheezy</emphasis> 及更早版本的 Debian)，可使用标准的 SystemV init。在这种系统里，只需在 <filename>/etc/inittab</filename> 文件加入一行；然后，在断线之后，运行 <command>init</command> 就可重新连接。"

msgid ""
"\n"
"adsl:2345:respawn:/usr/sbin/pppd call dsl-provider"
msgstr "\nadsl:2345:respawn:/usr/sbin/pppd call dsl-provider"

msgid "For ADSL connections that auto-disconnect on a daily basis, this method reduces the duration of the interruption."
msgstr "每天自动断线的 ADSL，使用这种方法可以减少中断的次数。"

msgid "Modems Supporting PPTP"
msgstr "支持 PPTP 的调制解调器"

msgid "<primary>PPTP</primary>"
msgstr "<primary>PPTP</primary>"

msgid "The PPTP (Point-to-Point Tunneling Protocol) protocol was created by Microsoft. Deployed at the beginning of ADSL, it was quickly replaced by PPPOE. If this protocol is forced on you, see <xref linkend=\"sect.pptp\" />."
msgstr "PPTP (点对点隧道协议) 协议由微软创制。部署在 ADSL 的初期，很快就被 PPPOE 取代。若被强制使用此协议，请参见 <xref linkend=\"sect.pptp\" />。"

msgid "Modems Supporting DHCP"
msgstr "支持 DHCP 的调制解调器"

msgid "When a modem is connected to the computer by an Ethernet cable (crossover cable) you typically configure a network connection by DHCP on the computer; the modem automatically acts as a gateway by default and takes care of routing (meaning that it manages the network traffic between the computer and the Internet)."
msgstr "用以太网缆线 (交叉网线) 连接电脑的调制解调器，可以在电脑以 DHCP 配置网络链接；调制解调器自动成为网关且运行路由的功能 (就是管理电脑与互联网的流量)。"

msgid "<emphasis>BACK TO BASICS</emphasis> Crossover cable for a direct Ethernet connection"
msgstr "<emphasis>基础知识</emphasis> 直接链接以太网的交叉网线"

msgid "<primary>crossover cable</primary>"
msgstr "<primary>交叉网线</primary>"

msgid "Computer network cards expect to receive data on specific wires in the cable, and send their data on others. When you connect a computer to a local network, you usually connect a cable (straight or crossover) between the network card and a repeater or switch. However, if you want to connect two computers directly (without an intermediary switch or repeater), you must route the signal sent by one card to the receiving side of the other card, and vice-versa. This is the purpose of a crossover cable, and the reason it is used."
msgstr "电脑网卡经由特定缆线接收数据，也从同样的管道送出数据。电脑连上本地网络后，通常以缆线 (直连网线或交叉网线) 连接网络上的集线器或交换器。若想直接连接两部电脑 (不经过交换器或集线器)，必须经由网卡送出数据至接收端的另个网络卡，反之亦然。这就是交叉网线的作用，以及使用它的原因。"

msgid "Note that this distinction has become almost irrelevant over time, as modern network cards are able to detect the type of cable present and adapt accordingly, so it won't be unusual that both kinds of cable will work in a given location."
msgstr "请注意，随着时间的推移，这种区别几乎变得无关紧要，因为现代网卡能够检测并相应地调整电缆的类型，因此这两种电缆在同一位置工作并不罕见。"

msgid "Most “ADSL routers” on the market can be used like this, as do most of the ADSL modems provided by Internet services providers."
msgstr "大部份的 “ADSL 路由器” 也能这么做，互联网服务供应商提供的 ADSL 调制解调器也具有此功能。"

msgid "Automatic Network Configuration for Roaming Users"
msgstr "漫游用户的网络自动配置"

msgid "<primary>network</primary><secondary>roaming configuration</secondary>"
msgstr "<primary>网络</primary><secondary>漫游配置</secondary>"

msgid "Many Falcot engineers have a laptop computer that, for professional purposes, they also use at home. The network configuration to use differs according to location. At home, it may be a wifi network (protected by a WPA key), while the workplace uses a wired network for greater security and more bandwidth."
msgstr "Falcot 公司的工程师拥有专业用的笔记本电脑，同时也在家里使用它。根据使用场所的不同，网络有不同的配置方式。在家里，可能使用 WiFi 网络 (以 WPA 密钥保护)，在工作场合则使用较安全与带宽更充足的固接网络。"

msgid "To avoid having to manually connect or disconnect the corresponding network interfaces, administrators installed the <emphasis role=\"pkg\">network-manager</emphasis> package on these roaming machines. This software enables a user to easily switch from one network to another using a small icon displayed in the notification area of their graphical desktop. Clicking on this icon displays a list of available networks (both wired and wireless), so they can simply choose the network they wish to use. The program saves the configuration for the networks to which the user has already connected, and automatically switches to the best available network when the current connection drops."
msgstr "为了避免人工链接与断线对应的网络接口，管理员在漫游机器安装 <emphasis role=\"pkg\">network-manager</emphasis> 软件包。此软件可以让用户从图形桌面的小图标在多个网络间切换。按下此图标即显示可用的网络（有线与无线连接），以选择其中之一。此程序保存曾连接网络的配置，断线时自动选择最佳的网络。"

msgid "In order to do this, the program is structured in two parts: a daemon running as root handles activation and configuration of network interfaces and a user interface controls this daemon. PolicyKit handles the required authorizations to control this program and Debian configured PolicyKit in such a way so that members of the netdev group can add or change Network Manager connections."
msgstr "为了达到这个目的，程序分为两个部份：后台守护进程配置网络接口，用户接口控制该后台进程。PolicyKit 处理必要的权限以控制此程序，然后由 Debian 配置 PolicyKit 让 netdev 群组成员可以添加或修改 Network Manager 的链接。"

msgid "Network Manager knows how to handle various types of connections (DHCP, manual configuration, local network), but only if the configuration is set with the program itself. This is why it will systematically ignore all network interfaces in <filename>/etc/network/interfaces</filename> and <filename>/etc/network/interfaces.d/</filename> for which it is not suited. Since Network Manager doesn't give details when no network connections are shown, the easy way is to delete from <filename>/etc/network/interfaces</filename> any configuration for all interfaces that must be managed by Network Manager."
msgstr "网络管理器知道如何处理各种类型的连接（DHCP、手动配置、本地网络），但只能处理程序本身的配置。这是会系统地忽略 <filename>/etc/network/interfaces</filename> 和 <filename>/etc/network/interfaces.d/</filename> 中的所有网络接口的原因。由于网络管理器在未显示网络连接时不提供详细信息，因此简单方法是从 <filename>/etc/network/interfaces</filename> 和其他配置中删除必须由网络管理器管理的网络接口的配置。"

msgid "Note that this program is installed by default when the “Desktop Environment” task is chosen during initial installation."
msgstr "注意，在初始安装阶段选择 “桌面环境”的工作，就能够缺省安装此程序。"

msgid "Setting the Hostname and Configuring the Name Service"
msgstr "设置主机名称与配置名称服务"

msgid "<primary>name</primary><secondary>attribution and resolution</secondary>"
msgstr "<primary>名称</primary><secondary>属性与解析</secondary>"

msgid "<primary>assignment of names</primary>"
msgstr "<primary>指定名称</primary>"

msgid "The purpose of assigning names to IP numbers is to make them easier for people to remember. In reality, an IP address identifies a network interface associated with a device such as a network card. Since each machine can have several network cards, and several interfaces on each card, one single computer can have several names in the domain name system."
msgstr "将 IP 数字转换为名称系方便记忆。实务上，IP 地址系用于辨识网络卡之类的网络接口设备。机器可能有多个网络卡，每个网络卡可能有多个接口，所以在网域名称系统里，一部电脑就可能有多个名称。"

msgid "Each machine is, however, identified by a main (or “canonical”) name, stored in the <filename>/etc/hostname</filename> file and communicated to the Linux kernel by initialization scripts through the <command>hostname</command> command. The current value is available in a virtual filesystem, and you can get it with the <command>cat /proc/sys/kernel/hostname</command> command."
msgstr "然而，每部机器都有辨识用的主要 (或 “规范”) 名称，保存在 <filename>/etc/hostname</filename> 文件内并以初始脚本经由 <command>hostname</command> 命令与 Linux 核心沟通。当前值保存在虚拟文件系统，可经由 <command>cat /proc/sys/kernel/hostname</command> 命令取得。"

msgid "<primary><command>hostname</command></primary>"
msgstr "<primary><command>hostname</command></primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> <filename>/proc/</filename> and <filename>/sys/</filename>, virtual filesystems"
msgstr "<emphasis>基础知识</emphasis> <filename>/proc/</filename> 与 <filename>/sys/</filename>，虚拟文件系统"

msgid "<primary><filename>/proc/</filename></primary>"
msgstr "<primary><filename>/proc/</filename></primary>"

msgid "<primary><filename>proc</filename></primary>"
msgstr "<primary><filename>proc</filename></primary>"

msgid "<primary><filename>/sys/</filename></primary>"
msgstr "<primary><filename>/sys/</filename></primary>"

msgid "<primary><filename>sys</filename></primary>"
msgstr "<primary><filename>sys</filename></primary>"

msgid "The <filename>/proc/</filename> and <filename>/sys/</filename> file trees are generated by “virtual” filesystems. This is a practical means of recovering information from the kernel (by listing virtual files) and communicating them to it (by writing to virtual files)."
msgstr "<filename>/proc/</filename> 与 <filename>/sys/</filename> 文件树系由 “虚拟” 文件系统产生。从核心 (以列出虚拟文件方式) 取得信息并与其沟通 (写入虚拟文件) 。"

msgid "<filename>/sys/</filename> in particular is designed to provide access to internal kernel objects, especially those representing the various devices in the system. The kernel can, thus, share various pieces of information: the status of each device (for example, if it is in energy saving mode), whether it is a removable device, etc. Note that <filename>/sys/</filename> has only existed since kernel version 2.6. <filename>/proc/</filename> describes the current state of the kernel: the files in this directory contain information about the processes running on the system and its hardware."
msgstr "<filename>/sys/</filename> 是特别设计提供对内核对象的访问，特别是那些表示系统设备的对象。因此，内核可以共享各种信息：每个设备的状态（如是否处于节能模式）、是否可移动设备等。注意，<filename>/sys/</filename>在内核版本 v2.6 之后才存在。<filename>/proc/</filename> 描述内核的当前状态：此目录中的文件包含有关系统上运行的进程及硬件的信息。"

msgid "Surprisingly, the domain name is not managed in the same way, but comes from the complete name of the machine, acquired through name resolution. You can change it in the <filename>/etc/hosts</filename> file; simply write a complete name for the machine there at the beginning of the list of names associated with the address of the machine, as in the following example:"
msgstr "意外的是，网域名称的管理方式不同，来自机器的完整名称，经由名称解析取得。可以在 <filename>/etc/hosts</filename> 文件内更改它；在名称清单前写入完整的名称，如下例："

msgid ""
"\n"
"127.0.0.1     localhost\n"
"192.168.0.1   arrakis.falcot.com arrakis"
msgstr "\n127.0.0.1     localhost\n192.168.0.1   arrakis.falcot.com arrakis"

msgid "<primary><filename>hosts</filename></primary>"
msgstr "<primary><filename>主机</filename></primary>"

msgid "<primary><filename>/etc/hosts</filename></primary>"
msgstr "<primary><filename>/etc/hosts</filename></primary>"

msgid "<primary>domain</primary><secondary>name</secondary>"
msgstr "<primary>网域</primary><secondary>名称</secondary>"

msgid "<primary>name</primary><secondary>domain</secondary>"
msgstr "<primary>名称</primary><secondary>网域</secondary>"

msgid "<primary>NSS</primary>"
msgstr "<primary>NSS</primary>"

msgid "Name Resolution"
msgstr "名称解析"

msgid "<primary>resolution</primary><secondary>name</secondary>"
msgstr "<primary>解析</primary><secondary>名称</secondary>"

msgid "<primary>name</primary><secondary>resolution</secondary>"
msgstr "<primary>名称</primary><secondary>解析</secondary>"

msgid "The mechanism for name resolution in Linux is modular and can use various sources of information declared in the <filename>/etc/nsswitch.conf</filename> file. The entry that involves host name resolution is <literal>hosts</literal>. By default, it contains <literal>files dns</literal>, which means that the system consults the <filename>/etc/hosts</filename> file first, then DNS servers. NIS/NIS+ or LDAP servers are other possible sources."
msgstr "Linux 的名称解析机制是模块化的且可使用 <filename>/etc/nsswitch.conf</filename> 宣称的数据源。涉及主机名称解析的条目是 <literal>hosts</literal>。默认情况下，它包括 <literal>files dns</literal>，表示系统先参照 <filename>/etc/hosts</filename> 文件，再参照 DNS 服务器。NIS/NIS+ 或 LDAP 服务器是另一个来源选择。"

msgid "<emphasis>NOTE</emphasis> NSS and DNS"
msgstr "<emphasis>说明</emphasis> NSS 与 DNS"

msgid "Be aware that the commands specifically intended to query DNS (especially <command>host</command>) do not use the standard name resolution mechanism (NSS). As a consequence, they do not take into consideration <filename>/etc/nsswitch.conf</filename>, and thus, not <filename>/etc/hosts</filename> either."
msgstr "专门用于查找 DNS 的命令(特别是 <command>host</command>)，未使用标准的名称解析机制 (NSS)。也就是说，完全未考虑 <filename>/etc/nsswitch.conf</filename>，也不使用 <filename>/etc/hosts</filename>。"

msgid "Configuring DNS Servers"
msgstr "配置 DNS 服务器"

msgid "<primary>DNS</primary>"
msgstr "<primary>DNS</primary>"

msgid "<primary>Domain Name Service</primary>"
msgstr "<primary>网域名称服务</primary>"

msgid "DNS (Domain Name Service) is a distributed and hierarchical service mapping names to IP addresses, and vice-versa. Specifically, it can turn a human-friendly name such as <literal>www.eyrolles.com</literal> into the actual IP address, <literal>213.244.11.247</literal>."
msgstr "DNS (网域名称服务) 是映射名称至 IP 地址的分布式分级服务，同时也反向映射。尤其是，把可阅读的名称，如 <literal>www.eyrolles.com</literal> 映射至实际的 IP 地址 <literal>213.244.11.247</literal>。"

msgid "To access DNS information, a DNS server must be available to relay requests. Falcot Corp has its own, but an individual user is more likely to use the DNS servers provided by their ISP."
msgstr "必须先设置 DNS 服务器，才能用到 DNS 信息。Falcot 公司自设该服务器，但个人用户可能使用 ISP 提供的 DNS 服务器。"

msgid "<primary><filename>resolv.conf</filename></primary>"
msgstr "<primary><filename>resolv.conf</filename></primary>"

msgid "<primary><literal>nameserver</literal></primary>"
msgstr "<primary><literal>nameserver</literal></primary>"

msgid "The DNS servers to be used are indicated in the <filename>/etc/resolv.conf</filename>, one per line, with the <literal>nameserver</literal> keyword preceding an IP address, as in the following example:"
msgstr "DNS 服务器的用法在 <filename>/etc/resolv.conf</filename> 内，每个一列，在 IP 地址前有 <literal>nameserver</literal> 关键词，如下："

msgid ""
"\n"
"nameserver 212.27.32.176\n"
"nameserver 212.27.32.177\n"
"nameserver 8.8.8.8"
msgstr ""
"\n"
"nameserver 212.27.32.176\n"
"nameserver 212.27.32.177\n"
"nameserver 8.8.8.8"

msgid "Note that the <filename>/etc/resolv.conf</filename> file may be handled automatically (and overwritten) when the network is managed by NetworkManager or configured via DHCP."
msgstr "注意，当网络由 NetworkManager 管理或经由 DHCP 配置时，可以自动处理 (与覆写) <filename>/etc/resolv.conf</filename> 文件。"

msgid "The <filename>/etc/hosts</filename> file"
msgstr "<filename>/etc/hosts</filename> 文件"

msgid "If there is no name server on the local network, it is still possible to establish a small table mapping IP addresses and machine hostnames in the <filename>/etc/hosts</filename> file, usually reserved for local network stations. The syntax of this file as described in <citerefentry><refentrytitle>hosts</refentrytitle> <manvolnum>5</manvolnum></citerefentry> is very simple: each line indicates a specific IP address followed by the list of any associated names (the first being “completely qualified”, meaning it includes the domain name)."
msgstr "在本地网络没有名称服务器时，仍可以在保留给本地网络的 <filename>/etc/hosts</filename> 文件内，创建 IP 地址与主机名称的小型对照表。此文件的语法在 <citerefentry><refentrytitle>hosts</refentrytitle> <manvolnum>5</manvolnum></citerefentry> 中说明，极简单：每列一个固定 IP 地址，然后是相关的名称 (第一个是 “完全合格”，表示包括网域名称)。"

msgid "This file is available even during network outages or when DNS servers are unreachable, but will only really be useful when duplicated on all the machines on the network. The slightest alteration in correspondence will require the file to be updated everywhere. This is why <filename>/etc/hosts</filename> generally only contains the most important entries."
msgstr "即使网络停摆或 DNS 服务器不通仍可使用此文件，但只适用于本地网络所有机器都复制的内容。即使是极微小的变动，都需要更新各地所有的文件。所以， <filename>/etc/hosts</filename> 通常只包括最重要的条目。"

msgid "This file will be sufficient for a small network not connected to the Internet, but with 5 machines or more, it is recommended to install a proper DNS server."
msgstr "这个文件对未连上互联网的小型网络是够用的，但对于5 部以及以上的机器，推荐安装一个 DNS 服务器。"

msgid "<emphasis>TIP</emphasis> Bypassing DNS"
msgstr "<emphasis>秘诀</emphasis> 绕过 DNS"

msgid "Since applications check the <filename>/etc/hosts</filename> file before querying DNS, it is possible to include information in there that is different from what the DNS would return, and therefore to bypass normal DNS-based name resolution."
msgstr "某些应用程序先检查 <filename>/etc/hosts</filename> 文件才查找 DNS，与 DNS 送回数据不同的部分，可以先保存在这里，并略过 DNS 的名称解析。"

msgid "This allows, in the event of DNS changes not yet propagated, to test access to a website with the intended name even if this name is not properly mapped to the correct IP address yet."
msgstr "修改 DNS 但尚未部署前，这种做法可以测试网站名称与 IP 地址的对应性。"

msgid "Another possible use is to redirect traffic intended for a specific host to the localhost, thus preventing any communication with the given host. For example, hostnames of servers dedicated to serving ads could be diverted which would bypass these ads resulting in more fluid, less distracting, navigation."
msgstr "另一个可能用法是把流量转移至指定的区域主机，避免大流量进入指定的主机。例如，可以绕过专供广告使用的服务器主机名称，让结果更顺畅、少些干扰。"

msgid "User and Group Databases"
msgstr "用户与群组数据库"

msgid "<primary>user</primary><secondary>database</secondary>"
msgstr "<primary>用户</primary><secondary>数据库</secondary>"

msgid "<primary>group</primary><secondary>database</secondary>"
msgstr "<primary>群组</primary><secondary>数据库</secondary>"

msgid "<primary>database</primary><secondary>of users</secondary>"
msgstr "<primary>数据库</primary><secondary>用户</secondary>"

msgid "<primary>database</primary><secondary>of groups</secondary>"
msgstr "<primary>数据库</primary><secondary>群组</secondary>"

msgid "The list of users is usually stored in the <filename>/etc/passwd</filename> file, while the <filename>/etc/shadow</filename> file stores hashed passwords. Both are text files, in a relatively simple format, which can be read and modified with a text editor. Each user is listed there on a line with several fields separated with a colon (“<literal>:</literal>”)."
msgstr "用户清单通常保存在 <filename>/etc/passwd</filename> 文件内，把哈希编码后的密码保存在 <filename>/etc/shadow</filename> 文件内。这两个文件都是纯文本档，以简单的格式保存，可以用文本编辑器读取与修改。每个用户占一行，其字段以冒号分隔 (“<literal>:</literal>”)。"

msgid "<emphasis>NOTE</emphasis> Editing system files"
msgstr "<emphasis>说明</emphasis> 编辑系统文件"

msgid "The system files mentioned in this chapter are all plain text files, and can be edited with a text editor. Considering their importance to core system functionality, it is always a good idea to take extra precautions when editing system files. First, always make a copy or backup of a system file before opening or altering it. Second, on servers or machines where more than one person could potentially access the same file at the same time, take extra steps to guard against file corruption."
msgstr "本章讨论的系统文件都是纯文本档，可以用文本编辑器处理。这些文件对内核系统的运作极为重要，编辑该等文件时多加慎重不会错的。首先，先复制或备份原文件。第二，在服务器或多人可同时使用该等文件的机器上，多费心以防止文件损坏。"

msgid "For this purpose, it is enough to use the <command>vipw</command> command to edit the <filename>/etc/passwd</filename> file, or <command>vigr</command> to edit <filename>/etc/group</filename>. These commands lock the file in question prior to running the text editor, (<command>vi</command> by default, unless the <varname>EDITOR</varname> environment variable has been altered). The <literal>-s</literal> option in these commands allows editing the corresponding <foreignphrase>shadow</foreignphrase> file."
msgstr "为了达成此目标，最好使用 <command>vipw</command> 命令编辑 <filename>/etc/passwd</filename> 文件，或使用 <command>vigr</command> 命令编辑 <filename>/etc/group</filename> 文件。这些命令会先锁住该文件再运行文本编辑器， (缺省使用 <command>vi</command> 命令，除非 <varname>EDITOR</varname> 环境变量有其他的设置)。加上 <literal>-s</literal> 选项可同时编辑对应的 <foreignphrase>shadow</foreignphrase> 文件。"

msgid "<emphasis>BACK TO BASICS</emphasis> Crypt, a one-way function"
msgstr "<emphasis>基础知识</emphasis> Crypt，单向的函数"

msgid "<primary>crypt</primary>"
msgstr "<primary>crypt</primary>"

msgid "<command>crypt</command> is a one-way function that transforms a string (<varname>A</varname>) into another string (<varname>B</varname>) in a way that <varname>A</varname> cannot be derived from <varname>B</varname>. The only way to identify <varname>A</varname> is to test all possible values, checking each one to determine if transformation by the function will produce <varname>B</varname> or not. It uses up to 8 characters as input (string <varname>A</varname>) and generates a string of 13, printable, ASCII characters (string <varname>B</varname>)."
msgstr "<command>crypt</command> 是单向函数以特别的方法把字符串 (<varname>A</varname>) 转换成另个字符串 (<varname>B</varname>)，转换后无法经由 <varname>B</varname> 恢复成 <varname>A</varname> 。辨识 <varname>A</varname> 的唯一方法是逐一测试所有可能的值，查验等同于 <varname>B</varname> 的结果。最多可输入 8 个字符 (字符串 <varname>A</varname>) 然后产生 13 个字符的可打印 ASCII 字符 (字符串 <varname>B</varname>)。"

msgid "User List: <filename>/etc/passwd</filename>"
msgstr "用户清单：<filename>/etc/passwd</filename>"

msgid "Here is the list of fields in the <filename>/etc/passwd</filename> file:"
msgstr "在 <filename>/etc/passwd</filename> 文件内的字段清单："

msgid "<primary><command>passwd</command></primary>"
msgstr "<primary><command>passwd</command></primary>"

msgid "<primary><filename>/etc/passwd</filename></primary>"
msgstr "<primary><filename>/etc/passwd</filename></primary>"

msgid "<primary><literal>uid</literal></primary>"
msgstr "<primary><literal>uid</literal></primary>"

msgid "<primary><literal>gid</literal></primary>"
msgstr "<primary><literal>gid</literal></primary>"

msgid "<primary><literal>GECOS</literal></primary>"
msgstr "<primary><literal>GECOS</literal></primary>"

msgid "<primary><literal>login</literal></primary>"
msgstr "<primary><literal>login</literal></primary>"

msgid "login, for example <literal>rhertzog</literal>;"
msgstr "登录，例如 <literal>rhertzog</literal>;"

msgid "password: this is a password encrypted by a one-way function (<command>crypt</command>), relying on <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> or <literal>SHA-512</literal>. The special value “<literal>x</literal>” indicates that the encrypted password is stored in <filename>/etc/shadow</filename>;"
msgstr "密码：就是通过单向函数 (<command>crypt</command>)，使用 <literal>DES</literal>、<literal>MD5</literal>、<literal>SHA-256</literal> 或 <literal>SHA-512</literal> 加密后的密码。以特别符号 “<literal>x</literal>” 表示加密后的密码保存在<filename>/etc/shadow</filename>;"

msgid "<literal>uid</literal>: unique number identifying each user;"
msgstr "<literal>uid</literal>：用于辨识用户的不重复数字;"

msgid "<literal>gid</literal>: unique number for the user's main group (Debian creates a specific group for each user by default);"
msgstr "<literal>gid</literal>：用户主要群组 (Debian 的默认值系为每个用户创建一个群组) 的不重复号码;"

msgid "<literal>GECOS</literal>: data field usually containing the user's full name;"
msgstr "<literal>GECOS</literal>：通常保存用户全名的数据栏;"

msgid "login directory, assigned to the user for storage of their personal files (the environment variable <varname>$HOME</varname> generally points here);"
msgstr "登入目录，用于保存用户的个人文件 (环境变量 <varname>$HOME</varname> 通常指向此处);"

msgid "program to execute upon login. This is usually a command interpreter (shell), giving the user free rein. If you specify <command>/bin/false</command> (which does nothing and returns control immediately), the user cannot login."
msgstr "登录时运行的程序。通常是命令解译器 (shell)，若指定为 <command>/bin/false</command> (不做任何事并立即回到控制)，则用户无法登录。"

msgid "<emphasis>BACK TO BASICS</emphasis> Unix group"
msgstr "<emphasis>基础知识</emphasis> Unix 群组"

msgid "<primary>group</primary>"
msgstr "<primary>群组</primary>"

msgid "A Unix group is an entity including several users so that they can easily share files using the integrated permission system (by benefiting from the same rights). You can also restrict use of certain programs to a specific group."
msgstr "Unix 群组是包括多个用户的实体，以集成授权系统可以共享文件 (具有同样的权限)。可以限定程序供指定的群组使用。"

msgid "The Hidden and Encrypted Password File: <filename>/etc/shadow</filename>"
msgstr "隐藏与加密的密码档：<filename>/etc/shadow</filename>"

msgid "<primary><filename>shadow</filename></primary>"
msgstr "<primary><filename>shadow</filename></primary>"

msgid "<primary><filename>/etc/shadow</filename></primary>"
msgstr "<primary><filename>/etc/shadow</filename></primary>"

msgid "The <filename>/etc/shadow</filename> file contains the following fields:"
msgstr "<filename>/etc/shadow</filename> 文件含以下的字段："

msgid "login;"
msgstr "登录;"

msgid "encrypted password;"
msgstr "加密的密码;"

msgid "several fields managing password expiration."
msgstr "管理密码期限的字段。"

msgid "<emphasis>SECURITY</emphasis> <filename>/etc/shadow</filename> file security"
msgstr "<emphasis>安全</emphasis> <filename>/etc/shadow</filename> 文件的安全"

msgid "<filename>/etc/shadow</filename>, unlike its alter-ego, <filename>/etc/passwd</filename>, cannot be read by regular users. Any hashed password stored in <filename>/etc/passwd</filename> is readable by anybody; a cracker could try to “break” (or reveal) a password by one of several “brute force” methods which, simply put, guess at commonly used combinations of characters. This attack — called a \"dictionary attack\" — is no longer possible on systems using <filename>/etc/shadow</filename>."
msgstr "<filename>/etc/shadow</filename>，不同于它的分身，<filename>/etc/passwd</filename>，不能被一般用户读取。保存在 <filename>/etc/passwd</filename> 内的哈希编码后的密码可被任何人读取；破坏者可以用 “暴力” 法破坏它们，以常见的编码字符破解。这种攻击方式 — 称为 \"字典攻击\" — 对于使用 <filename>/etc/shadow</filename> 的系统是无效的。"

msgid "<emphasis>DOCUMENTATION</emphasis> <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> and <filename>/etc/group</filename> file formats"
msgstr "<emphasis>文档</emphasis> <filename>/etc/passwd</filename>、<filename>/etc/shadow</filename> 与 <filename>/etc/group</filename> 文件格式"

msgid "These formats are documented in the following man pages: <citerefentry><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle><manvolnum>5</manvolnum></citerefentry>, and <citerefentry><refentrytitle>group</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgstr "这些格式记录在下列的手册页面：<citerefentry><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>、<citerefentry><refentrytitle>shadow</refentrytitle><manvolnum>5</manvolnum></citerefentry>、与 <citerefentry><refentrytitle>group</refentrytitle><manvolnum>5</manvolnum></citerefentry>。"

msgid "Modifying an Existing Account or Password"
msgstr "修改既有的帐号或密码"

msgid "<primary><command>chsh</command></primary>"
msgstr "<primary><command>chsh</command></primary>"

msgid "<primary><command>chfn</command></primary>"
msgstr "<primary><command>chfn</command></primary>"

msgid "<primary><command>chage</command></primary>"
msgstr "<primary><command>chage</command></primary>"

msgid "<primary>password</primary>"
msgstr "<primary>密码</primary>"

msgid "The following commands allow modification of the information stored in specific fields of the user databases: <command>passwd</command> permits a regular user to change their password, which in turn, updates the <filename>/etc/shadow</filename> file; <command>chfn</command> (CHange Full Name), reserved for the super-user (root), modifies the <literal>GECOS</literal> field. <command>chsh</command> (CHange SHell) allows the user to change their login shell; however, available choices will be limited to those listed in <filename>/etc/shells</filename>; the administrator, on the other hand, is not bound by this restriction and can set the shell to any program of their choosing."
msgstr "以下的命令允许修改用户数据库内的特定字段数据：<command>passwd</command> 允许用户更改自己的密码，并更新 <filename>/etc/shadow</filename> 文件；<command>chfn</command> (CHange Full Name)，保留给超级用户 (root) 专用，修改 <literal>GECOS</literal> 字段。<command>chsh</command> (CHange SHell) 允许用户变更自己的登录 shell，但只限列名在 <filename>/etc/shells</filename> 之内的；另一方面，管理员不受此限，且可设置任何 shell。"

msgid "Finally, the <command>chage</command> (CHange AGE) command allows the administrator to change the password expiration settings (the <literal>-l <replaceable>user</replaceable></literal> option will list the current settings). You can also force the expiration of a password using the <command>passwd -e <replaceable>user</replaceable></command> command, which will require the user to change their password the next time they log in."
msgstr "最后，<command>chage</command> (CHange AGE) 命令允许管理者变更密码的有效期 (<literal>-l <replaceable>用户</replaceable></literal> 选项列出现在的设置)。用 <command>passwd -e <replaceable>用户</replaceable></command> 命令强迫密码失效，要求用户登录时变更密码才能继续使用。"

msgid "Disabling an Account"
msgstr "帐号禁用"

msgid "<primary>Disable an account</primary>"
msgstr "<primary>禁用帐号</primary>"

msgid "<primary>account</primary><secondary>disable</secondary>"
msgstr "<primary>帐号</primary><secondary>禁用</secondary>"

msgid "You may find yourself needing to “disable an account” (lock out a user), as a disciplinary measure, for the purposes of an investigation, or simply in the event of a prolonged or definitive absence of a user. A disabled account means the user cannot login or gain access to the machine. The account remains intact on the machine and no files or data are deleted; it is simply inaccessible. This is accomplished by using the command <command>passwd -l <replaceable>user</replaceable></command> (lock). Re-enabling the account is done in similar fashion, with the <literal>-u</literal> option (unlock)."
msgstr "有时需要 “禁用一个帐号” (锁定某用户)，基于纪律考量、调查、或用户太久未登录。被禁用的帐号表示该用户不能登录或使用该机器。帐号还在机器内且文件与数据都未被删除；只是不能使用。以 <command>passwd -l <replaceable>用户</replaceable></command> (锁定) 命令就能够达成。以同样的方式使用另一个选项 <literal>-u</literal> (解锁) 就可恢复该帐号。"

msgid "<emphasis>GOING FURTHER</emphasis> NSS and system databases"
msgstr "<emphasis>进一步</emphasis> NSS 与系统数据库"

msgid "<primary>Name Service Switch</primary>"
msgstr "<primary>切换名称服务</primary>"

msgid "Instead of using the usual files to manage lists of users and groups, you could use other types of databases, such as LDAP or <command>db</command>, by using an appropriate NSS (Name Service Switch) module. The modules used are listed in the <filename>/etc/nsswitch.conf</filename> file, under the <literal>passwd</literal>, <literal>shadow</literal> and <literal>group</literal> entries. See <xref linkend=\"sect.config-nss\" /> for a specific example of the use of an NSS module by LDAP."
msgstr "除了使用文件管理用户与群组清单，还可以通过适当的 NSS (Name Service Switch 切换i昵称服务) 模块使用其他数据库类型，诸如 LDAP 或 <command>db</command>。可用的模块列在 <filename>/etc/nsswitch.conf</filename> 文件内，在 <literal>passwd</literal>、<literal>shadow</literal> 与 <literal>group</literal> 条目下。LDAP 下的 NSS 模块使用法，见 <xref linkend=\"sect.config-nss\" />。"

msgid "Group List: <filename>/etc/group</filename>"
msgstr "群组清单：<filename>/etc/group</filename>"

msgid "Groups are listed in the <filename>/etc/group</filename> file, a simple textual database in a format similar to that of the <filename>/etc/passwd</filename> file, with the following fields:"
msgstr "群组列在 <filename>/etc/group</filename> 文件内，类似 <filename>/etc/passwd</filename> 文件的纯文本数据库，包括以下的字段："

msgid "group name;"
msgstr "群组名称;"

msgid "password (optional): This is only used to join a group when one is not a usual member (with the <command>newgrp</command> or <command>sg</command> commands, see sidebar <xref linkend=\"sidebar.working-with-several-groups\" />);"
msgstr "密码 (可选)：只在加入群组时会用到 (使用 <command>newgrp</command> 或 <command>sg</command> 命令，见专栏 <xref linkend=\"sidebar.working-with-several-groups\" />);"

msgid "<literal>gid</literal>: unique group identification number;"
msgstr "<literal>gid</literal>：不重复的群组识别码;"

msgid "list of members: list of names of users who are members of the group, separated by commas."
msgstr "成员清单：属于此群组的用户名清单，以逗号分隔。"

msgid "<emphasis>BACK TO BASICS</emphasis> Working with several groups"
msgstr "<emphasis>基本知识</emphasis> 在多个群组工作"

msgid "<primary><command>newgrp</command></primary>"
msgstr "<primary><command>newgrp</command></primary>"

msgid "<primary><command>sg</command></primary>"
msgstr "<primary><command>sg</command></primary>"

msgid "<primary><command>id</command></primary>"
msgstr "<primary><command>id</command></primary>"

msgid "<primary>group</primary><secondary>change</secondary>"
msgstr "<primary>群组</primary><secondary>改变</secondary>"

msgid "Each user may be a member of many groups; one of them is their “main group”. A user's main group is, by default, created during initial user configuration. By default, each file that a user creates belongs to them, as well as to their main group. This is not always desirable; for example, when the user needs to work in a directory shared by a group other than their main group. In this case, the user needs to change their main group using one of the following commands: <command>newgrp</command>, which starts a new shell, or <command>sg</command>, which simply executes a command using the supplied alternate group. These commands also allow the user to join a group to which they do not belong. If the group is password protected, they will need to supply the appropriate password before the command is executed."
msgstr "用户可能加入多个群组；其中一个是 “主群组”。用户自己的主群组默认是初始化用户配置时自动产生的。默认情况下，用户添加的文件自动属于该用户，以及其主群组。这种方式并不重视可取的；例如，用户需要在自己主群组文件夹之外工作，与其他群组共享其文件。在这种情况下，用户需以命令：<command>newgrp</command> 变更其主要群组，启动新的 shell，或以 <command>sg</command> 命令，使用其他群组执行一个命令。这些命令也允许用户加入其他群组。若该群组受密码保护，则需先取得密码才能运行该等命令。"

msgid "Alternatively, the user can set the <literal>setgid</literal> bit on the directory, which causes files created in that directory to automatically belong to the correct group. For more details, see sidebar <xref linkend=\"sidebar.setgid-dir\" />."
msgstr "用户还可以设置文件夹的 <literal>setgid</literal> 位，让该文件夹内的文件自动属于特定群组。详情见专栏 <xref linkend=\"sidebar.setgid-dir\" />。"

msgid "The <command>id</command> command displays the current state of a user, with their personal identifier (<varname>uid</varname> variable), current main group (<varname>gid</varname> variable), and the list of groups to which they belong (<varname>groups</varname> variable)."
msgstr "<command>id</command> 命令显示用户的当前状态，包括个人辨识码 (<varname>uid</varname> 变量)、当前的主群组 (<varname>gid</varname> 变量)、以及其所属群组的清单 (<varname>groups</varname> 变量)。"

msgid "<primary><filename>group</filename></primary>"
msgstr "<primary><filename>group</filename></primary>"

msgid "<primary><filename>/etc/group</filename></primary>"
msgstr "<primary><filename>/etc/group</filename></primary>"

msgid "The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>gpasswd <replaceable>group</replaceable></command> changes the password for the group, while the <command>gpasswd -r <replaceable>group</replaceable></command> command deletes it."
msgstr "<command>addgroup</command> 与 <command>delgroup</command> 命令可以添加或删除群组。<command>groupmod</command> 命令修改群组的信息 (其 <literal>gid</literal> 或辨识码)。命令 <command>gpasswd <replaceable>group</replaceable></command> 可变更群组的密码，<command>gpasswd -r <replaceable>group</replaceable></command> 命令可删除群组的密码。"

msgid "<primary><command>addgroup</command></primary>"
msgstr "<primary><command>addgroup</command></primary>"

msgid "<primary><command>delgroup</command></primary>"
msgstr "<primary><command>delgroup</command></primary>"

msgid "<primary><command>groupmod</command></primary>"
msgstr "<primary><command>groupmod</command></primary>"

msgid "<primary><command>gpasswd</command></primary>"
msgstr "<primary><command>gpasswd</command></primary>"

msgid "<primary>group</primary><secondary>creation</secondary>"
msgstr "<primary>群组</primary><secondary>添加</secondary>"

msgid "<primary>creation</primary><secondary>of groups</secondary>"
msgstr "<primary>添加</primary><secondary>群组</secondary>"

msgid "<primary>group</primary><secondary>deletion</secondary>"
msgstr "<primary>群组</primary><secondary>删除</secondary>"

msgid "<primary>deletion of a group</primary>"
msgstr "<primary>删除群组</primary>"

msgid "<emphasis>TIP</emphasis> <command>getent</command>"
msgstr "<emphasis>秘诀</emphasis> <command>getent</command>"

msgid "<primary><command>getent</command></primary>"
msgstr "<primary><command>getent</command></primary>"

msgid "The <command>getent</command> (get entries) command checks the system databases the standard way, using the appropriate library functions, which in turn call the NSS modules configured in the <filename>/etc/nsswitch.conf</filename> file. The command takes one or two arguments: the name of the database to check, and a possible search key. Thus, the command <command>getent passwd rhertzog</command> will give the information from the user database regarding the user <literal>rhertzog</literal>."
msgstr "<command>getent</command> (get entries) 命令使用适当的程序库函数，调用配置于 <filename>/etc/nsswitch.conf</filename> 文件的 NSS 模块，以标准方式检查系统数据库。此命令需要一个或两个参数：被检查的数据库名称、以及可能的搜索键词。因此，<command>getent passwd rhertzog</command> 命令将从用户 <literal>rhertzog</literal> 中给予用户数据库。"

msgid "Creating Accounts"
msgstr "添加帐号"

msgid "<primary>account</primary><secondary>creation</secondary>"
msgstr "<primary>帐号</primary><secondary>添加</secondary>"

msgid "<primary>creation</primary><secondary>of user accounts</secondary>"
msgstr "<primary>添加</primary><secondary>用户帐号</secondary>"

msgid "One of the first actions an administrator needs to do when setting up a new machine is to create user accounts. This is typically done using the <command>adduser</command> command which takes a user-name for the new user to be created, as an argument."
msgstr "设置新机器后管理者需做的第一件事就是添加用户帐号。以 <command>adduser</command> 命令添加用户的名称，作为其参数。"

msgid "<primary><command>adduser</command></primary>"
msgstr "<primary><command>adduser</command></primary>"

msgid "The <command>adduser</command> command asks a few questions before creating the account, but its usage is fairly straightforward. Its configuration file, <filename>/etc/adduser.conf</filename>, includes all the interesting settings: it can be used to automatically set a quota for each new user by creating a user template, or to change the location of user accounts; the latter is rarely useful, but it comes in handy when you have a large number of users and want to divide their accounts over several disks, for instance. You can also choose a different default shell."
msgstr "<command>adduser</command> 命令在添加帐号前先询问若干问题，但其使用方式相当直观。 <filename>/etc/adduser.conf</filename> 是它的配置档，包括有趣的设置：可用于自动设置用户的配额、或改变用户帐号的位置；后者较少使用，但有多个用户且需分隔帐号于若干硬盘时，就是很好用的工具。也可选择不同的 shell 为默认值。"

msgid "<emphasis>BACK TO BASICS</emphasis> Quota"
msgstr "<emphasis>基本知识</emphasis> 额度"

msgid "<primary>quota</primary>"
msgstr "<primary>额度</primary>"

msgid "The term “quota” refers to a limit on machine resources that a user is allowed to use. This frequently refers to disk space."
msgstr "“额度” 指的是用户在此机器可使用的资源上限。通常指的是磁盘空间。"

msgid "The creation of an account populates the user's home directory with the contents of the <filename>/etc/skel/</filename> template. This provides the user with a set of standard directories and configuration files."
msgstr "添加帐号时，把用户的家目录设置为与 <filename>/etc/skel/</filename> 模板目录相同。这样可以提供给用户一组标准的文件夹与配置文件。"

msgid "<primary>group</primary><secondary>add a user</secondary>"
msgstr "<primary>群组</primary><secondary>添加用户</secondary>"

msgid "<primary>add a user to a group</primary>"
msgstr "<primary>添加群组的用户</primary>"

msgid "In some cases, it will be useful to add a user to a group (other than their default “main” group) in order to grant them additional permissions. For example, a user who is included in the <emphasis>audio</emphasis> group can access audio devices (see sidebar <xref linkend=\"sidebar.special-files\" />). This can be achieved with a command such as <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command>."
msgstr "有的时候，把用户加入群组 (除了缺省的 “主要” 群组) 以取得额外的权限。例如，在 <emphasis>audio</emphasis> 群组内的用户可以使用该群组内的音效设备 (见专栏 <xref linkend=\"sidebar.special-files\" />)。以 <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command> 命令就能把用户加入该群组。"

msgid "<emphasis>BACK TO BASICS</emphasis> Device access permissions"
msgstr "<emphasis>基本知识</emphasis> 设备访问权限"

msgid "<primary>device</primary><secondary>access permissions</secondary>"
msgstr "<primary>设备</primary><secondary>访问权限</secondary>"

msgid "<primary>file</primary><secondary>special</secondary>"
msgstr "<primary>文件</primary><secondary>特别</secondary>"

msgid "<primary>mode</primary><secondary>character</secondary>"
msgstr "<primary>模式</primary><secondary>字符</secondary>"

msgid "<primary>mode</primary><secondary>block</secondary>"
msgstr "<primary>模式</primary><secondary>区块</secondary>"

msgid "<primary>block, mode</primary>"
msgstr "<primary>区块，模块</primary>"

msgid "<primary>character, mode</primary>"
msgstr "<primary>字符，模式</primary>"

msgid "<primary>special, file</primary>"
msgstr "<primary>特别，文件</primary>"

msgid "<primary><command>mknod</command></primary>"
msgstr "<primary><command>mknod</command></primary>"

msgid "Each hardware peripheral device is represented under Unix with a special file, usually stored in the file tree under <filename>/dev/</filename> (DEVices). Two types of special files exist according to the nature of the device: “character mode” and “block mode” files, each mode allowing for only a limited number of operations. While character mode limits interaction with read/write operations, block mode also allows seeking within the available data. Finally, each special file is associated with two numbers (“major” and “minor”) that identify the device to the kernel in a unique manner. Such a file, created by the <command>mknod</command> command, simply contains a symbolic (and more human-friendly) name."
msgstr "在 Unix 之下，每个周边硬件设备都是一个保存在 <filename>/dev/</filename> (DEVices) 的特别文件。根据设备的特性有两种特别文件：“字符模式” 与 “区块模式” 文件，每个模式都只有固定数量的操作。字符模式限制读/写操作，区块模式还允许搜索可得的数据。最后，每个特别文件有两个数字 (“主要” 与 “次要”) 供内核辨识该设备。这种文件以 <command>mknod</command> 命令添加，包括符号名称 (人类可以理解的符号)。"

msgid "The permissions of a special file map to the permissions necessary to access the device itself. Thus, a file such as <filename>/dev/mixer</filename>, representing the audio mixer, only has read/write permissions for the root user and members of the <literal>audio</literal> group. Only these users can operate the audio mixer."
msgstr "特别文件的权限映射至设备本身的访问权限。因此，<filename>/dev/mixer</filename> 这个文件代表混音器，只有root用户与 <literal>audio</literal> 群组的用户拥有读/取权限。且只有该用户才能操作混音器。"

msgid "It should be noted that the combination of <emphasis role=\"pkg\">udev</emphasis> and <emphasis role=\"pkg\">policykit</emphasis> can add additional permissions to allow users physically connected to the console (and not through the network) to access to certain devices."
msgstr "使用 <emphasis role=\"pkg\">udev</emphasis> 与 <emphasis role=\"pkg\">policykit</emphasis> 指令，用户就可以直接操作 (不经由网络) 这些设备。"

msgid "Shell Environment"
msgstr "Shell 环境"

msgid "Command interpreters (or shells) can be a user's first point of contact with the computer, and they must therefore be rather friendly. Most of them use initialization scripts that allow configuration of their behavior (automatic completion, prompt text, etc.)."
msgstr "命令解译器 (或 shells) 是用户接触电脑的第一个点，必须足够友善。大部分的人使用初始设置的脚本配置其行为 (自动完成、提示字符等)。"

msgid "<primary>command line interface</primary>"
msgstr "<primary>命令行接口</primary>"

msgid "<primary>command interpreter</primary>"
msgstr "<primary>命令解译器</primary>"

msgid "<primary>shell</primary>"
msgstr "<primary>shell</primary>"

msgid "<primary><command>bash</command></primary>"
msgstr "<primary><command>bash</command></primary>"

msgid "<command>bash</command>, the standard shell, uses the <filename>/etc/bash.bashrc</filename> initialization script for “interactive” shells, and <filename>/etc/profile</filename> for “login” shells."
msgstr "<command>bash</command> 是标准的 shell，使用 <filename>/etc/bash.bashrc</filename> 初始脚本为 “交互” shell 初始化，并以 <filename>/etc/profile</filename> 作为 “登录” shell。"

msgid "<emphasis>BACK TO BASICS</emphasis> Login shell and (non) interactive shell"
msgstr "<emphasis>基础知识</emphasis> 登录 shell 与 (非) 交互 shell"

msgid "In simple terms, a login shell is invoked when you login to the console either locally or remotely via <command>ssh</command>, or when you run an explicit <command>bash --login</command> command. Regardless of whether it is a login shell or not, a shell can be interactive (in an <command>xterm</command>-type terminal for instance); or non-interactive (when executing a script)."
msgstr "简单地说，不论本地登录或使用 <command>ssh</command> 远程登录，或以 <command>bash --login</command> 命令登录，都启用登录 shell。在 登录或非登录 shell 里，该 shell 必须是交互的 (例如在 <command>xterm</command>-type 终端机内)；或非交互式 (执行脚本时)。"

msgid "<emphasis>DISCOVERY</emphasis> Other shells, other scripts"
msgstr "<emphasis>发现</emphasis> 其他 shells、其他脚本"

msgid "Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>tcsh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use."
msgstr "每个命令解译器有自己的语法及其配置文件。因此，<command>zsh</command> 使用 <filename>/etc/zshrc</filename> 与 <filename>/etc/zshenv</filename>；<command>tcsh</command> 使用 <filename>/etc/csh.cshrc</filename>、<filename>/etc/csh.login</filename> 与 <filename>/etc/csh.logout</filename>。程序的手册页面详述其用法。"

msgid "<primary><command>zsh</command></primary>"
msgstr "<primary><command>zsh</command></primary>"

msgid "<primary><command>tcsh</command></primary>"
msgstr "<primary><command>tcsh</command></primary>"

msgid "For <command>bash</command>, it is useful to activate “automatic completion” in the <filename>/etc/bash.bashrc</filename> file (simply uncomment a few lines)."
msgstr "<command>bash</command> 启用 <filename>/etc/bash.bashrc</filename> 文件 (未标注注释的几列) 内的 “自动补完”非常有用。"

msgid "<emphasis>BACK TO BASICS</emphasis> Automatic completion"
msgstr "<emphasis>基础知识</emphasis> 自动补完"

msgid "<primary>automatic completion</primary>"
msgstr "<primary>自动补完</primary>"

msgid "Many command interpreters provide a completion feature, which allows the shell to automatically complete a partially typed command name or argument when the user hits the <keycap>Tab</keycap> key. This lets users work more efficiently and be less error-prone."
msgstr "若干命令解译器提供补完功能，即键入命令前几个字后，用户按 <keycap>Tab</keycap> ，shell 自动补完命令名称或参数。用户的工作更有效率且更少错误。"

msgid "This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.)."
msgstr "此函数极有用并富弹性。可根据每个命令分别配置。因此，<command>apt</command> 之后的第一个参数，即使未映射任何文件 (在本例中，可能的选择为 <literal>install</literal>、<literal>remove</literal>、<literal>upgrade</literal>等)，也可根据此命令的语法构建。"

msgid "The package <emphasis role=\"pkg\">bash-completion</emphasis> contains completions for most common programs."
msgstr "软件包 <emphasis role=\"pkg\">bash-completion</emphasis> 包含大部分通用程序的自动补完内容。"

msgid "<emphasis>BACK TO BASICS</emphasis> The tilde, a shortcut to HOME"
msgstr "<emphasis>基础知识</emphasis> 波浪号（“~”），回到home文件夹的捷径"

msgid "<primary>~</primary>"
msgstr "<primary>~</primary>"

msgid "<primary>tilde</primary>"
msgstr "<primary>波浪号</primary>"

msgid "The tilde is often used to indicate the directory to which the environment variable, <varname>HOME</varname>, points (being the user's home directory, such as <filename>/home/rhertzog/</filename>). Command interpreters automatically make the substitution: <filename>~/hello.txt</filename> becomes <filename>/home/rhertzog/hello.txt</filename>."
msgstr "波浪号（“~”）通常用于表示环境变量 <varname>HOME</varname> ，指向 (就是用户的home文件夹，如 <filename>/home/rhertzog/</filename>) 的文件夹。命令解译器自动取代：<filename>~/hello.txt</filename> 就是 <filename>/home/rhertzog/hello.txt</filename>。"

msgid "The tilde also allows access to another user's home directory. Thus, <filename>~rmas/bonjour.txt</filename> is synonymous with <filename>/home/rmas/bonjour.txt</filename>."
msgstr "波浪号也可使用至另一个用户的home文件夹。因此，<filename>~rmas/bonjour.txt</filename> 等于 <filename>/home/rmas/bonjour.txt</filename>。"

msgid "In addition to these common scripts, each user can create their own <filename>~/.bashrc</filename> and <filename>~/.bash_profile</filename> to configure their shell. The most common changes are the addition of aliases; these are words that are automatically replaced with the execution of a command, which makes it faster to invoke that command. For instance, you could create the <literal>la</literal> alias for the command <command>ls -la | less</command> command; then you only have to type <command>la</command> to inspect the contents of a directory in detail."
msgstr "除了这些常见的脚本，用户还可以创建自己的 <filename>~/.bashrc</filename> 与 <filename>~/.bash_profile</filename> 来配置 shell。常见的改变是添加别名；即自动取代运行的命令，以加速命令的效率。例如，添加 <literal>la</literal> 别名取代 <command>ls -la | less</command> 命令后，只需键入 <command>la</command> 就能查看文件夹内容的详情。"

msgid "<emphasis>BACK TO BASICS</emphasis> Environment variables"
msgstr "<emphasis>基础知识</emphasis> 环境变量"

msgid "<primary>environment</primary><secondary>environment variable</secondary>"
msgstr "<primary>环境</primary><secondary>环境变量</secondary>"

msgid "<primary>variable, environment</primary>"
msgstr "<primary>变量，环境</primary>"

msgid "Environment variables allow storage of global settings for the shell or various other programs called. They are contextual (each process has its own set of environment variables) but inheritable. This last characteristic offers the possibility for a login shell to declare variables which will be passed down to all programs it executes."
msgstr "环境变量保存供 shell 或其他程序使用的全域设置。它们是与环境相关的 (每个进程都有自己的环境变量) 但可继承的。最后这个特性让登录 shell 时可以声明继承所有程序的变量。"

msgid "Setting default environment variables is an important element of shell configuration. Leaving aside the variables specific to a shell, it is preferable to place them in the <filename>/etc/environment</filename> file, since it is used by the various programs likely to initiate a shell session. Variables typically defined there include <varname>ORGANIZATION</varname>, which usually contains the name of the company or organization, and <varname>HTTP_PROXY</varname>, which indicates the existence and location of an HTTP proxy."
msgstr "设置缺省的环境变量是 shell 配置的重要工作。除了把变量指定给 shell 之外，还可以放在 <filename>/etc/environment</filename> 文件内，以供启动 shell 的其他程序使用。设置的变量通常包括 <varname>ORGANIZATION</varname>，包括公司或组织的名称；以及 <varname>HTTP_PROXY</varname>，指示 HTTP 代理服务器的位置。"

msgid "<emphasis>TIP</emphasis> All shells configured identically"
msgstr "<emphasis>秘诀</emphasis> 所有的 shell 拥有相同的配置"

msgid "Users often want to configure their login and interactive shells in the same way. To do this, they choose to interpret (or “source”) the content from <filename>~/.bashrc</filename> in the <filename>~/.bash_profile</filename> file. It is possible to do the same with files common to all users (by calling <filename>/etc/bash.bashrc</filename> from <filename>/etc/profile</filename>)."
msgstr "用户通常以相同的方式登录与交互 shell。所以，从 <filename>~/.bashrc</filename> 里的 <filename>~/.bash_profile</filename> 文件选择解译器 (或 “source”) 的内容。也可使用适用于所有用户的文件 (调用 <filename>/etc/profile</filename> 中的 <filename>/etc/bash.bashrc</filename> 文件)。"

msgid "Printer Configuration"
msgstr "打印机配置"

msgid "<primary>configuration</primary><secondary>printing</secondary>"
msgstr "<primary>配置</primary><secondary>打印</secondary>"

msgid "<primary>printing</primary><secondary>configuration</secondary>"
msgstr "<primary>打印</primary><secondary>配置</secondary>"

msgid "Printer configuration used to cause a great many headaches for administrators and users alike. These headaches are now mostly a thing of the past, thanks to CUPS, the free print server using the IPP (Internet Printing Protocol)."
msgstr "配置打印机是管理者与用户头痛的项目之一。感谢 IPP 协议 (Internet Printing Protocol) 的自由打印机服务器CUPS，这些问题已过去了。"

msgid "<primary>IPP</primary>"
msgstr "<primary>IPP</primary>"

msgid "<primary>Internet Printing Protocol</primary>"
msgstr "<primary>网络打印协议</primary>"

msgid "<primary>CUPS</primary>"
msgstr "<primary>CUPS</primary>"

msgid "Debian distributes CUPS divided between several packages. The heart of the system is the scheduler, cupsd, which is in the <emphasis role=\"pkg\">cups-daemon</emphasis> package. <emphasis role=\"pkg\">cups-client</emphasis> contains utility programs to interact with the server, cupsd. lpadmin is probably the most important utility, as it is crucial for setting up a printer, but there are also facilities to disable or enable a printer queue, view or delete print jobs and display or set printer options. The CUPS framework is based on the System V printing system, but there is a compatibility package, <emphasis role=\"pkg\">cups-bsd</emphasis>, allowing use of commands such as <command>lpr</command>, <command>lpq</command> and <command>lprm</command> from the traditional BSD printing system."
msgstr "Debian 分发的 CUPS 分布在几个软件包中。系统的核心是调度器 cupsd，在软件包 <emphasis role=\"pkg\">cups-daemon</emphasis> 中。<emphasis role=\"pkg\">cups-client</emphasis> 包含与服务 cupsd 交互的实用程序。lpadmin 可能是最重要的实用程序，对于设置打印机至关重要，同时还有启用或禁用打印机序列、查看或删除打印任务以及显示和设置打印机选项的工具。CUPS 框架基于System V打印系统，但也有一个兼容包 <emphasis role=\"pkg\">cups-bsd</emphasis>，允许使用传统的BSD打印系统命令，如 <command>lpr</command>、<command>lpq</command> 和 <command>lprm</command>。"

msgid "<primary><command>lpr</command></primary>"
msgstr "<primary><command>lpr</command></primary>"

msgid "<primary><command>lpd</command></primary>"
msgstr "<primary><command>lpd</command></primary>"

msgid "<primary><command>lpq</command></primary>"
msgstr "<primary><command>lpq</command></primary>"

msgid "<emphasis>COMMUNITY</emphasis> CUPS"
msgstr "<emphasis>社区</emphasis> CUPS"

msgid "<primary>Common Unix Printing System</primary>"
msgstr "<primary>通用 Unix 打印系统</primary>"

msgid "CUPS is a project and a trademark owned and managed by Apple, Inc. Prior to its acquisition by Apple it was known as the Commmon Unix Printing System. <ulink type=\"block\" url=\"https://www.cups.org/\" />"
msgstr "CUPS是 Apple Inc 所有和管理的项目与商标。在被 Apple Inc 收购之前，被称为通用Unix打印系统。 <ulink type=\"block\" url=\"http://www.cups.org/\" />"

msgid "The scheduler manages print jobs and these jobs traverse a filtering system to produce a file that the printer will understand and print. The filtering system is provided by the <emphasis role=\"pkg\">cups-filters</emphasis> (<ulink url=\"https://salsa.debian.org/printing-team/cups-filters\" />) package in conjunction with <emphasis role=\"pkg\">printer-driver-*</emphasis> packages. CUPS in combination with <emphasis role=\"pkg\">cups-filters</emphasis> and <emphasis role=\"pkg\">printer-driver-*</emphasis> is the basis for the Debian printing system."
msgstr "调度器管理打印作业，这些作业历遍筛选系统，以生成打印机能理解的文件并打印。筛选系统由 <emphasis role=\"pkg\">cups-filters</emphasis> (<ulink url=\"https://salsa.debian.org/printing-team/cups-filters\" />) 软件包及 <emphasis role=\"pkg\">printer-driver-*</emphasis> 软件包配合提供。CUPS与 <emphasis role=\"pkg\">cups-filters</emphasis> 和 <emphasis role=\"pkg\">printer-driver-*</emphasis> 组合成Debian打印系统的基础。"

msgid "Modern printers manufactured and sold within the last ten years are nearly always AirPrint-capable, and CUPS and cups-filters on Debian <emphasis role=\"distribution\">Buster</emphasis> have everything which is needed to take advantage of this facility on the network. In essence, these printers are IPP printers and an excellent fit for a driverless printing system, reducing the system to CUPS plus cups-filters. A printer-driver package can be dispensed with, and non-free printing software from vendors like Canon and Brother is no longer required. A USB-connected printer can take advantage of a modern printer with the <emphasis role=\"pkg\">ippusbxd</emphasis> package."
msgstr "近十年制造和销售的现代打印机几乎都具有 AirPrint 功能，Debian <emphasis role=\"distribution\">Buster</emphasis> 中的CUPS和 cups-filters on have拥有通过网络使用这一功能所需的一切设施。本质上说，这些打印机是IPP打印机，非常适合无驱动程序打印系统，可将系统还原为CUPS + cups-filters。无需打印机驱动程序包，不再需要来自Canon和Brother等供应商的 non-free 打印程序。USB连接的现代打印机可以使用 <emphasis role=\"pkg\">ippusbxd</emphasis> 包。"

msgid "The command <command>apt install cups</command> will install CUPS and cups-filters. It will also install the recommended <emphasis role=\"pkg\">printer-driver-gutenprint</emphasis> to provide a driver for a wide range of printers, but, unless the printer is being operated driverlessly, an alternative printer-driver might be needed for the particular device."
msgstr "命令 <command>apt install cups</command> 会安装CUPS和 cups-filters。也会安装建议的 <emphasis role=\"pkg\">printer-driver-gutenprint</emphasis>，为各种打印机提供驱动程序，但是，除非打印机是无需驱动程序的，否则可能需要为特定设备提供打印驱动程序。"

msgid "As a package recommended by <emphasis role=\"pkg\">cups-daemon</emphasis>, <emphasis role=\"pkg\">cups-browsed</emphasis> will be on the system and networked print queues, and modern printers can be automatically discovered and set up from their DNS-SD broadcasts (Bonjour). USB printers will have to be set up manually as described in the next paragraph."
msgstr "作为 <emphasis role=\"pkg\">cups-daemon</emphasis> 建议的软件包，<emphasis role=\"pkg\">cups-browsed</emphasis> 将在系统和网络上监测打印队列，现代的打印机可以从DNS-SD广播 (Bonjour)自动发现和设置。USB打印机必须用下面说明方式手工设置。"

msgid "The printing system is administered easily through a web interface accessible at the local address <literal>http://localhost:631/</literal>. There you can add and remove USB and network printers and administer most aspects of their behavior. Similar administration tasks can also be carried out via the graphical interface provided by a desktop environment or the <command>system-config-printer</command> graphical interface (from the homonym Debian package)."
msgstr "可经由网页接口进入本地地址 <literal>http://localhost:631/</literal> 轻松管理打印系统。可以添加或删除USB和网络打印机，以及管理其各方面行为。类似的管理也可以在桌面环境或 <command>system-config-printer</command>（Debian homonym 软件包）提供的图形界面执行。"

msgid "<primary><command>cups</command></primary><secondary>administration</secondary>"
msgstr "<primary><command>cups</command></primary><secondary>管理</secondary>"

msgid "Configuring the Bootloader"
msgstr "配置引导加载器（Bootloader）"

msgid "<primary>loader</primary><secondary>bootloader</secondary>"
msgstr "<primary>加载器</primary><secondary>引导加载器</secondary>"

msgid "<primary>bootloader</primary>"
msgstr "<primary>引导加载器</primary>"

msgid "It is probably already functional, but it is always good to know how to configure and install the bootloader in case it disappears from the Master Boot Record. This can occur after installation of another operating system, such as Windows. The following information can also help you to modify the bootloader configuration if needed."
msgstr "或许已经运作了，但最好知道如何配置与安装引导加载器，万一它不在MBR中。安装 Windows 等其他操作系统后，很可能出现这种情况。以下的信息在必要时可协助修改引导加载器的配置。"

msgid "<emphasis>BACK TO BASICS</emphasis> Master boot record"
msgstr "<emphasis>基础知识</emphasis> 主引导记录（MBR）"

msgid "<primary>MBR</primary>"
msgstr "<primary>MBR</primary>"

msgid "<primary>Master Boot Record</primary>"
msgstr "<primary>主引导记录</primary>"

msgid "The Master Boot Record (MBR) occupies the first 512 bytes of the first hard disk, and is the first thing loaded by the BIOS to hand over control to a program capable of booting the desired operating system. In general, a bootloader gets installed in the MBR, removing its previous content."
msgstr "主引导记录 (Master Boot Record, MBR) 位于第一个磁盘的最前方 512 字节，首先被 BIOS 加载，再启动操作系统。一般来说，安装引导加载器到主引导记录时，会移除之前的内容。"

msgid "Identifying the Disks"
msgstr "辨识磁盘"

msgid "<emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> and <filename>/dev/</filename>"
msgstr "<emphasis>文化</emphasis> <emphasis>udev</emphasis> 与 <filename>/dev/</filename>"

msgid "The <filename>/dev/</filename> directory traditionally houses so-called “special” files, intended to represent system peripherals (see sidebar <xref linkend=\"sidebar.special-files\" />). Once upon a time, it used to contain all special files that could potentially be used. This approach had a number of drawbacks among which the fact that it restricted the number of devices that one could use (due to the hardcoded list of names), and that it was impossible to know which special files were actually useful."
msgstr "<filename>/dev/</filename> 文件夹通常保存被称为 “特殊的” 文件，用于代表系统的周边设备 (见专栏 <xref linkend=\"sidebar.special-files\" />)。曾经纳入所有可能用到的特殊文件。这种处理方式有若干缺点，限制设备数量是其中之一，每种设备只能有一个 (因为清单名称被限制)，且不可能知道实际上该用哪个特殊文件。"

msgid "Nowadays, the management of special files is entirely dynamic and matches better the nature of hot-swappable computer devices. The kernel cooperates with <emphasis>udev</emphasis> (<xref linkend=\"sect.udev\" />) to create and delete them as needed when the corresponding devices appear and disappear. For this reason, <filename>/dev/</filename> doesn't need to be persistent and is thus a RAM-based filesystem that starts empty and contains only the relevant entries."
msgstr "如今，以动态方式管理特殊文件，并且更适合热切换电脑设备。内核与 <emphasis>udev</emphasis> (<xref linkend=\"sect.udev\" />) 合作在需要的时候添加与删除文件以映射出现或消失的设备。所以，<filename>/dev/</filename> 不需要维持不变，反而采用 RAM 保存的文件系统清除或纳入相关的条目。"

msgid "The kernel communicates lots of information about any newly added device and hands out a pair of major/minor numbers to identify it. With this <command>udevd</command> can create the special file under the name and with the permissions that it wants. It can also create aliases and perform additional actions (such as initialization or registration tasks). <command>udevd</command>'s behavior is driven by a large set of (customizable) rules."
msgstr "内核与添加的设备沟通，并发给主要/次要号码以供辨识。以 <command>udevd</command> 命令可以添加特殊文件并授权使用它。也可添加别名运行其他的工作 (诸如初始化或登录工作)。<command>udevd</command> 命令的行为由一组 (可定制) 的规则驱动。"

msgid "With dynamically assigned names, you can thus keep the same name for a given device, regardless of the connector used or the connection order, which is especially useful when you use various USB peripherals. The first partition on the first hard drive can then be called <filename>/dev/sda1</filename> for backwards compatibility, or <filename>/dev/root-partition</filename> if you prefer, or even both at the same time since <command>udevd</command> can be configured to automatically create a symbolic link."
msgstr "动态给予名称，就能够让相同的名称永远指向特定设备，不必在意链接的设备或顺序，尤其在使用 USB 周边时更为便利。第一个磁盘的第一个分区称为 <filename>/dev/sda1</filename> 可供向后兼容，喜欢的话也可称为 <filename>/dev/root-partition</filename>，或两者共用，因为 <command>udevd</command> 可以配置成自动添加符号链接。"

msgid "In ancient times, some kernel modules did automatically load when you tried to access the corresponding device file. This is no longer the case, and the peripheral's special file no longer exists prior to loading the module; this is no big deal, since most modules are loaded on boot thanks to automatic hardware detection. But for undetectable peripherals (such as very old disk drives or PS/2 mice), this doesn't work. Consider adding the modules, <literal>floppy</literal>, <literal>psmouse</literal> and <literal>mousedev</literal> to <filename>/etc/modules</filename> in order to force loading them on boot."
msgstr "过去在需要进入特定设备文件时，部分的内核模块无法自动加载。现在情况已变了，周边设备的特殊文件于加载模块时才会存在；所以问题不大，受惠于自动侦测硬件，大部分模块都可于启动时加载。但对于侦测不到的周边 (诸如极旧的磁盘驱动器或 PS/2 鼠标)，则无效。在此情况下，就需添加 <literal>floppy</literal>、<literal>psmouse</literal> 与 <literal>mousedev</literal> 等模块至 <filename>/etc/modules</filename> 才能于启动时强制加载。"

msgid "<primary>hard drive, names</primary>"
msgstr "<primary>硬盘，名称</primary>"

msgid "<primary>names</primary><secondary>of hard drives</secondary>"
msgstr "<primary>名称</primary><secondary>硬盘</secondary>"

msgid "Configuration of the bootloader must identify the different hard drives and their partitions. Linux uses “block” special files stored in the <filename>/dev/</filename> directory, for this purpose. Since Debian <emphasis role=\"distribution\">Squeeze</emphasis>, the naming scheme for hard drives has been unified by the Linux kernel, and all hard drives (IDE/PATA, SATA, SCSI, USB, IEEE 1394) are now represented by <filename>/dev/sd*</filename>."
msgstr "配置引导加载器必须辨认硬盘及其分区。Linux 使用 “block” 特殊文件保存在 <filename>/dev/</filename> 文件夹内。由 Debian <emphasis role=\"distribution\">Squeeze</emphasis> 版本开始使用源自 Linux 内核的硬盘命名架构，所有的硬盘 (IDE/PATA、SATA、SCSI、USB、IEEE 1394) 都以 <filename>/dev/sd*</filename> 表示。"

msgid "Each partition is represented by its number on the disk on which it resides: for instance, <filename>/dev/sda1</filename> is the first partition on the first disk, and <filename>/dev/sdb3</filename> is the third partition on the second disk."
msgstr "每个分区由其磁盘代号表示：如，<filename>/dev/sda1</filename> 是第一个磁盘的第一个分区，而 <filename>/dev/sdb3</filename> 是第二个磁盘的第三个分区。"

msgid "<primary>partition</primary><secondary>primary</secondary>"
msgstr "<primary>分区</primary><secondary>主要</secondary>"

msgid "<primary>partition</primary><secondary>extended</secondary>"
msgstr "<primary>分区</primary><secondary>扩展</secondary>"

msgid "<primary>partition</primary><secondary>secondary</secondary>"
msgstr "<primary>分区</primary><secondary>次要</secondary>"

msgid "<primary>partition table</primary><secondary>MS-DOS format</secondary>"
msgstr "<primary>分区表</primary><secondary>MS-DOS 格式</secondary>"

msgid "The PC architecture (or “i386”, including its younger cousin “amd64”) has long been limited to using the “MS-DOS” partition table format, which only allows four “primary” partitions per disk. To go beyond this limitation under this scheme, one of them has to be created as an “extended” partition, and it can then contain additional “secondary” partitions. These secondary partitions are numbered from 5. Thus the first secondary partition could be <filename>/dev/sda5</filename>, followed by <filename>/dev/sda6</filename>, etc."
msgstr "PC 架构 (或 “i386”，包括新出现的 “amd64”) 不再受限于使用 “MS-DOS” 分区表格式，每个磁盘可以拥有超过 4 个 “主要” 分区。在此架构下要超过此限制，必须添加 “扩展” 分区，然后就能使用添加的 “次要” 分区。这些次要分区由 5 开始编号。所以，第一个磁盘的次要分区可以是 <filename>/dev/sda5</filename>，然后是 <filename>/dev/sda6</filename>，余此类推。"

msgid "Another restriction of the MS-DOS partition table format is that it only allows disks up to 2 TiB in size, which is becoming a real problem with recent disks."
msgstr "MS-DOS 分区表格式的另一个限制是磁盘的容量不能超过 2 TiB，这成为现代磁盘的真正问题。"

msgid "<primary>GPT</primary><secondary>partition table format</secondary>"
msgstr "<primary>GPT</primary><secondary>分区表格式</secondary>"

msgid "<primary>partition table</primary><secondary>GPT format</secondary>"
msgstr "<primary>分区表</primary><secondary>GPT 格式</secondary>"

msgid "A new partition table format called GPT loosens these constraints on the number of partitions (it allows up to 128 partitions when using standard settings) and on the size of the disks (up to 8 ZiB, which is more than 8 billion terabytes). If you intend to create many physical partitions on the same disk, you should therefore ensure that you are creating the partition table in the GPT format when partitioning your disk."
msgstr "GPT 是新的分区表格式，解放对区分数的限制 (标准方式最多可以设置 128 个区分) 以及磁盘容量的限制 (最多达 8 ZiB，超过 8 百万兆字节)。若想在一个磁盘切出多个实体区分，必须以 GPT 格式添加分区表。"

msgid "It is not always easy to remember what disk is connected to which SATA controller, or in third position in the SCSI chain, especially since the naming of hotplugged hard drives (which includes among others most SATA disks and external disks) can change from one boot to another. Fortunately, <command>udev</command> creates, in addition to <filename>/dev/sd*</filename>, symbolic links with a fixed name, which you could then use if you wished to identify a hard drive in a non-ambiguous manner. These symbolic links are stored in <filename>/dev/disk/by-id</filename>. On a machine with two physical disks, for example, one could find the following:"
msgstr "不容易记得磁盘挂在 SATA 控制卡的位置，或在 SCSI 链的第三个位置，尤其是热插拔硬盘 (包括 SATA 磁盘与扩展磁盘) 可在开机时改变位置。还好，<command>udev</command> 以固定的名称，添加 <filename>/dev/sd*</filename> 以外的符号链接，就能够轻易的辨识硬盘。这种符号链接保存在 <filename>/dev/disk/by-id</filename> 之内。例如，在两个实体磁盘的机器，可以找到如下的消息："

msgid ""
"<computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l\n"
"</userinput><computeroutput>total 0\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1\n"
"[...]\n"
"mirexpress:/dev/disk/by-id# </computeroutput>"
msgstr ""
"<computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l\n"
"</userinput><computeroutput>total 0\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1\n"
"lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2\n"
"[...]\n"
"lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda\n"
"lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1\n"
"[...]\n"
"mirexpress:/dev/disk/by-id# </computeroutput>"

msgid "Note that some disks are listed several times (because they behave simultaneously as ATA disks and SCSI disks), but the relevant information is mainly in the model and serial numbers of the disks, from which you can find the peripheral file."
msgstr "同一个磁盘出现了多次 (因为它们同时做为 ATA 磁盘与 SCSI 磁盘)，但是根据磁盘的型号与序号等相关信息，就可找到对应的周边设备文件。"

msgid "The example configuration files given in the following sections are based on the same setup: a single SATA disk, where the first partition is an old Windows installation and the second contains Debian GNU/Linux."
msgstr "下面的配置根据同样的设置而来：一个 SATA 磁盘，第一个区分安装了旧的Windows系统、第二个分区安装了 Debian GNU/Linux。"

msgid "Configuring LILO"
msgstr "配置 LILO"

msgid "<primary>LILO</primary>"
msgstr "<primary>LILO</primary>"

msgid "<primary>Linux Loader</primary>"
msgstr "<primary>Linux 引导加载器</primary>"

msgid "<emphasis>LILO</emphasis> (LInux LOader) is the oldest bootloader — solid but rustic. It writes the physical address of the kernel to boot on the MBR, which is why each update to LILO (or its configuration file) must be followed by the command <command>lilo</command>. Forgetting to do so will render a system unable to boot if the old kernel was removed or replaced as the new one will not be in the same location on the disk."
msgstr "<emphasis>LILO</emphasis> (Linux 加载器，LInux LOader) 是最旧的引导加载器 — 稳定但粗糙。把启动内核的物理地址写入到MBR中，所以每次更新 LILO (或其配置文件) 都必须再运行命令 <command>lilo</command>。忘记的话，移除或更新内核后，新的内核就不在磁盘的原来位置，以致系统无法启动。"

msgid "LILO's configuration file is <filename>/etc/lilo.conf</filename>; a simple file for standard configuration is illustrated in the example below."
msgstr "LILO 的配置档是 <filename>/etc/lilo.conf</filename>；一个简单的标准配置文件示例如下。"

msgid "LILO configuration file"
msgstr "LILO 配置文件"

msgid ""
"\n"
"# The disk on which LILO should be installed.\n"
"# By indicating the disk and not a partition.\n"
"# you order LILO to be installed on the MBR.\n"
"boot=/dev/sda\n"
"# the partition that contains Debian\n"
"root=/dev/sda2\n"
"# the item to be loaded by default\n"
"default=Linux\n"
"\n"
"# the most recent kernel image\n"
"image=/vmlinuz\n"
"  label=Linux\n"
"  initrd=/initrd.img\n"
"  read-only\n"
"\n"
"# Old kernel (if the newly installed kernel doesn't boot)\n"
"image=/vmlinuz.old\n"
"  label=LinuxOLD\n"
"  initrd=/initrd.img.old\n"
"  read-only\n"
"  optional\n"
"\n"
"# only for Linux/Windows dual boot\n"
"other=/dev/sda1\n"
"  label=Windows"
msgstr ""
"\n"
"# The disk on which LILO should be installed.\n"
"# By indicating the disk and not a partition.\n"
"# you order LILO to be installed on the MBR.\n"
"boot=/dev/sda\n"
"# the partition that contains Debian\n"
"root=/dev/sda2\n"
"# the item to be loaded by default\n"
"default=Linux\n"
"\n"
"# the most recent kernel image\n"
"image=/vmlinuz\n"
"  label=Linux\n"
"  initrd=/initrd.img\n"
"  read-only\n"
"\n"
"# Old kernel (if the newly installed kernel doesn't boot)\n"
"image=/vmlinuz.old\n"
"  label=LinuxOLD\n"
"  initrd=/initrd.img.old\n"
"  read-only\n"
"  optional\n"
"\n"
"# only for Linux/Windows dual boot\n"
"other=/dev/sda1\n"
"  label=Windows"

msgid "GRUB 2 Configuration"
msgstr "GRUB 2 配置"

msgid "<primary>GRUB</primary>"
msgstr "<primary>GRUB</primary>"

msgid "<primary>GRUB 2</primary>"
msgstr "<primary>GRUB 2</primary>"

msgid "<emphasis>GRUB</emphasis> (GRand Unified Bootloader) is more recent. It is not necessary to invoke it after each update of the kernel; <emphasis>GRUB</emphasis> knows how to read the filesystems and find the position of the kernel on the disk by itself. To install it on the MBR of the first disk, simply type <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm>"
msgstr "<emphasis>GRUB</emphasis> (GRand Unified Bootloader) 是更新的引导加载器。每次更新内核后不必再运行它；<emphasis>GRUB</emphasis> 知道如何读取文件系统并找到内核在磁盘的位置。键入 <command>grub-install /dev/sda</command> 命令就能够把它安装在第一个磁盘的 MBR。<indexterm><primary><command>grub-install</command></primary></indexterm>"

msgid "<emphasis>NOTE</emphasis> Disk names for GRUB"
msgstr "<emphasis>说明</emphasis> GRUB 的磁盘名称"

msgid "GRUB can only identify hard drives based on information provided by the BIOS. <literal>(hd0)</literal> corresponds to the first disk thus detected, <literal>(hd1)</literal> the second, etc. In most cases, this order corresponds exactly to the usual order of disks under Linux, but problems can occur when you associate SCSI and IDE disks. GRUB used to store the correspondences that it detected in the file <filename>/boot/grub/device.map</filename>. GRUB avoids this problem nowadays by using UUIDs or file system labels when generating <filename>grub.cfg</filename>. However, the device map file is not obsolete yet, since it can be used to override when the current environment is different from the one on boot. If you find errors there (because you know that your BIOS detects drives in a different order), correct them manually and run <command>grub-install</command> again. <command>grub-mkdevicemap</command> can help creating a <filename>device.map</filename> file from which to start."
msgstr "GRUB 只能根据 BIOS 提供的信息辨识硬盘。<literal>(hd0)</literal> 对应侦测到的第一个磁盘、<literal>(hd1)</literal> 对应第二个磁盘等。大部分的情况下，此顺序刚好是 Linux 的磁盘顺序，同时使用 SCSI 与 IDE 磁盘时就容易出问题。GRUB 把侦测到的信息保存在 <filename>/boot/grub/device.map</filename> 文件内。GRUB在生成 <filename>grub.cfg</filename> 时使用UUID或文件系统标签解决这个问题。如果在此发现错误 (因为已知 BIOS 以不同的顺序侦测磁盘)，修正它并再次运行 <command>grub-install</command> 命令。<command>grub-mkdevicemap</command> 命令可添加 <filename>device.map</filename> 文件。"

msgid "Partitions also have a specific name in GRUB. When you use “classical” partitions in MS-DOS format, the first partition on the first disk is labeled, <literal>(hd0,msdos1)</literal>, the second <literal>(hd0,msdos2)</literal>, etc."
msgstr "分区表在 GRUB 内也有特定的名称。通常使用 MS-DOS 格式的 “经典” 分区，第一个磁盘的第一个分区标记为 <literal>(hd0,msdos1)</literal>、第二个分区标记为 <literal>(hd0,msdos2)</literal>，余此类推。"

msgid "GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/40_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd)."
msgstr "GRUB 2 的配置存在 <filename>/boot/grub/grub.cfg</filename> 内，但该文件 (在 Debian 环境下) 以其他方式产生。不可以人工方式修改它，否则在下次运行 <command>update-grub</command> 时 (更新多个软件包时需运行它)，将失去修改的内容。修改 <filename>/boot/grub/grub.cfg</filename> 文件 (例如添加给内核使用的参数或改变显示菜单的时间等) 通常经由修改 <filename>/etc/default/grub</filename> 的变量执行。添加条目至菜单时，可以新建 <filename>/boot/grub/custom.cfg</filename> 文件或修改 <filename>/etc/grub.d/40_custom</filename> 文件。更复杂的配置，可以添加或修改 <filename>/etc/grub.d</filename> 内的其他文件；这些脚本应返回配置的片断，很可能是外部程序做的修改。这些脚本将更新启动的内核：<filename>10_linux</filename> 考量安装 Linux 内核；<filename>20_linux_xen</filename> 考量 Xen 虚拟系统，而 <filename>30_os-prober</filename> 则列出其他的操作系统 (Windows、OS X、Hurd)。"

msgid "Other Configurations: Time Synchronization, Logs, Sharing Access…"
msgstr "其他配置：时间同步、日志记录、共享访问…"

msgid "The many elements listed in this section are good to know for anyone who wants to master all aspects of configuration of the GNU/Linux system. They are, however, treated briefly and frequently refer to the documentation."
msgstr "本节列出的细目对希望精通 GNU/Linux 系统配置极有帮助。这里只列出简要的内容，详情仍需参阅文档。"

msgid "Timezone"
msgstr "时区"

msgid "<primary>timezone</primary>"
msgstr "<primary>时区</primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> Symbolic links"
msgstr "<emphasis>基础知识</emphasis> 符号链接"

msgid "<primary>link</primary><secondary>symbolic</secondary>"
msgstr "<primary>链接</primary><secondary>符号</secondary>"

msgid "<primary>symbolic link</primary>"
msgstr "<primary>符号链接</primary>"

msgid "<primary><command>ln</command></primary>"
msgstr "<primary><command>ln</command></primary>"

msgid "A symbolic link is a pointer to another file. When you access it, the file to which it points is opened. Removal of the link will not cause deletion of the file to which it points. Likewise, it does not have its own set of permissions, but rather retains the permissions of its target. Finally, it can point to any type of file: directories, special files (sockets, named pipes, device files, etc.), even other symbolic links."
msgstr "符号链接是一种指向另一个文件的指针。使用时，被指向的文件就被打开。移除链接不会删除指向的文件。同样的，没有自身的授权，而是使用目标的授权。最后，可以用于任何类型的文件：文件夹、特殊文件 (socket、命名管道、设备文件等)、甚至另一个符号链接。"

msgid "The <command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> command creates a symbolic link, named <replaceable>link-name</replaceable>, pointing to <replaceable>target</replaceable>."
msgstr "<command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> 命令添加一个符号链接，命名为 <replaceable>link-name</replaceable>，指向 <replaceable>target</replaceable>。"

msgid "If the target does not exist, then the link is “broken” and accessing it will result in an error indicating that the target file does not exist. If the link points to another link, you will have a “chain” of links that turns into a “cycle” if one of the targets points to one of its predecessors. In this case, accessing one of the links in the cycle will result in a specific error (“too many levels of symbolic links”); this means the kernel gave up after several rounds of the cycle."
msgstr "若目标不存在，则链接算是 “破损” 且其使用返回错误消息指示目标文件不存在。若链接指向另一个链接，该链接又指向其前一个链接，则该链接的 “链” 形成 “循环”。在这种情况下，使用循环内的任一链接也会得到特定的错误 (“过多层的符号链接”)；经过若干循环后内核会放弃它。"

msgid "The timezone, configured during initial installation, is a configuration item for the <emphasis role=\"pkg\">tzdata</emphasis> package. To modify it, use the <command>dpkg-reconfigure tzdata</command> command, which allows you to choose the timezone to be used in an interactive manner. Its configuration is stored in the <filename>/etc/timezone</filename> file. Additionally, the corresponding file in the <filename>/usr/share/zoneinfo</filename> directory is copied into <filename>/etc/localtime</filename>; this file contains the rules governing the dates where daylight saving time is active, for countries that use it."
msgstr "初始安装时经由 <emphasis role=\"pkg\">tzdata</emphasis> 软件包配置时区。<command>dpkg-reconfigure tzdata</command> 命令以交互方式修改时区。其配置内容保存在 <filename>/etc/timezone</filename> 文件。在 <filename>/usr/share/zoneinfo</filename> 文件夹内映射的文件复制在 <filename>/etc/localtime</filename> 文件内；此文件包含管理夏令时状态日期的规则，适用于使用它的国家/地区。"

msgid "<primary><filename>timezone</filename></primary>"
msgstr "<primary><filename>timezone</filename></primary>"

msgid "<primary><filename>/etc/timezone</filename></primary>"
msgstr "<primary><filename>/etc/timezone</filename></primary>"

msgid "<primary><filename>zoneinfo</filename></primary>"
msgstr "<primary><filename>zoneinfo</filename></primary>"

msgid "<primary><filename>/usr/share/zoneinfo/</filename></primary>"
msgstr "<primary><filename>/usr/share/zoneinfo/</filename></primary>"

msgid "<primary>DST</primary>"
msgstr "<primary>DST</primary>"

msgid "<primary>daylight saving time</primary>"
msgstr "<primary>夏令时</primary>"

msgid "When you need to temporarily change the timezone, use the <varname>TZ</varname> environment variable, which takes priority over the configured system default:"
msgstr "暂时变更时区，可使用 <varname>TZ</varname> 环境变量，它的优先次序在缺省的配置档之前："

msgid "<primary><varname>TZ</varname></primary>"
msgstr "<primary><varname>TZ</varname></primary>"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>date</userinput>\n"
"<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>\n"
"<computeroutput>$ </computeroutput><userinput>TZ=\"Pacific/Honolulu\" date</userinput>\n"
"<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>date</userinput>\n"
"<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>\n"
"<computeroutput>$ </computeroutput><userinput>TZ=\"Pacific/Honolulu\" date</userinput>\n"
"<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput>"

msgid "<emphasis>NOTE</emphasis> System clock, hardware clock"
msgstr "<emphasis>说明</emphasis> 系统时钟，硬件时钟"

msgid "There are two time sources in a computer. A computer's motherboard has a hardware clock, called the “CMOS clock”. This clock is not very precise, and provides rather slow access times. The operating system kernel has its own, the software clock, which it keeps up to date with its own means (possibly with the help of time servers, see <xref linkend=\"sect.time-synchronization\" />). This system clock is generally more accurate, especially since it doesn't need access to hardware variables. However, since it only exists in live memory, it is zeroed out every time the machine is booted, contrary to the CMOS clock, which has a battery and therefore “survives” rebooting or halting of the machine. The system clock is, thus, set from the CMOS clock during boot, and the CMOS clock is updated on shutdown (to take into account possible changes or corrections if it has been improperly adjusted)."
msgstr "电脑内有两个时间来源。主板有个硬件时钟，称为 “CMOS 时钟”。这个时钟不准，访问的速度慢。操作系统内核有自己的系统时钟，以自己的方式 (可能由时间服务器协助，见 <xref linkend=\"sect.time-synchronization\" />) 保持时间的正确。此系统时钟较为准确，尤其是不需经由硬件变量就能近用。然而，系统时钟只存在于内存，开机就归零，不像 CMOS 时间钟，有电池支持，不受重新开机影响，关机时仍能 “存活”。因此，开机时，由 CMOS 时钟设置系统时钟，关机时更新 CMOS 时钟 (若被不当调整就能修正它)。"

msgid "In practice, there is a problem, since the CMOS clock is nothing more than a counter and contains no information regarding the time zone. There is a choice to make regarding its interpretation: either the system considers it runs in universal time (UTC, formerly GMT), or in local time. This choice could be a simple shift, but things are actually more complicated: as a result of daylight saving time, this offset is not constant. The result is that the system has no way to determine whether the offset is correct, especially around periods of time change. Since it is always possible to reconstruct local time from universal time and the timezone information, we strongly recommend using the CMOS clock in universal time."
msgstr "实务上有个问题，因为 CMOS 时钟只是个计数器，未含时区信息。有几个方式选择其解释方式：系统以世界标准时间 (UTC，旧称 GMT)，或当地时间看待。虽然可以简单切换，但却颇为复杂：它的偏移值不是常数。系统无法判断偏移值的正确性，尤其在时区交接。总是在世界标准时间与时区信息之间重组本地时间，强烈推荐使用 CMOS 时间为世界标准时间。"

msgid "Unfortunately, Windows systems in their default configuration ignore this recommendation; they keep the CMOS clock on local time, applying time changes when booting the computer by trying to guess during time changes if the change has already been applied or not. This works relatively well, as long as the system has only Windows running on it. But when a computer has several systems (whether it be a “dual-boot” configuration or running other systems via virtual machine), chaos ensues, with no means to determine if the time is correct. If you absolutely must retain Windows on a computer, you should either configure it to keep the CMOS clock as UTC (setting the registry key <literal>HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal</literal> to “1” as a DWORD), or use <command>hwclock --localtime --set</command> on the Debian system to set the hardware clock and mark it as tracking the local time (and make sure to manually check your clock in spring and autumn)."
msgstr "不幸的是，Windows系统缺省的配置忽视这个推荐；仍以 CMOS 时钟为本地时间，启动时猜测时区的变动。只运行单一的Windows系统时就没有问题。可是，电脑经常安装多个系统 (“双启动” 配置或在虚拟机运行其他系统)，混乱就免不了，无法决定正确的时间。必须保留Windows系统的前提下，应把 CMOS 时钟配置成 UTC (把机码 <literal>HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal</literal> 设置为 “1” 做为 DWORD)，或使用 Debian 系统的 <command>hwclock --localtime --set</command> 设置硬件时钟并标记追踪其为本地时间 (并且在春秋两季手动检查时钟的正确性)。"

msgid "Time Synchronization"
msgstr "时间同步"

msgid "<primary>time synchronization</primary>"
msgstr "<primary>时间同步</primary>"

msgid "<primary>clock</primary><secondary>synchronization</secondary>"
msgstr "<primary>时间</primary><secondary>同步</secondary>"

msgid "Time synchronization, which may seem superfluous on a computer, is very important on a network. Since users do not have permissions allowing them to modify the date and time, it is important for this information to be precise to prevent confusion. Furthermore, having all of the computers on a network synchronized allows better cross-referencing of information from logs on different machines. Thus, in the event of an attack, it is easier to reconstruct the chronological sequence of actions on the various machines involved in the compromise. Data collected on several machines for statistical purposes won't make a great deal of sense if they are not synchronized."
msgstr "时间同步，在单机时代是多余，但在网络时代却很重要。用户无权修改日期与时间，所以需要精准的时间以免混乱。尤有甚者，网络上的电脑时间同步后，有助于安排社区工作者透过全球网络互联。受到攻击时，容易依序恢复原来的运作。由多部机器收集来的统计数据，必须有同步的时间，才能发挥作用。"

msgid "<emphasis>BACK TO BASICS</emphasis> NTP"
msgstr "<emphasis>基础知识</emphasis> NTP"

msgid "<primary>NTP</primary>"
msgstr "<primary>NTP</primary>"

msgid "<primary>Network</primary><secondary>Time Protocol</secondary>"
msgstr "<primary>网络</primary><secondary>时间协议</secondary>"

msgid "NTP (Network Time Protocol) allows a machine to synchronize with others fairly accurately, taking into consideration the delays induced by the transfer of information over the network and other possible offsets."
msgstr "网络时间协议 (Network Time Protocol, NTP) 可以让机器间相当精准的同步，甚至把网络延迟及其他偏移值列入考量。"

msgid "While there are numerous NTP servers on the Internet, the more popular ones may be overloaded. This is why we recommend using the <emphasis>pool.ntp.org</emphasis> NTP server, which is, in reality, a group of machines that have agreed to serve as public NTP servers. You could even limit use to a sub-group specific to a country, with, for example, <emphasis>us.pool.ntp.org</emphasis> for the United States, or <emphasis>ca.pool.ntp.org</emphasis> for Canada, etc."
msgstr "互联网上很多 NTP 服务器可用，受欢迎的其工作量可能负荷过重。所以推荐使用 <emphasis>pool.ntp.org</emphasis> NTP 服务器，它是一组公开的 NTP 服务器。也可使用针对特定地区的次群组服务器，如 <emphasis>us.pool.ntp.org</emphasis> 系供美国使用、<emphasis>ca.pool.ntp.org</emphasis> 供加拿大使用。"

msgid "However, if you manage a large network, it is recommended that you install your own NTP server, which will synchronize with the public servers. In this case, all the other machines on your network can use your internal NTP server instead of increasing the load on the public servers. You will also increase homogeneity with your clocks, since all the machines will be synchronized on the same source, and this source is very close in terms of network transfer times."
msgstr "然而，管理大型网络时，还推荐安装与公共服务器同步的自己 NTP 服务器。同个网络上自己的机器，就能使用内部的 NTP 服务器不必增加外部公共服务器的负担。以自己的时钟增加网络内机器的同质化，同步截取与共用资源，使用共同的网络交换时间。"

msgid "For Workstations"
msgstr "工作站"

msgid "Since work stations are regularly rebooted (even if only to save energy), synchronizing them by NTP at boot is enough. To do so, simply install the <emphasis role=\"pkg\">ntpdate</emphasis> package. You can change the NTP server used if needed by modifying the <filename>/etc/default/ntpdate</filename> file."
msgstr "工作站经常需要重新开机 (虽然只是节省能源)，开机时以 NTP 同步就够了。安装 <emphasis role=\"pkg\">ntpdate</emphasis> 软件包就可以。需要更换 NTP 服务器时，再修改 <filename>/etc/default/ntpdate</filename> 文件即可。"

msgid "<primary><filename>ntpdate</filename></primary>"
msgstr "<primary><filename>ntpdate</filename></primary>"

msgid "<primary><filename>/etc/default/ntpdate</filename></primary>"
msgstr "<primary><filename>/etc/default/ntpdate</filename></primary>"

msgid "For Servers"
msgstr "服务器"

msgid "Servers are only rarely rebooted, and it is very important for their system time to be correct. To permanently maintain correct time, you would install a local NTP server, a service offered in the <emphasis role=\"pkg\">ntp</emphasis> package. In its default configuration, the server will synchronize with <emphasis>pool.ntp.org</emphasis> and provide time in response to requests coming from the local network. You can configure it by editing the <filename>/etc/ntp.conf</filename> file, the most significant alteration being the NTP server to which it refers. If the network has a lot of servers, it may be interesting to have one local time server which synchronizes with the public servers and is used as a time source by the other servers of the network."
msgstr "服务器很少重启，系统时间必须绝对精准。为了永久维持时间的正确性，必须安装由 <emphasis role=\"pkg\">ntp</emphasis> 软件包提供的 NPT 服务器。缺省的配置方式系与 <emphasis>pool.ntp.org</emphasis> 同步，且回应本地网络的请求。可以编辑 <filename>/etc/ntp.conf</filename> 文件改变原来的配置，NTP 服务器依照该文件的内容而变更。若有多个服务器，最好有一个本地时间服务器与公共的服务器同步，并做为本地网络其他服务器的同步的依据。"

msgid "<primary><emphasis role=\"pkg\">ntp</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">ntp</emphasis></primary>"

msgid "<primary>server</primary><secondary>NTP</secondary>"
msgstr "<primary>服务器</primary><secondary>NTP</secondary>"

msgid "<primary>NTP</primary><secondary>server</secondary>"
msgstr "<primary>NTP</primary><secondary>服务器</secondary>"

msgid "<emphasis>GOING FURTHER</emphasis> GPS modules and other time sources"
msgstr "<emphasis>进一步</emphasis> GPS 模块与其他时间来源"

msgid "<primary>GPS</primary>"
msgstr "<primary>GPS</primary>"

msgid "<primary>DCF-77</primary>"
msgstr "<primary>DCF-77</primary>"

msgid "If time synchronization is particularly crucial to your network, it is possible to equip a server with a GPS module (which will use the time from GPS satellites) or a DCF-77 module (which will sync time with the atomic clock near Frankfurt, Germany). In this case, the configuration of the NTP server is a little more complicated, and prior consultation of the documentation is an absolute necessity."
msgstr "如果网络对时间同步极为敏感，最好在服务器安装 GPS 模块 (从GPS卫星获取时间) 或 DCF-77 模块 (与位于德国法兰克福的原子钟同步时间 )。在这种情况下，NTP 服务器的配置就有点复杂，必须参照文档办理。"

msgid "Rotating Log Files"
msgstr "轮转日志文件"

msgid "<primary>file</primary><secondary>logs, rotation</secondary>"
msgstr "<primary>文件</primary><secondary>日志，轮转</secondary>"

msgid "<primary>logs</primary><secondary>files, rotation</secondary>"
msgstr "<primary>日志</primary><secondary>文件，轮转</secondary>"

msgid "<primary>rotation of log files</primary>"
msgstr "<primary>轮转日志文件</primary>"

msgid "<primary><command>logrotate</command></primary>"
msgstr "<primary><command>logrotate</command></primary>"

msgid "Log files can grow, fast, and it is necessary to archive them. The most common scheme is a rotating archive: the log file is regularly archived, and only the latest <replaceable>X</replaceable> archives are retained. <command>logrotate</command>, the program responsible for these rotations, follows directives given in the <filename>/etc/logrotate.conf</filename> file and all of the files in the <filename>/etc/logrotate.d/</filename> directory. The administrator may modify these files, if they wish to adapt the log rotation policy defined by Debian. The <citerefentry><refentrytitle>logrotate</refentrytitle> <manvolnum>1</manvolnum></citerefentry> man page describes all of the options available in these configuration files. You may want to increase the number of files retained in log rotation, or move the log files to a specific directory dedicated to archiving them rather than delete them. You could also send them by e-mail to archive them elsewhere."
msgstr "日志文件的增长速度很快，需要存档。最常的做法是循环存档：只保留最新的 <replaceable>X</replaceable> 部分。<command>logrotate</command> 是负责循环的程序，根据 <filename>/etc/logrotate.conf</filename> 文件内的配置，把日志文件保存在 <filename>/etc/logrotate.d/</filename> 文件夹内。管理者可以修改该文件，修改 Debian 缺省的循环政策。<citerefentry><refentrytitle>logrotate</refentrytitle> <manvolnum>1</manvolnum></citerefentry> 手册页面描述该配置可用的选项。可以在循环的过程中，增加存档的文件数，或把文件移至指定的文件夹而不是删除它们。也可以电子邮件方式邮寄到别的地方。"

msgid "The <command>logrotate</command> program is executed daily by the <command>cron</command> scheduling program (described in <xref linkend=\"sect.task-scheduling-cron-atd\" />)."
msgstr "<command>logrotate</command> 程序每日运行 <command>cron</command> 调度的要求 (详情见 <xref linkend=\"sect.task-scheduling-cron-atd\" />)。"

msgid "Sharing Administrator Rights"
msgstr "共享管理员权限"

msgid "<primary>account</primary><secondary>administrator account</secondary>"
msgstr "<primary>帐户</primary><secondary>管理员帐户</secondary>"

msgid "<primary>root</primary>"
msgstr "<primary>root</primary>"

msgid "<primary><command>sudo</command></primary>"
msgstr "<primary><command>sudo</command></primary>"

msgid "Frequently, several administrators work on the same network. Sharing the root passwords is not very elegant, and opens the door for abuse due to the anonymity such sharing creates. The solution to this problem is the <command>sudo</command> program, which allows certain users to execute certain commands with special rights. In the most common use case, <command>sudo</command> allows a trusted user to execute any command as root. To do so, the user simply executes <command>sudo <replaceable>command</replaceable></command> and authenticates using their personal password."
msgstr "数个管理者共同在同个服务器工作。共用同一个root用户密码不是好主意，匿名引发的误用很麻烦。解决方案是使用 <command>sudo</command> 程序，允许用户对特定命令拥有专门的权力。在多数情况下，<command>sudo</command> 允许受信任的用户以root的权限运行命令。用户只需运行 <command>sudo <replaceable>command</replaceable></command> 并以个人的密码通过认证。"

msgid "When installed, the <emphasis role=\"pkg\">sudo</emphasis> package gives full root rights to members of the <literal>sudo</literal> Unix group. To delegate other rights, the administrator must use the <command>visudo</command> command, which allows them to modify the <filename>/etc/sudoers</filename> configuration file (here again, this will invoke the <command>vi</command> editor, or any other editor indicated in the <varname>EDITOR</varname> environment variable). Adding a line with <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> allows the user in question to execute any command as root."
msgstr "安装的时候，<emphasis role=\"pkg\">sudo</emphasis> 软件包把完整的root权限授权给 <literal>sudo</literal> Unix 群组。管理者必须使用 <command>visudo</command> 命令授予其他权利，该命令允许用户修改 <filename>/etc/sudoers</filename> 配置档 (当然，必须启用 <command>vi</command> 编辑器，或在 <varname>EDITOR</varname> 环境变量指定的编辑器)。添加一列 <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> 就能允许该用户以 root 的授权运行命令。"

msgid "<primary><command>visudo</command></primary>"
msgstr "<primary><command>visudo</command></primary>"

msgid "<primary><filename>sudoers</filename></primary>"
msgstr "<primary><filename>sudoers</filename></primary>"

msgid "<primary><filename>/etc/sudoers</filename></primary>"
msgstr "<primary><filename>/etc/sudoers</filename></primary>"

msgid "More sophisticated configurations allow authorization of only specific commands to specific users. All the details of the various possibilities are given in the <citerefentry><refentrytitle>sudoers</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgstr "还有较复杂的配置，只允许特定用户运行部分命令。详情在 <citerefentry><refentrytitle>sudoers</refentrytitle> <manvolnum>5</manvolnum></citerefentry> 手册页面。"

msgid "List of Mount Points"
msgstr "挂载点清单"

msgid "<primary>point, mount</primary>"
msgstr "<primary>点，挂载</primary>"

msgid "<primary>mount point</primary>"
msgstr "<primary>挂载点</primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> Mounting and unmounting"
msgstr "<emphasis>基础知识</emphasis> 挂载与卸载"

msgid "In a Unix-like system such as Debian, files are organized in a single tree-like hierarchy of directories. The <filename>/</filename> directory is called the “root directory”; all additional directories are sub-directories within this root. “Mounting” is the action of including the content of a peripheral device (often a hard drive) into the system's general file tree. As a consequence, if you use a separate hard drive to store users' personal data, this disk will have to be “mounted” in the <filename>/home/</filename> directory. The root filesystem is always mounted at boot by the kernel; other devices are often mounted later during the startup sequence or manually with the <command>mount</command> command."
msgstr "在 Debian 这类的类 Unix 系统里，文件以树状的文件夹层级组织。<filename>/</filename> 文件夹称为 “根文件夹”；其他的文件夹都是此根文件夹的次文件夹。“挂载” 是把周边设备 (通常是磁盘) 纳入系统文件树的作业。如果以其他磁盘保存用户个人的数据，将 “挂载” 于 <filename>/home/</filename> 文件夹。根文件系统由内核永久挂载于root；其他设备则稍后再透过启动顺序或以 <command>mount</command> 命令挂载进来。"

msgid "<primary><command>mount</command></primary>"
msgstr "<primary><command>mount</command></primary>"

msgid "Some removable devices are automatically mounted when connected, especially when using the GNOME, Plasma or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <command>mount</command> and <command>umount</command> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <literal>user</literal> option in the <filename>/etc/fstab</filename> file."
msgstr "有些移动式设备在链接时系统自动挂载，尤其在 GNOME、Plasma 或其他图形桌面环境。有些情况就需要用户手动挂载。同样的，也需要卸载 (从文件树移除)。标准的用户权限不允许运行挂载 <command>mount</command> 与卸载 <command>umount</command> 命令。只有管理者才能够设置 <filename>/etc/fstab</filename> 文件内的 <literal>user</literal> 选项，授权用户运行该等命令 (独立于每个挂载点)。"

msgid "The <command>mount</command> command can be used without arguments to list all mounted filesystems; you can execute <command>findmnt --fstab</command> to show only the filesystems from <filename>/etc/fstab</filename>. The following parameters are required to mount or unmount a device. For the complete list, please refer to the corresponding man pages, <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> and <citerefentry><refentrytitle>umount</refentrytitle> <manvolnum>8</manvolnum></citerefentry>. For simple cases, the syntax is simple too: for example, to mount the <filename>/dev/sdc1</filename> partition, which has an ext3 filesystem, into the <filename>/mnt/tmp/</filename> directory, you would simply run <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command>."
msgstr "<command>mount</command> 命令可以直接不带参数使用 (列出所有已挂载的文件系统)；执行 <command>findmnt --fstab</command> 只显示从 <filename>/etc/fstab</filename> 挂载的文件系统。以下参数为挂载或卸载设备所必需的。完整的参数，请参见对应的手册页面，<citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> 与 <citerefentry><refentrytitle>umount</refentrytitle> <manvolnum>8</manvolnum></citerefentry>。语法也很简单：例如，挂载使用 ex3 文件系统的 <filename>/dev/sdc1</filename> 分区到 <filename>/mnt/tmp/</filename> 文件夹时，需运行 <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command> 命令。"

msgid "The <filename>/etc/fstab</filename> file gives a list of all possible mounts that happen either automatically on boot or manually for removable storage devices. Each mount point is described by a line with several space-separated fields: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>"
msgstr "<filename>/etc/fstab</filename> 文件列出所有开机自动挂载或手动挂载的移动存储设备。每个挂载点由一列文本描述，包括若干空格分隔的字段：<indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>"

msgid "file system: this indicates where the filesystem to be mounted can be found, it can be a local device (hard drive partition, CD-ROM) or a remote filesystem (such as NFS)."
msgstr "file system：表示要挂载的文件系统的位置 (硬盘、CD-ROM) 或远程的文件系统 (如 NFS)。"

msgid "This field is frequently replaced with the unique ID of the filesystem (which you can determine with <command>blkid <userinput>device</userinput></command>) prefixed with <literal>UUID=</literal>. This guards against a change in the name of the device in the event of addition or removal of disks, or if disks are detected in a different order."
msgstr "此字段通常以文件系统的唯一 ID 取代 (可以用 <command>blkid <userinput>device</userinput></command>) 确定 <literal>UUID=</literal>。这可防止在添加或删除磁盘时更改设备名称，或者以不同顺序检测到磁盘产生的问题。"

msgid "mount point: this is the location on the local filesystem where the device, remote system, or partition will be mounted."
msgstr "mount point：这是把设备、远程系统或分区挂载到本地文件系统的位置。"

msgid "type: this field defines the filesystem used on the mounted device. <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>btrfs</literal>, <literal>xfs</literal> are a few examples."
msgstr "type：这个字段定义挂载设备使用的文件系统。<literal>ext4</literal>、<literal>ext3</literal>、<literal>vfat</literal>、<literal>ntfs</literal>、<literal>btrfs</literal>、<literal>xfs</literal> 等。"

msgid "<emphasis>BACK TO BASICS</emphasis> NFS, a network filesystem"
msgstr "<emphasis>基础知识</emphasis> NFS，网络文件系统"

msgid "NFS is a network filesystem; under Linux, it allows transparent access to remote files by including them in the local filesystem."
msgstr "NFS 是一种 Linux 环境下的网络文件系统，把远程的文件以透明方式纳入本地的文件系统内。"

msgid "A complete list of known filesystems is available in the <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> man page. The <literal>swap</literal> special value is for swap partitions; the <literal>auto</literal> special value tells the <command>mount</command> program to automatically detect the filesystem (which is especially useful for disk readers and USB keys, since each one might have a different filesystem);"
msgstr "已知的文件系统清单在 <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry> 手册页面。特殊值 <literal>swap</literal> 供交换分区使用；特殊值 <literal>auto</literal> 告诉<command>mount</command> 程序自动侦测文件系统 (对读卡机与 USB 磁盘机特别有用，因为它们可能使用不同的文件系统);"

msgid "options: there are many of them, depending on the filesystem, and they are documented in the <command>mount</command> man page. The most common are"
msgstr "options：依文件系统的不同，而有多种选项，详情见 <command>mount</command> 手册页面。最常用的是"

msgid "<literal>rw</literal> or <literal>ro</literal>, meaning, respectively, that the device will be mounted with read/write or read-only permissions."
msgstr "<literal>rw</literal> 或 <literal>ro</literal>，表示该设备挂载后可以读/写，或只有读取的权限。"

msgid "<literal>noauto</literal> deactivates automatic mounting on boot."
msgstr "<literal>noauto</literal> 开机时关闭自动挂载。"

msgid "<literal>nofail</literal> allows the boot to proceed even when the device is not present. Make sure to put this option for external drives that might be unplugged when you boot, because <command>systemd</command> really ensures that all mount points that must be automatically mounted are actually mounted before letting the boot process continue to its end. Note that you can combine this with <literal>x-systemd.device-timeout=5s</literal> to tell <command>systemd</command> to not wait more than 5 seconds for the device to appear (see <citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry>)."
msgstr "<literal>nofail</literal> 允许在启动时处理设备，即使该设备不存在。确认启动时，该外置磁盘机可能未插入，因为 <command>systemd</command> 将确认所有挂载点在启动完成前必须自动挂载。可将此与 <literal>x-systemd.device-timeout=5s</literal> 并用，告诉 <command>systemd</command> 不必等 5 秒以上的时间，直接进入下个作业阶段 (见 <citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry>)。"

msgid "<literal>user</literal> authorizes all users to mount this filesystem (an operation which would otherwise be restricted to the root user)."
msgstr "<literal>user</literal> 授权所有的用户均可挂载此文件系统 (若无此选项，则只有根用户才有此权限)。"

msgid "<literal>defaults</literal> means the group of default options: <literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> and <literal>async</literal>, each of which can be individually disabled after <literal>defaults</literal> by adding <literal>nosuid</literal>, <literal>nodev</literal> and so on to block <literal>suid</literal>, <literal>dev</literal> and so on. Adding the <literal>user</literal> option reactivates it, since <literal>defaults</literal> includes <literal>nouser</literal>."
msgstr "<literal>defaults</literal> 表示缺省的选项群组为：<literal>rw</literal>、<literal>suid</literal>、<literal>dev</literal>、<literal>exec</literal>、<literal>auto</literal>、<literal>nouser</literal> 与 <literal>async</literal>，使用了 <literal>defaults</literal> 之后，还可以用 <literal>nosuid</literal> 命令、<literal>nodev</literal> 及其他类似的命令，中止 <literal>suid</literal>、<literal>dev</literal> 等作用。加入 <literal>user</literal> 选项可再启用它，因为 <literal>defaults</literal> 包括 <literal>nouser</literal>。"

msgid "dump: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up."
msgstr "dump：此字段几乎都设为 <literal>0</literal>。当它是 <literal>1</literal> 时，告诉 <command>dump</command> 工具将备份有数据的分区。"

msgid "pass: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>."
msgstr "pass：最后一个字段告知系统在启动时，或其他时机，检查文件系统的完整性。若设为 <literal>0</literal>，则不检查。根文件系统的值为 <literal>1</literal>，其他固定文件系统的值为 <literal>2</literal>。"

msgid "Example <filename>/etc/fstab</filename> file"
msgstr "范例 <filename>/etc/fstab</filename> 文件"

msgid ""
"\n"
"# /etc/fstab: static file system information.\n"
"#\n"
"# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;\n"
"proc            /proc           proc    defaults        0       0\n"
"# / was on /dev/sda1 during installation\n"
"UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1\n"
"# swap was on /dev/sda5 during installation\n"
"UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0\n"
"/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0\n"
"/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0\n"
"arrakis:/shared /shared         nfs     defaults        0       0"
msgstr ""
"\n"
"# /etc/fstab: static file system information.\n"
"#\n"
"# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;\n"
"proc            /proc           proc    defaults        0       0\n"
"# / was on /dev/sda1 during installation\n"
"UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1\n"
"# swap was on /dev/sda5 during installation\n"
"UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0\n"
"/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0\n"
"/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0\n"
"arrakis:/shared /shared         nfs     defaults        0       0"

msgid "The last entry in this example corresponds to a network filesystem (NFS): the <filename>/shared/</filename> directory on the <emphasis>arrakis</emphasis> server is mounted at <filename>/shared/</filename> on the local machine. The format of the <filename>/etc/fstab</filename> file is documented on the <citerefentry><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry> man page."
msgstr "此例的最后一个条目对应于网络文件系统 (NFS)：<filename>/shared/</filename> 文件夹位于 <emphasis>arrakis</emphasis> 服务器挂载于本地机器的 <filename>/shared/</filename>。<filename>/etc/fstab</filename> 文件格式位于 <citerefentry><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry> 手册页面。"

msgid "<emphasis>GOING FURTHER</emphasis> Auto-mounting"
msgstr "<emphasis>进一步</emphasis> 自动挂载"

msgid "systemd is able to manage automount points: those are filesystems that are mounted on-demand when a user attempts to access their target mount points. It can also unmount these filesystems when no process is accessing them any longer."
msgstr "systemd 可以管理自动挂载点：当用户尝试访问其目标挂载点时，这些i文件系统建按需挂载。当没有进程访问这些文件系统时，也可以卸载它们。"

msgid "Like most concepts in systemd, automount points are managed with dedicated units (using the <literal>.automount</literal> suffix). See <citerefentry><refentrytitle>systemd.automount</refentrytitle><manvolnum>5</manvolnum></citerefentry> for their precise syntax."
msgstr "与大部分 systemd 的概念一样，自动挂载点使用专用单元（使用 <literal>.automount</literal> 后缀）进行管理。其详细语法参阅 <citerefentry><refentrytitle>systemd.automount</refentrytitle><manvolnum>5</manvolnum></citerefentry>。"

msgid "<primary><emphasis>am-utils</emphasis></primary>"
msgstr "<primary><emphasis>am-utils</emphasis></primary>"

msgid "<primary><command>amd</command></primary>"
msgstr "<primary><command>amd</command></primary>"

msgid "<primary><command>automount</command></primary>"
msgstr "<primary><command>automount</command></primary>"

msgid "<primary><emphasis>autofs</emphasis></primary>"
msgstr "<primary><emphasis>autofs</emphasis></primary>"

msgid "<primary>automounter</primary>"
msgstr "<primary>automounter</primary>"

msgid "Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis role=\"pkg\">autofs</emphasis> package or <command>amd</command> in the <emphasis role=\"pkg\">am-utils</emphasis> package."
msgstr "还有其他自动挂载实用程序，诸如 <emphasis>autof role=\"pkg\">autofs</emphasis> 软件包中的 <command>automount</command> 或 <emphasis role=\"pkg\">am-utils</emphasis> 软件包中的<command>amd</command>。"

msgid "Note also that GNOME, Plasma, and other graphical desktop environments work together with <emphasis>udisks</emphasis>, and can automatically mount removable media when they are connected."
msgstr "注意，与 GNOME、Plasma 及其他图形桌面环境一起工作的 <emphasis>udisks</emphasis>，也可在链接移动媒体时自动挂载。"

msgid "<command>locate</command> and <command>updatedb</command>"
msgstr "<command>locate</command> 与 <command>updatedb</command>"

msgid "<primary><command>locate</command></primary>"
msgstr "<primary><command>locate</command></primary>"

msgid "<primary><command>updatedb</command></primary>"
msgstr "<primary><command>updatedb</command></primary>"

msgid "<primary><command>mlocate</command></primary>"
msgstr "<primary><command>mlocate</command></primary>"

msgid "The <command>locate</command> command can find the location of a file when you only know part of the name. It sends a result almost instantaneously, since it consults a database that stores the location of all the files on the system; this database is updated daily by the <command>updatedb</command> command. There are multiple implementations of the <command>locate</command> command and Debian picked <emphasis role=\"pkg\">mlocate</emphasis> for its standard system."
msgstr "可以用 <command>locate</command> 命令找寻已知名称的文件。几乎即时返回结果，因为它搜索的数据库保存系统内所有文件的位置；此数据库由 <command>updatedb</command> 命令每日更新。<command>locate</command> 命令还有其他用途，Debian 选择 <emphasis role=\"pkg\">mlocate</emphasis> 做为其标准系统。"

msgid "<command>mlocate</command> is smart enough to only return files which are accessible to the user running the command even though it uses a database that knows about all files on the system (since its <command>updatedb</command> implementation runs with root rights). For extra safety, the administrator can use <varname>PRUNEDPATHS</varname> in <filename>/etc/updatedb.conf</filename> to exclude some directories from being indexed."
msgstr "<command>mlocate</command> 很聪明，只返回该命令用户能够使用的文件，不会显示系统内其他符合条件的文件 (因为它以根权限运行 <command>updatedb</command> 命令)。为了提供额外的安全保护，管理者可以使用位于 <filename>/etc/updatedb.conf</filename> 中的 <varname>PRUNEDPATHS</varname> ，排除已经索引的其他文件夹。"

msgid "Compiling a Kernel"
msgstr "编译内核"

msgid "<primary>compilation</primary><secondary>of a kernel</secondary>"
msgstr "<primary>编译</primary><secondary>内核</secondary>"

msgid "<primary>kernel</primary><secondary>compilation</secondary>"
msgstr "<primary>内核</primary><secondary>编译</secondary>"

msgid "The kernels provided by Debian include the largest possible number of features, as well as the maximum of drivers, in order to cover the broadest spectrum of existing hardware configurations. This is why some users prefer to recompile the kernel in order to only include what they specifically need. There are two reasons for this choice. First, it may be to optimize memory consumption, since the kernel code, even if it is never used, occupies memory for nothing (and never “goes down” on the swap space, since it is actual RAM that it uses), which can decrease overall system performance. A locally compiled kernel can also limit the risk of security problems since only a fraction of the kernel code is compiled and run."
msgstr "Debian 的内核尽量纳入所有的功能，以及最多的驱动程序，以便涵盖现在的硬件配置。所以，有些用户宁愿自行编译只包括所需的内核。这么做有两个理由。第一，内存用量较小，内核代码即使未用到，也占有内存的空间 (而且永远不 “离开” 置换内存，因为它用到实际的 RAM)，降低系统的整体性能。本地自行编译的内核也限制了安全问题的范围，因为只编译与运行部分内核码。"

msgid "<emphasis>NOTE</emphasis> Security updates"
msgstr "<emphasis>说明</emphasis> 安全更新"

msgid "If you choose to compile your own kernel, you must accept the consequences: Debian cannot ensure security updates for your custom kernel. By keeping the kernel provided by Debian, you benefit from updates prepared by the Debian Project's security team."
msgstr "决定编译自己的内核后，必须接受一个事实：Debian 不能确认定制内核的安全更新。使用 Debian 的内核，可以使用 Debian 计划提供的更新。"

msgid "Recompilation of the kernel is also necessary if you want to use certain features that are only available as patches (and not included in the standard kernel version)."
msgstr "使用只在补丁内提供的功能 (不在标准的内核版本内) 时，就必须重新编译内核。"

msgid "<emphasis>GOING FURTHER</emphasis> The Debian Kernel Handbook"
msgstr "<emphasis>进一步</emphasis> The Debian Kernel Handbook"

msgid "<primary><emphasis role=\"pkg\">debian-kernel-handbook</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">debian-kernel-handbook</emphasis></primary>"

msgid "The Debian kernel team maintains the “Debian Kernel Handbook” (also available in the <emphasis role=\"pkg\">debian-kernel-handbook</emphasis> package) with comprehensive documentation about most kernel related tasks and about how official Debian kernel packages are handled. This is the first place you should look into if you need more information than what is provided in this section. <ulink type=\"block\" url=\"https://kernel-team.pages.debian.net/kernel-handbook/\" />"
msgstr "Debian 内核团队维护的 “Debian Kernel Handbook” (全文见 <emphasis role=\"pkg\">debian-kernel-handbook</emphasis> 软件包) 详述内核相关的工作与 Debian 内核软件包的处理方式。欲知本节所述事宜的详情，请参见此网址。<ulink type=\"block\" url=\"https://kernel-team.pages.debian.net/kernel-handbook/\" />"

msgid "Introduction and Prerequisites"
msgstr "简介和先决条件"

msgid "Unsurprisingly Debian manages the kernel in the form of a package, which is not how kernels have traditionally been compiled and installed. Since the kernel remains under the control of the packaging system, it can then be removed cleanly, or deployed on several machines. Furthermore, the scripts associated with these packages automate the interaction with the bootloader and the initrd generator."
msgstr "Debian 以软件包方式管理内核，与传统的编译安装不同。内核还是在软件包系统的控制下，可以被完整移除，或布建在多个机器上。与该软件包有关的脚本自动与启动程序和 initrd 生成器交互。"

msgid "The upstream Linux sources contain everything needed to build a Debian package of the kernel. But you still need to install <emphasis role=\"pkg\">build-essential</emphasis> to ensure that you have the tools required to build a Debian package. Furthermore, the configuration step for the kernel requires the <emphasis role=\"pkg\">libncurses5-dev</emphasis> package. Finally, the <emphasis role=\"pkg\">fakeroot</emphasis> package will enable creation of the Debian package without using administrator's rights."
msgstr "上游的 Linux 源代码包括建置 Debian 内核软件包所需的一切。但是仍可再安装 <emphasis role=\"pkg\">build-essential</emphasis> 以确保拥有创建 Debian 软件包所需的所有工具。而且，配置内核时需要 <emphasis role=\"pkg\">libncurses5-dev</emphasis> 软件包。最后，<emphasis role=\"pkg\">fakeroot</emphasis> 软件包将在不使用管理者权限的前提下，启用添加 Debian 软件包。"

msgid "<emphasis>CULTURE</emphasis> The good old days of <emphasis role=\"pkg\">kernel-package</emphasis>"
msgstr "<emphasis>文化</emphasis> <emphasis role=\"pkg\">kernel-package</emphasis> 的美好岁月"

msgid "<primary><emphasis role=\"pkg\">kernel-package</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">kernel-package</emphasis></primary>"

msgid "Before the Linux build system gained the ability to build proper Debian packages, the recommended way to build such packages was to use <command>make-kpkg</command> from the <emphasis role=\"pkg\">kernel-package</emphasis> package."
msgstr "在 Linux 构建系统能够创建适当的 Debian 软件包前，构建这样软件包的推荐方式，是使用来自 <emphasis role=\"pkg\">kernel-package</emphasis> 软件包的 <command>make-kpkg</command>。"

msgid "Getting the Sources"
msgstr "获取源代码"

msgid "<primary>Linux kernel sources</primary>"
msgstr "<primary>Linux 内核源代码</primary>"

msgid "<primary>kernel</primary><secondary>sources</secondary>"
msgstr "<primary>内核</primary><secondary>源代码</secondary>"

msgid "<primary>source</primary><secondary>of the Linux kernel</secondary>"
msgstr "<primary>源代码</primary><secondary> Linux 内核</secondary>"

msgid "Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role=\"pkg\">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role=\"distribution\">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend=\"sect.apt-mix-distros\" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes."
msgstr "就像 Debian 系统内其他有用的东西，Linux 内核源代码也在软件包内。只要安装 <emphasis role=\"pkg\">linux-source-<replaceable>version</replaceable></emphasis> 软件包，就能取得全部的源代码。<command>apt search ^linux-source</command> 命令列出 Debian 内各种版本的核心软件包。最新的版本在 <emphasis role=\"distribution\">Unstable</emphasis> 发行版内：可以毫不费力的取得 (尤其是把 APT 根据 <xref linkend=\"sect.apt-mix-distros\" /> 的指示配置后)。这些软件包内的源代码并未完全吻合 Linus Torvalds 与其他核心开发者发布的内容；如同其他的发行版，Debian 以一系列的补丁搭配，这些补丁可能 (或不可能) 以自己的方法纳入 Linux 上游的版本。包括从较新核心版本的 fixes/features/drivers 反向迁移，功能较新但尚未 (全部) 合并入上游的Linux 树，甚至 Debian 特别的改变。"

msgid "The remainder of this section focuses on the 4.19 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want."
msgstr "本节其他内容以 Linux 内核 v4.19 为准，范例则不以此为限，可以调整为特定的核心版本。"

msgid "We assume the <emphasis role=\"pkg\">linux-source-4.19</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-4.19.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate."
msgstr "假设 <emphasis role=\"pkg\">linux-source-4.19</emphasis> 软件包已安装好了。包括 <filename>/usr/src/linux-source-4.19.tar.xz</filename>，核心源代码的压缩档。在另一个文件夹解缩 (不能直接在 <filename>/usr/src/</filename> 之下，因为不需特别的授权就可以重新编译 Linux 核心)：<filename>~/kernel/</filename> 是个不错的选择。"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-4.19.tar.xz</userinput>"
msgstr "\n<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>\n<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-4.19.tar.xz</userinput>"

msgid "<emphasis>CULTURE</emphasis> Location of kernel sources"
msgstr "<emphasis>文化</emphasis> 内核源代码的位置"

msgid "Traditionally, Linux kernel sources would be placed in <filename>/usr/src/linux/</filename> thus requiring root permissions for compilation. However, working with administrator rights should be avoided when not needed. There is a <literal>src</literal> group that allows members to work in this directory, but working in <filename>/usr/src/</filename> should be avoided, nevertheless. By keeping the kernel sources in a personal directory, you get security on all counts: no files in <filename>/usr/</filename> unknown to the packaging system, and no risk of misleading programs that read <filename>/usr/src/linux</filename> when trying to gather information on the used kernel."
msgstr "传统上，Linux 内核源代码放置于 <filename>/usr/src/linux/</filename>，需要root权限才能编译。但是，在不需要时应避免使用管理员权限。<literal>src</literal> 群组的成员也可以使用该文件夹，但是应避免使用 <filename>/usr/src/</filename>。把核心源代码置于个人文件夹时，应把安全放在第一位：在 <filename>/usr/</filename> 内的文件都应明确其在软件包系统内的作用，试图收集内核使用的信息时，不能在读取 <filename>/usr/src/linux</filename> 时误导程序。"

msgid "Configuring the Kernel"
msgstr "配置内核"

msgid "<primary>kernel</primary><secondary>configuration</secondary>"
msgstr "<primary>内核</primary><secondary>配置</secondary>"

msgid "<primary>configuration</primary><secondary>of the kernel</secondary>"
msgstr "<primary>配置</primary><secondary>内核</secondary>"

msgid "<primary><filename>.config</filename></primary>"
msgstr "<primary><filename>.config</filename></primary>"

msgid "The next step consists of configuring the kernel according to your needs. The exact procedure depends on the goals."
msgstr "下一个步骤是根据需要配置内核。确切的进程视需要而订。"

msgid "When recompiling a more recent version of the kernel (possibly with an additional patch), the configuration will most likely be kept as close as possible to that proposed by Debian. In this case, and rather than reconfiguring everything from scratch, it is sufficient to copy the <filename>/boot/config-<replaceable>version</replaceable></filename> file (the version is that of the kernel currently used, which can be found with the <command>uname -r</command> command) into a <filename>.config</filename> file in the directory containing the kernel sources."
msgstr "重新编译较新版本的内核 (可能连同其补丁) 时，应尽量采用 Debian 建议的配置。在此情况下，与其从最基本开始重新编译，不妨复制 <filename>/boot/config-<replaceable>version</replaceable></filename> 文件 (内核正在使用的版本，可以 <command>uname -r</command> 命令查看) 进入内核原始所在文件夹内的 <filename>.config</filename> 文件。"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cp /boot/config-4.19.0-5-amd64 ~/kernel/linux-source-4.19/.config</userinput>"
msgstr "\n<computeroutput>$ </computeroutput><userinput>cp /boot/config-4.19.0-5-amd64 ~/kernel/linux-source-4.19/.config</userinput>"

msgid "Unless you need to change the configuration, you can stop here and skip to <xref linkend=\"sect.kernel-build\" />. If you need to change it, on the other hand, or if you decide to reconfigure everything from scratch, you must take the time to configure your kernel. There are various dedicated interfaces in the kernel source directory that can be used by calling the <command>make <replaceable>target</replaceable></command> command, where <replaceable>target</replaceable> is one of the values described below."
msgstr "需要改变配置的话，就跳至 <xref linkend=\"sect.kernel-build\" />。或者从基本开始重新配置，就需花时间配置内核。在内核源代码的文件夹内有很多专属接口，使用 <command>make <replaceable>target</replaceable></command> 命令调用，<replaceable>target</replaceable> 是下列的值之一。"

msgid "<command>make menuconfig</command> compiles and executes a text-mode interface (this is where the <emphasis role=\"pkg\">libncurses5-dev</emphasis> package is required) which allows navigating the options available in a hierarchical structure. Pressing the <keycap>Space</keycap> key changes the value of the selected option, and <keycap>Enter</keycap> validates the button selected at the bottom of the screen; <guibutton>Select</guibutton> returns to the selected sub-menu; <guibutton>Exit</guibutton> closes the current screen and moves back up in the hierarchy; <guibutton>Help</guibutton> will display more detailed information on the role of the selected option. The arrow keys allow moving within the list of options and buttons. To exit the configuration program, choose <guibutton>Exit</guibutton> from the main menu. The program then offers to save the changes you've made; accept if you are satisfied with your choices."
msgstr "<command>make menuconfig</command> 编译并运行文本模式界面 (需要 <emphasis role=\"pkg\">libncurses5-dev</emphasis> 软件包) 以层级结构浏览可用的选项。按 <keycap>空格</keycap> 键改变选定的值，并按屏幕下方的 <keycap>Enter</keycap> 钮；<guibutton>Select</guibutton> 返回选定的子次单；<guibutton>Exit</guibutton> 关闭当前的屏幕并回到上一个层级；<guibutton>Help</guibutton> 显示选项的详细信息。箭头键在选项及按钮清单内移动。按主菜单的 <guibutton>Exit</guibutton> 钮，就可离开配置程序。此程序可保存改变的配置；接受改变后的配置。"

msgid "Other interfaces have similar features, but they work within more modern graphical interfaces; such as <command>make xconfig</command> which uses a Qt graphical interface, and <command>make gconfig</command> which uses GTK+. The former requires <emphasis role=\"pkg\">libqt4-dev</emphasis>, while the latter depends on <emphasis role=\"pkg\">libglade2-dev</emphasis> and <emphasis role=\"pkg\">libgtk2.0-dev</emphasis>."
msgstr "其他的界面类似的功能，但在现代化的图形接口运作；诸如 <command>make xconfig</command> 使用 Qt 图形接口，而 <command>make gconfig</command> 使手 GTK+。前者用到 <emphasis role=\"pkg\">libqt4-dev</emphasis>，后者依赖 <emphasis role=\"pkg\">libglade2-dev</emphasis> 与 <emphasis role=\"pkg\">libgtk2.0-dev</emphasis>。"

msgid "When using one of those configuration interfaces, it is always a good idea to start from a reasonable default configuration. The kernel provides such configurations in <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> and you can put your selected configuration in place with a command like <command>make x86_64_defconfig</command> (in the case of a 64-bit PC) or <command>make i386_defconfig</command> (in the case of a 32-bit PC)."
msgstr "使用这些配置界面时，建议从合理的缺省配置开始。提供该配置的内核在 <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename>，然后使用 <command>make x86_64_defconfig</command> (64 位电脑) 或 <command>make i386_defconfig</command> (32 位电脑) 这样的命令选择合适的缺省配置。"

msgid "<emphasis>TIP</emphasis> Dealing with outdated <filename>.config</filename> files"
msgstr "<emphasis>秘诀</emphasis> 处理过时的 <filename>.config</filename> 文件"

msgid "When you provide a <filename>.config</filename> file that has been generated with another (usually older) kernel version, you will have to update it. You can do so with <command>make oldconfig</command>, it will interactively ask you the questions corresponding to the new configuration options. If you want to use the default answer to all those questions you can use <command>make olddefconfig</command>. With <command>make oldnoconfig</command>, it will assume a negative answer to all questions."
msgstr "使用其他 (通常是较旧的) 内核版本的 <filename>.config</filename> 文件时，需要先更新它。可以使用 <command>make oldconfig</command> 命令，以交互方式询问对新配置的选择。可以用 <command>make olddefconfig</command> 命令使用问题缺省的答案。以 <command>make oldnoconfig</command> 命令，可以对问题提供缺省的答案。"

msgid "Compiling and Building the Package"
msgstr "编译与创建软件包"

msgid "<primary><command>make deb-pkg</command></primary>"
msgstr "<primary><command>make deb-pkg</command></primary>"

msgid "<emphasis>NOTE</emphasis> Clean up before rebuilding"
msgstr "<emphasis>说明</emphasis> 创建前先清理"

msgid "If you have already compiled once in the directory and wish to rebuild everything from scratch (for example, because you substantially changed the kernel configuration), you will have to run <command>make clean</command> to remove the compiled files. <command>make distclean</command> removes even more generated files, including your <filename>.config</filename> file too, so make sure to backup it first. If you copied the configuration from <filename>/boot/</filename>, you must change the system trusted keys option, providing an empty string is enough: <literal>CONFIG_SYSTEM_TRUSTED_KEYS = \"\"</literal>."
msgstr "若已在文件夹内编译过，希望重新创建 (或许更换内核配置)，需运行 <command>make clean</command> 命令移除已编译的文件。<command>make distclean</command> 命令可移除更多的文件，包括定制的 <filename>.config</filename> 文件，别忘了先备份。如果从 <filename>/boot/</filename> 复制配置文件，必须更改系统信任密钥选项，提供空字符串就可以： <literal>CONFIG_SYSTEM_TRUSTED_KEYS = \"\"</literal>。"

msgid "Once the kernel configuration is ready, a simple <command>make deb-pkg</command> will generate up to 5 Debian packages: <emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable></emphasis> that contains the kernel image and the associated modules, <emphasis role=\"pkg\">linux-headers-<replaceable>version</replaceable></emphasis> which contains the header files required to build external modules, <emphasis role=\"pkg\">linux-firmware-image-<replaceable>version</replaceable></emphasis> which contains the firmware files needed by some drivers (this package might be missing when you build from the kernel sources provided by Debian), <emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable>-dbg</emphasis> which contains the debugging symbols for the kernel image and its modules, and <emphasis role=\"pkg\">linux-libc-dev</emphasis> which contains headers relevant to some user-space libraries like GNU glibc."
msgstr "内核配置完成后，<command>make deb-pkg</command> 命令可产生至多 5 个 Debian 软件包：<emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable></emphasis> 包括内核映像与相关的模块，<emphasis role=\"pkg\">linux-headers-<replaceable>version</replaceable></emphasis> 包括创建外部模块所需的头文件，<emphasis role=\"pkg\">linux-firmware-image-<replaceable>version</replaceable></emphasis> 包括某些驱动程序所需的固件 (由 Debian 提供的内核源文件创建时，可能没有该软件包)，<emphasis role=\"pkg\">linux-image-<replaceable>version</replaceable>-dbg</emphasis> 包括供软件包映像及其模块的调试符号，以及<emphasis role=\"pkg\">linux-libc-dev</emphasis> 包括 GNU glibc 之类与用户程序库相关的标头。"

msgid "The <replaceable>version</replaceable> is defined by the concatenation of the upstream version (as defined by the variables <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> and <literal>EXTRAVERSION</literal> in the <filename>Makefile</filename>), of the <literal>LOCALVERSION</literal> configuration parameter, and of the <literal>LOCALVERSION</literal> environment variable. The package version reuses the same version string with an appended revision that is regularly incremented (and stored in <filename>.version</filename>), except if you override it with the <literal>KDEB_PKGVERSION</literal> environment variable."
msgstr "<replaceable>version</replaceable> 由上游版本决定 (如同变量 <literal>VERSION</literal>、<literal>PATCHLEVEL</literal>、<literal>SUBLEVEL</literal> 与 <literal>EXTRAVERSION</literal> 在 <filename>Makefile</filename> 内所定)、 <literal>LOCALVERSION</literal> 配置参数、以及 <literal>LOCALVERSION</literal> 环境变量。软件包版本使用同版本字符串以及添加的附加版本 (并保存在 <filename>.version</filename>)，除非以 <literal>KDEB_PKGVERSION</literal> 环境变量覆写它们。"

msgid ""
"<computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1\n"
"</userinput><computeroutput>[...]\n"
"$ </computeroutput><userinput>ls ../*.deb\n"
"</userinput><computeroutput>../linux-headers-4.19.37-falcot_4.19.37-1_amd64.deb\n"
"../linux-image-4.19.37-falcot_4.19.37-1_amd64.deb\n"
"../linux-libc-dev_4.19.37-1_amd64.deb\n"
"</computeroutput>"
msgstr "<computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1\n</userinput><computeroutput>[...]\n$ </computeroutput><userinput>ls ../*.deb\n</userinput><computeroutput>../linux-headers-4.19.37-falcot_4.19.37-1_amd64.deb\n../linux-image-4.19.37-falcot_4.19.37-1_amd64.deb\n../linux-libc-dev_4.19.37-1_amd64.deb\n</computeroutput>"

msgid "Compiling External Modules"
msgstr "编译外部模块"

msgid "<primary>kernel</primary><secondary>external modules</secondary>"
msgstr "<primary>内核</primary><secondary>外部模块</secondary>"

msgid "<primary>modules</primary><secondary>external kernel modules</secondary>"
msgstr "<primary>模块</primary><secondary>外部内核模块</secondary>"

msgid "<primary><command>dkms</command></primary>"
msgstr "<primary><command>dkms</command></primary>"

msgid "Some modules are maintained outside of the official Linux kernel. To use them, they must be compiled alongside the matching kernel. A number of common third party modules are provided by Debian in dedicated packages, such as <emphasis role=\"pkg\">vpb-driver-source</emphasis> (extra modules for Voicetronix telefony hardware) or <emphasis role=\"pkg\">leds-alix-source</emphasis> (driver of PCEngines ALIX 2/3 boards)."
msgstr "部分 Linux 内核模块并不由官方维护。使用时，必须与对应的内核一起编译。若干常见的第三方模块由 Debian 指定软件包提供，诸如 <emphasis role=\"pkg\">vpb-driver-source</emphasis> (Voicetronix telefony硬件的扩展模块) 或 <emphasis role=\"pkg\">leds-alix-source</emphasis> (PCEngines ALIX 2/3 主板的驱动程序)。"

msgid "These packages are many and varied, <command>apt-cache rdepends module-assistant$</command> can show the list provided by Debian. However, a complete list isn't particularly useful since there is no particular reason for compiling external modules except when you know you need it. In such cases, the device's documentation will typically detail the specific module(s) it needs to function under Linux."
msgstr "这些软件包极多且复杂，<command>apt-cache rdepends module-assistant$</command> 可以列出Debian提供的部分。然而，完整的清单没什么用处，只有明确知道需要时，才会编译特定的外部模块。在这个情况下，设备的文档会详述 Linux 环境所需的模块。"

msgid "For example, let's look at the <emphasis role=\"pkg\">dahdi-source</emphasis> package: after installation, a <filename>.tar.bz2</filename> of the module's sources is stored in <filename>/usr/src/</filename>. While we could manually extract the tarball and build the module, in practice we prefer to automate all this using DKMS. Most modules offer the required DKMS integration in a package ending with a <literal>-dkms</literal> suffix. In our case, installing <emphasis role=\"pkg\">dahdi-dkms</emphasis> is all that is needed to compile the kernel module for the current kernel provided that we have the <emphasis role=\"pkg\">linux-headers-*</emphasis> package matching the installed kernel. For instance, if you use <emphasis role=\"pkg\">linux-image-amd64</emphasis>, you would also install <emphasis role=\"pkg\">linux-headers-amd64</emphasis>."
msgstr "以 <emphasis role=\"pkg\">dahdi-source</emphasis> 软件包为例：安装之后，模块源文件 <filename>.tar.bz2</filename> 保存在 <filename>/usr/src/</filename>。可以手动解开该压缩档并创建模块，也可用 DKMS 自动处理它。大部分模块提供必要的 DKMS 以 <literal>-dkms</literal> 后缀文本集成入软件包。在本例中，安装 <emphasis role=\"pkg\">dahdi-dkms</emphasis> 就是为当前内核编译内核模块，前提是有匹配已安装内核的 <emphasis role=\"pkg\">linux-headers-*</emphasis> 软件包。例如，使用 <emphasis role=\"pkg\">linux-image-amd64</emphasis>，则应同时安装 <emphasis role=\"pkg\">linux-headers-amd64</emphasis>。"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>sudo apt install dahdi-dkms</userinput>\n"
"<computeroutput>\n"
"[...]\n"
"Setting up xtables-addons-dkms (2.12-0.1) ...\n"
"Loading new xtables-addons-2.12 DKMS files...\n"
"Building for 4.19.0-5-amd64\n"
"Building initial module for 4.19.0-5-amd64\n"
"Done.\n"
"\n"
"dahdi_dummy.ko:\n"
"Running module version sanity check.\n"
" - Original module\n"
"   - No original module exists within this kernel\n"
" - Installation\n"
"   - Installing to /lib/modules/4.19.0-5-amd64/updates/dkms/\n"
"[...]\n"
"DKMS: install completed.\n"
"$ </computeroutput><userinput>sudo dkms status</userinput>\n"
"<computeroutput>dahdi, DEB_VERSION, 4.19.0-5-amd64, x86_64: installed\n"
"$ </computeroutput><userinput>sudo modinfo dahdi_dummy</userinput>\n"
"<computeroutput>filename:       /lib/modules/4.19.0-5-amd64/updates/dkms/dahdi_dummy.ko\n"
"license:        GPL v2\n"
"author:         Robert Pleh &lt;robert.pleh@hermes.si&gt;\n"
"description:    Timing-Only Driver\n"
"[...]\n"
"</computeroutput>"
msgstr "\n<computeroutput>$ </computeroutput><userinput>sudo apt install dahdi-dkms</userinput>\n<computeroutput>\n[...]\nSetting up xtables-addons-dkms (2.12-0.1) ...\nLoading new xtables-addons-2.12 DKMS files...\nBuilding for 4.19.0-5-amd64\nBuilding initial module for 4.19.0-5-amd64\nDone.\n\ndahdi_dummy.ko:\nRunning module version sanity check.\n - Original module\n   - No original module exists within this kernel\n - Installation\n   - Installing to /lib/modules/4.19.0-5-amd64/updates/dkms/\n[...]\nDKMS: install completed.\n$ </computeroutput><userinput>sudo dkms status</userinput>\n<computeroutput>dahdi, DEB_VERSION, 4.19.0-5-amd64, x86_64: installed\n$ </computeroutput><userinput>sudo modinfo dahdi_dummy</userinput>\n<computeroutput>filename:       /lib/modules/4.19.0-5-amd64/updates/dkms/dahdi_dummy.ko\nlicense:        GPL v2\nauthor:         Robert Pleh &lt;robert.pleh@hermes.si&gt;\ndescription:    Timing-Only Driver\n[...]\n</computeroutput>"

msgid "<emphasis>ALTERNATIVE</emphasis> module-assistant"
msgstr "<emphasis>其他</emphasis> module-assistant"

msgid "<primary><emphasis role=\"pkg\">module-assistant</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">module-assistant</emphasis></primary>"

msgid "Before DKMS, <emphasis role=\"pkg\">module-assistant</emphasis> was the simplest solution to build and deploy kernel modules. It can still be used, in particular for packages lacking DKMS integration: with a simple command like <command>module-assistant auto-install dadhi</command> (or <command>m-a a-i dahdi</command> for short), the modules are compiled for the current kernel, put in a new Debian package, and that package gets installed on the fly."
msgstr "DKMS 出现以前，<emphasis role=\"pkg\">module-assistant</emphasis> 是创建与部署内核模块的最简单解决方案。目前还能用，特别是缺少 DKMS 集成的情况：以 <command>module-assistant auto-install dadhi</command> (或较短的 <command>m-a a-i dahdi</command>) 命令，就能编译出给当前内核使用的模块，置于新的 Debian 软件包，让该软件包可以即时安装。"

msgid "Applying a Kernel Patch"
msgstr "选择内核补丁"

msgid "<primary>kernel</primary><secondary>patch</secondary>"
msgstr "<primary>内核</primary><secondary>补丁</secondary>"

msgid "<primary>patch of the kernel</primary>"
msgstr "<primary>内核补丁</primary>"

msgid "Some features are not included in the standard kernel due to a lack of maturity or to some disagreement with the kernel maintainers. Such features may be distributed as patches that anyone is then free to apply to the kernel sources."
msgstr "因为不够成熟或内核维护者意见不一致，很多功能未列入标准的内核。这种功能就以补丁的形式发行，任何人都可以自由地把它纳入内核源代码。"

msgid "Debian sometimes provides some of these patches in <emphasis role=\"pkg\">linux-patch-*</emphasis> packages, but they often don't make it into stable releases (sometimes for the very same reasons that they are not merged into the official upstream kernel). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory."
msgstr "Debian 以 <emphasis role=\"pkg\">linux-patch-*</emphasis> 的形式提供这些软件包，但通常不在稳定版中（有时相同的原因是这些都未纳入上游内核版本中）。这些软件包安装的文件在 <filename>/usr/src/kernel-patches/</filename> 文件夹内。"

msgid "To apply one or more of these installed patches, use the <command>patch</command> command in the sources directory then start compilation of the kernel as described above."
msgstr "要安装这些补丁，在源文件文件夹内使用 <command>patch</command> 命令，就能够纳入前述的补丁编译内核。"

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-4.9</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>make clean</userinput>\n"
"<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.1-4.9.11-201702181444.patch.gz | patch -p1</userinput>"
msgstr "\n<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-4.9</userinput>\n<computeroutput>$ </computeroutput><userinput>make clean</userinput>\n<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.1-4.9.11-201702181444.patch.gz | patch -p1</userinput>"

msgid "Note that a given patch may not necessarily work with every version of the kernel; it is possible for <command>patch</command> to fail when applying them to kernel sources. An error message will be displayed and give some details about the failure; in this case, refer to the documentation available in the Debian package of the patch (in the <filename>/usr/share/doc/linux-patch-*/</filename> directory). In most cases, the maintainer indicates for which kernel versions their patch is intended."
msgstr "有些补丁不见得适用于每个内核版本；以 <command>patch</command> 可能无法应用于内核源代码。将出现错误消息且提示错误的原因；在此情况下，参照 Debian 补丁软件包的文档 (位于 <filename>/usr/share/doc/linux-patch-*/</filename> 文件夹)。大部分的情况下，维护者会指出其补丁适用的内核版本。"

msgid "Installing a Kernel"
msgstr "安装内核"

msgid "<primary>installation</primary><secondary>of a kernel</secondary>"
msgstr "<primary>安装</primary><secondary>内核</secondary>"

msgid "<primary>kernel</primary><secondary>installation</secondary>"
msgstr "<primary>内核</primary><secondary>安装</secondary>"

msgid "Features of a Debian Kernel Package"
msgstr "Debian 内核包特性"

msgid "<primary><filename>vmlinuz</filename></primary>"
msgstr "<primary><filename>vmlinuz</filename></primary>"

msgid "A Debian kernel package installs the kernel image (<filename>vmlinuz-<replaceable>version</replaceable></filename>), its configuration (<filename>config-<replaceable>version</replaceable></filename>) and its symbols table (<filename>System.map-<replaceable>version</replaceable></filename>) in <filename>/boot/</filename>. The modules are installed in the <filename>/lib/modules/<replaceable>version</replaceable>/</filename> directory."
msgstr "Debian 内核软件包安装内核映像 (<filename>vmlinuz-<replaceable>version</replaceable></filename>)、其配置 (<filename>config-<replaceable>version</replaceable></filename>) 与符号表 (<filename>System.map-<replaceable>version</replaceable></filename>) 到 <filename>/boot/</filename> 内。其模块安装在 <filename>/lib/modules/<replaceable>version</replaceable>/</filename> 文件夹。"

msgid "<emphasis>CULTURE</emphasis> The symbols table"
msgstr "<emphasis>文化</emphasis> 符号表"

msgid "The symbols table helps developers understand the meaning of a kernel error message; without it, kernel “oopses” (an “oops” is the kernel equivalent of a segmentation fault for user-space programs, in other words messages generated following an invalid pointer dereference) only contain numeric memory addresses, which is useless information without the table mapping these addresses to symbols and function names."
msgstr "符号表协助开发者了解核心错误消息的意义；少了心，核心 “oopses” (“oops” 是相当于给用户程序的核心区段错误，换句话说，消息加上错误指针) 只有数字内存地址，没有符号表映射该等地址至符号与功能的话，本身是无意义的。"

msgid "The package's configuration scripts automatically generate an initrd image, which is a mini-system designed to be loaded in memory (hence the name, which stands for “init ramdisk”) by the bootloader, and used by the Linux kernel solely for loading the modules needed to access the devices containing the complete Debian system (for example, the driver for SATA disks). Finally, the post-installation scripts update the symbolic links <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>, <filename>/initrd.img</filename> and <filename>/initrd.img.old</filename> so that they point to the latest two kernels installed, respectively, as well as the corresponding initrd images."
msgstr "软件包的配置脚本自动产生 initrd 映像，这是由启动程序加载到内存的迷你系统 (其名称源自于此，表示为 “init ramdisk”)，被 Linux 内核专用于加载包括完整 Debian 系统设备的模块 (例如，SATA 磁盘的驱动程序)。最后，安装后脚本更新符号链接 <filename>/vmlinuz</filename>、<filename>/vmlinuz.old</filename>、<filename>/initrd.img</filename> 与 <filename>/initrd.img.old</filename>，让它们分别指向最新的两个内核， 以及映射的 initrd 映像。"

msgid "Most of those tasks are offloaded to hook scripts in the <filename>/etc/kernel/*.d/</filename> directories. For instance, the integration with <command>grub</command> relies on <filename>/etc/kernel/postinst.d/zz-update-grub</filename> and <filename>/etc/kernel/postrm.d/zz-update-grub</filename> to call <command>update-grub</command> when kernels are installed or removed."
msgstr "大部分的这些工作卸载至 <filename>/etc/kernel/*.d/</filename> 文件夹内的脚本。例如，当已安装或移除内核时，集成 <command>grub</command> 于 <filename>/etc/kernel/postinst.d/zz-update-grub</filename> 和 <filename>/etc/kernel/postrm.d/zz-update-grub</filename> 调用 <command>update-grub</command>。"

msgid "Installing with <command>dpkg</command>"
msgstr "使用 <command>dpkg</command> 安装"

msgid "Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role=\"pkg\">linux-image</emphasis> package such as <filename>linux-image-4.19.37-falcot_1_amd64.deb</filename>."
msgstr "使用 <command>apt</command> 极为便利，以致常忘记它是极为低级的工具，但是安装被编译的内核可使用更简单的工具，诸如 <command>dpkg -i <replaceable>package</replaceable>.deb</command>，<literal><replaceable>package</replaceable>.deb</literal> 是 <emphasis role=\"pkg\">linux-image</emphasis> 软件包的名称，例如 <filename>linux-image-4.19.37-ckt4-falcot_1_amd64.deb</filename>。"

msgid "The configuration steps described in this chapter are basic and can lead both to a server system or a workstation, and it can be massively duplicated in semi-automated ways. However, it is not enough by itself to provide a fully configured system. A few pieces are still in need of configuration, starting with low-level programs known as the “Unix services”."
msgstr "本章描述供服务器系统或工作站的基本配置，可以用半自动的方式大量复制。然而，本身还不足以提供完整的配置系统。还有若干部分需要进一步的配置，从 “Unix 服务” 之类的低级程序开始。"

#~ msgid "<primary><command>cups</command></primary>"
#~ msgstr "<primary><command>cups</command></primary>"

#~ msgid "This program is divided over several Debian packages: <emphasis role=\"pkg\">cups</emphasis> is the central print server; <emphasis role=\"pkg\">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role=\"pkg\">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role=\"pkg\">cups-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>."
#~ msgstr "此程序分散在若干 Debian 软件包中：<emphasis role=\"pkg\">cups</emphasis> 是中央印表服务器；<emphasis role=\"pkg\">cups-bsd</emphasis> 是使用传统 BSD 打印系统 (<command>lpd</command> 后台进程、<command>lpr</command> 与 <command>lpq</command> 等命令) 命令的兼容层；<emphasis role=\"pkg\">cups-client</emphasis> 包括一群与服务器交互 (拦阻或放行打印机、查看或删除进行中的印表工作等) 的程序；最后，<emphasis role=\"pkg\">cups-driver-gutenprint</emphasis> 包括给 <command>cups</command> 使用的其他打印机驱动程序集。"

#~ msgid "<emphasis>NOTE</emphasis> Obsolescence of <filename>/etc/printcap</filename>"
#~ msgstr "<emphasis>说明</emphasis> 过时的 <filename>/etc/printcap</filename>"

#~ msgid "<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend=\"sidebar.symbolic-link\" />) to <filename>/var/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility."
#~ msgstr "<emphasis>cups</emphasis> 不再使用已经过时的 <filename>/etc/printcap</filename> 文件。从此文件取得的可用打印机已过时不合用。为了避免此麻燸，应删除此文件并链接 (见专栏 <xref linkend=\"sidebar.symbolic-link\" />) 至 <filename>/var/run/cups/printcap</filename>，由 <emphasis>cups</emphasis> 维护该文件以确保其兼容性。"

#~ msgid "<primary><filename>printcap</filename></primary>"
#~ msgstr "<primary><filename>printcap</filename></primary>"

#~ msgid "For Macintosh Computers (PowerPC): Configuring Yaboot"
#~ msgstr "Macintosh 电脑 (PowerPC)：配置 Yaboot"

#~ msgid "<primary><command>yaboot</command></primary>"
#~ msgstr "<primary><command>yaboot</command></primary>"

#~ msgid "Yaboot is the bootloader used by old Macintosh computers using PowerPC processors. They do not boot like PCs, but rely on a “bootstrap” partition, from which the BIOS (or OpenFirmware) executes the loader, and on which the <command>ybin</command> program installs <command>yaboot</command> and its configuration file. You will only need to run this command again if the <filename>/etc/yaboot.conf</filename> is modified (it is duplicated on the bootstrap partition, and <command>yaboot</command> knows how to find the position of the kernels on the disks)."
#~ msgstr "Yaboot 是使用 PowerPC 芯片的旧型 Macintosh 电脑用到的启动程序。它的启动方式不同于 PC，采用 “引导” 分区法，从 BIOS (或 OpenFirmware) 运行启动程序，然后由 <command>ybin</command> 程序安装 <command>yaboot</command> 及其配置档。修改 <filename>/etc/yaboot.conf</filename> 文件后 (在启动程序分区复制，且 <command>yaboot</command> 知道如何到磁盘找寻核心的位置)，需再次运行此命令。"

#~ msgid "Before executing <command>ybin</command>, you must first have a valid <filename>/etc/yaboot.conf</filename>. The following is an example of a minimal configuration. <indexterm><primary><command>ybin</command></primary></indexterm>"
#~ msgstr "运行 <command>ybin</command> 之前，应有合法的 <filename>/etc/yaboot.conf</filename> 程序。以下的最小配置的范例。<indexterm><primary><command>ybin</command></primary></indexterm>"

#~ msgid "Yaboot configuration file"
#~ msgstr "Yaboot 配置文件"

#~ msgid ""
#~ "\n"
#~ "# bootstrap partition\n"
#~ "boot=/dev/sda2\n"
#~ "# the disk\n"
#~ "device=hd:\n"
#~ "# the Linux partition\n"
#~ "partition=3\n"
#~ "root=/dev/sda3\n"
#~ "# boot after 3 seconds of inactivity\n"
#~ "# (timeout is in tenths of seconds)\n"
#~ "timeout=30\n"
#~ "\n"
#~ "install=/usr/lib/yaboot/yaboot\n"
#~ "magicboot=/usr/lib/yaboot/ofboot\n"
#~ "enablecdboot\n"
#~ "\n"
#~ "# last kernel installed\n"
#~ "image=/vmlinux\n"
#~ "        label=linux\n"
#~ "        initrd=/initrd.img\n"
#~ "        read-only\n"
#~ "\n"
#~ "# old kernel\n"
#~ "image=/vmlinux.old\n"
#~ "        label=old\n"
#~ "        initrd=/initrd.img.old\n"
#~ "        read-only\n"
#~ "\n"
#~ "# only for Linux/Mac OSX dual-boot\n"
#~ "macosx=/dev/sda5\n"
#~ "\n"
#~ "# bsd=/dev/sdaX and macos=/dev/sdaX\n"
#~ "# are also possible"
#~ msgstr ""
#~ "\n"
#~ "# bootstrap partition\n"
#~ "boot=/dev/sda2\n"
#~ "# the disk\n"
#~ "device=hd:\n"
#~ "# the Linux partition\n"
#~ "partition=3\n"
#~ "root=/dev/sda3\n"
#~ "# boot after 3 seconds of inactivity\n"
#~ "# (timeout is in tenths of seconds)\n"
#~ "timeout=30\n"
#~ "\n"
#~ "install=/usr/lib/yaboot/yaboot\n"
#~ "magicboot=/usr/lib/yaboot/ofboot\n"
#~ "enablecdboot\n"
#~ "\n"
#~ "# last kernel installed\n"
#~ "image=/vmlinux\n"
#~ "        label=linux\n"
#~ "        initrd=/initrd.img\n"
#~ "        read-only\n"
#~ "\n"
#~ "# old kernel\n"
#~ "image=/vmlinux.old\n"
#~ "        label=old\n"
#~ "        initrd=/initrd.img.old\n"
#~ "        read-only\n"
#~ "\n"
#~ "# only for Linux/Mac OSX dual-boot\n"
#~ "macosx=/dev/sda5\n"
#~ "\n"
#~ "# bsd=/dev/sdaX and macos=/dev/sdaX\n"
#~ "# are also possible"
