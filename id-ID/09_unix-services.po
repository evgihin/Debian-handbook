#
# AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr "Project-Id-Version: 0\nPOT-Creation-Date: 2020-06-19 11:25+0200\nPO-Revision-Date: 2021-02-22 02:50+0000\nLast-Translator: Reza Almanda <rezaalmanda27@gmail.com>\nLanguage-Team: Indonesian <https://hosted.weblate.org/projects/debian-handbook/09_unix-services/id/>\nLanguage: id-ID\nMIME-Version: 1.0\nContent-Type: application/x-publican; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nPlural-Forms: nplurals=1; plural=0;\nX-Generator: Weblate 4.5\n"

msgid "System boot"
msgstr "Boot sistem"

msgid "Initscripts"
msgstr "Initscript"

msgid "SSH"
msgstr "SSH"

msgid "Telnet"
msgstr "Telnet"

msgid "Rights"
msgstr "Hak"

msgid "Permissions"
msgstr "Izin"

msgid "Supervision"
msgstr "Pengawasan"

msgid "Inetd"
msgstr "Inetd"

msgid "Cron"
msgstr "Cron"

msgid "Backup"
msgstr "Cadangan"

msgid "Hotplug"
msgstr "Hotplug"

msgid "PCMCIA"
msgstr "PCMCIA"

msgid "APM"
msgstr "APM"

msgid "ACPI"
msgstr "ACPI"

msgid "Unix Services"
msgstr "Layanan Unix"

msgid "This chapter covers a number of basic services that are common to many Unix systems. All administrators should be familiar with them."
msgstr "Bab ini membahas tentang layanan dasar yang biasa digunakan pada banyak sistem Unix. Semua administator seharusnya sudah terbiasa dengan mereka."

msgid "System Boot"
msgstr "Boot Sistem"

msgid "<primary>booting</primary><secondary>the system</secondary>"
msgstr "<primary>boot</primary><secondary>sistem</secondary>"

msgid "When you boot the computer, the many messages scrolling by on the console display many automatic initializations and configurations that are being executed. Sometimes you may wish to slightly alter how this stage works, which means that you need to understand it well. That is the purpose of this section."
msgstr "Ketika Anda mem-boot komputer, banyak pesan bergulir pada layar konsol yang menampilkan banyak inisialisasi dan konfigurasi otomatis yang sedang dieksekusi. Kadang-kadang Anda mungkin ingin mengubah sedikit bagaimana tahap ini bekerja, yang berarti bahwa Anda perlu untuk memahaminya dengan baik. Itulah tujuan dari bagian ini."

msgid "First, the BIOS takes control of the computer, detects the disks, loads the <emphasis>Master Boot Record</emphasis>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <command>init</command>. Frequently, this “root partition” and this <command>init</command> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process."
msgstr "Pertama, BIOS mengambil kendali komputer, mendeteksi disk, memuat <emphasis>Master Boot Record</emphasis>, dan mengeksekusi bootloader. Bootloader mengambil alih, menemukan kernel pada disk, memuat dan mengeksekusinya. Kernel kemudian diinisialisasi, dan mulai mencari dan me-mount partisi yang memuat sistem berkas root, dan akhirnya mengeksekusi program pertama — <command>init</command>. Seringkali, \"partisi root partisi\" ini dan =<command>init</command> ini, pada kenyataannya, terletak di sistem berkas virtual yang hanya ada dalam RAM (maka namanya, \"initramfs\", sebelumnya disebut \"initrd\" untuk \"initialization RAM disk\"). Sistem berkas ini dimuat ke dalam memori oleh bootloader, sering dari suatu berkas pada hard drive atau dari jaringan. Ini berisi minimal yang diperlukan oleh kernel untuk memuat sistem berkas root yang \"benar\": ini mungkin modul penggerak untuk hard drive, atau perangkat lain yang tanpanya sistem tidak bisa boot, atau, lebih sering, skrip inisialisasi dan modul untuk merakit larik RAID, membuka partisi yang dienkripsi, mengaktifkan volume LVM, dll. Setelah partisi root di-mount, initramfs menyerahkan kontrol untuk init nyata, dan mesin kembali ke proses boot standar."

msgid "The systemd init system"
msgstr "Sistem init systemd"

msgid "The “real init” is currently provided by <emphasis role=\"pkg\">systemd</emphasis> and this section documents this init system."
msgstr "”init sejati” saat ini disediakan oleh <emphasis role=\"pkg\">systemd</emphasis> dan seksi ini mendokumentasikan sistem init ini."

msgid "<emphasis>CULTURE</emphasis> Before <command>systemd</command>"
msgstr "<emphasis>KULTUR</emphasis> Sebelum <command>systemd</command>"

msgid "<command>systemd</command> is a relatively recent “init system”, and although it was already available, to a certain extent, in <emphasis role=\"distribution\">Wheezy</emphasis>, it has only become the default in Debian <emphasis role=\"distribution\">Jessie</emphasis>. Previous releases relied, by default, on the “System V init” (in the <emphasis role=\"pkg\">sysv-rc</emphasis> package), a much more traditional system. We describe the System V init later on."
msgstr "<command>systemd</command> adalah ”sistem init” yang relatif baru, dan walaupun sudah tersedia, sampai batas tertentu, dalam <emphasis role=\"distribution\">Wheezy</emphasis>, itu hanya menjadi baku dalam Debian <emphasis role=\"distribution\">Jessie</emphasis>. Rilis-rilis sebelumnya mengandalkan, secara baku, ”init System V” (dalam paket <emphasis role=\"pkg\">sysv-rc</emphasis>), suatu sistem yang jauh lebih tradisional. Kami menjelaskan init System V belakangan."

msgid "<emphasis>ALTERNATIVE</emphasis> Other boot systems"
msgstr "<emphasis>ALTERNATIF</emphasis> Sistem boot lain"

msgid "This book describes the boot system used by default in Debian <emphasis role=\"distribution\">Buster</emphasis> (as implemented by the <emphasis role=\"pkg\">systemd</emphasis> package), as well as the previous default, <emphasis role=\"pkg\">sysvinit</emphasis>, which is derived and inherited from <emphasis>System V</emphasis> Unix systems; there are others."
msgstr "Buku ini menjelaskan sistem boot yang dipakai secara baku dalam Debian <emphasis role=\"distribution\">Buster</emphasis> (yang diimplementasikan oleh paket <emphasis role=\"pkg\">systemd</emphasis>), maupun baku sebelumnya, <emphasis role=\"pkg\">sysvinit</emphasis>, yang diturunkan dan diwariskan dari sistem Unix <emphasis>System V</emphasis>; ada juga yang lain."

msgid "<emphasis role=\"pkg\">file-rc</emphasis> is a boot system with a very simple process. It keeps the principle of runlevels, but replaces the directories and symbolic links with a configuration file, which indicates to <command>init</command> the processes that must be started and their launch order."
msgstr "<emphasis role=\"pkg\">file-rc</emphasis> adalah sistem boot dengan proses yang sangat sederhana. Mempertahankan prinsip runlevel, tapi menggantikan direktori dan taut simbolik dengan sebuah berkas konfigurasi, yang mengindikasikan ke <command>init</command> proses-proses yang mesti dimulai dan urutan peluncuran mereka."

msgid "The <command>upstart</command> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, was present in Debian <emphasis role=\"distribution\">Jessie</emphasis>, but was not the default; it came, in fact, as a replacement for <emphasis role=\"pkg\">sysvinit</emphasis>, and one of the tasks launched by <command>upstart</command> was to launch the scripts written for traditional systems, especially those from the <emphasis role=\"pkg\">sysv-rc</emphasis> package."
msgstr "Sistem <command>upstart</command> belum diuji secara sempurna pada Debian. Itu berbasis kejadian: skrip-skrip init tidak lagi dijalankan berurutan tapi sebagai respon atas kejadian seperti misalnya selesai dijalankannya skrip lain yang menjadi ketergantungannya. Sistem ini, dimulai oleh Ubuntu, ada dalam Debian <emphasis role=\"distribution\">Jessie</emphasis>, tapi tidak baku; itu hadir, faktanya, sebagai pengganti <emphasis role=\"pkg\">sysvinit</emphasis>, dan satu dari tugas yang diluncurkan oleh <command>upstrart</command> adalah untuk meluncurkan skrip-skrip yang ditulis untuk sistem-sistem tradisional, khususnya yang dari paket <emphasis role=\"pkg\">sysv-rc</emphasis>."

msgid "There are also other systems and other operating modes, such as <command>runit</command> or <command>minit</command>, but they are relatively specialized and not widespread."
msgstr "Ada juga sistem-sistem lain dan mode-mode operasi lain, seperti misalnya <command>runit</command> atau <command>minit</command>, tapi mereka relatif khusus dan tidak meluas."

msgid "Boot sequence of a computer running Linux with systemd"
msgstr "Urutan boot dari komputer yang menjalankan Linux dengan systemd"

msgid "<emphasis>SPECIFIC CASE</emphasis> Booting from the network"
msgstr "<emphasis>KASUS SPESIFIK</emphasis> Boot dari jaringan"

msgid "In some configurations, the BIOS may be configured not to execute the MBR, but to seek its equivalent on the network, making it possible to build computers without a hard drive, or which are completely reinstalled on each boot. This option is not available on all hardware and it generally requires an appropriate combination of BIOS and network card."
msgstr "Dalam beberapa konfigurasi, BIOS mungkin dikonfigurasi untuk tidak menjalankan MBR, tapi untuk mencari yang setara di jaringan, sehingga memungkinkan untuk membangun komputer tanpa hard drive, atau yang sepenuhnya diinstal ulang pada setiap boot. Opsi ini tidak tersedia pada semua perangkat keras dan umumnya memerlukan kombinasi kartu BIOS dan jaringan yang sesuai."

msgid "Booting from the network can be used to launch the <command>debian-installer</command> or FAI (see <xref linkend=\"sect.installation-methods\" />)."
msgstr "Boot dari jaringan dapat digunakan untuk meluncurkan <command>debian-installer</command> atau FAI (lihat <xref linkend=\"sect.installation-methods\" />."

msgid "<emphasis>BACK TO BASICS</emphasis> The process, a program instance"
msgstr "<emphasis>KEMBALI KE DASAR</emphasis> Proses, suatu instansi program"

msgid "<primary>process</primary>"
msgstr "<primary>proses</primary>"

msgid "A process is the representation in memory of a running program. It includes all of the information necessary for the proper execution of the software (the code itself, but also the data that it has in memory, the list of files that it has opened, the network connections it has established, etc.). A single program may be instantiated into several processes, not necessarily running under different user IDs."
msgstr "Sebuah proses adalah representasi dalam memori dari suau program yang sedang berjalan. Ini mencakup semua informasi yang diperlukan untuk menjalankan perangkat lunak dengan benar (kode itu sendiri, juga data yang dimilikinya dalam memori, daftar berkas yang telah dibukanya, koneksi jaringan yang telah dijalin, dll.). Satu program dapat diinstansikan ke beberapa proses, tidak perlu berjalan di bawah ID pengguna yang berbeda."

msgid "<emphasis>SECURITY</emphasis> Using a shell as <command>init</command> to gain root rights"
msgstr "<emphasis>KEAMANAN</emphasis> Memakai sebuah shell sebagai <command>init</command> untuk mendapatkan hak root"

msgid "By convention, the first process that is booted is the <command>init</command> program (which is a symbolic link to <filename>/lib/systemd/systemd</filename> by default). However, it is possible to pass an <literal>init</literal> option to the kernel indicating a different program."
msgstr "Menurut konvensi, proses pertama yang di-boot adalah program <command>init</command> (yang secara baku merupakan taut simbolik ke <filename>/lib/systemd/systemd</filename>). Namun, mungkin untuk melewatkan suatu opsi <literal>init</literal> ke kernel yang mengindikasikan suatu program lain."

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "Any person who is able to access the computer can press the <keycap>Reset</keycap> button, and thus reboot it. Then, at the bootloader's prompt, it is possible to pass the <literal>init=/bin/sh</literal> option to the kernel to gain root access without knowing the administrator's password."
msgstr "Sebarang orang yang dapat mengakses komputer bisa menekan tombol <keycap>Reset</keycap>, dan sehingga me-reboot. Kemudian, pada prompt bootloader, mungkin untuk melewatkan opsi <literal>init=/bin/sh</literal> ke kernel untuk mendapatkan akses root tanpa mengetahui sandi administrator."

msgid "To prevent this, you can protect the bootloader itself with a password. You might also think about protecting access to the BIOS (a password protection mechanism is almost always available), without which a malicious intruder could still boot the machine on a removable media containing its own Linux system, which they could then use to access data on the computer's hard drives."
msgstr "Untuk mencegah hal ini, Anda dapat melindungi bootloader sendiri dengan kata sandi. Anda juga mungkin berpikir tentang melindungi akses ke BIOS (mekanisme perlindungan sandi hampir selalu tersedia), yang tanpanya penyusup jahat masih bisa mem-boot mesin pada media lepas-pasang yang berisi sistem Linux sendiri, yang kemudian dapat digunakan untuk mengakses data pada hard drive komputer."

msgid "Finally, be aware that most BIOS have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…"
msgstr "Akhirnya, sadarilah bahwa kebanyakan BIOS memiliki password generik. Awalnya dimaksudkan untuk pemecahan masalah bagi mereka yang telah lupa password, password ini sekarang umum dan tersedia di Internet (lihat sendiri dengan mencari \"password BIOS generik\" di mesin pencari). Semua perlindungan ini justru akan menghambat akses tidak sah ke mesin tanpa bisa sepenuhnya mencegah itu. Tidak ada cara yang handal untuk melindungi komputer jika penyerang dapat secara fisik mengakses mereka; mereka bisa melepas hard drive untuk menghubungkan mereka ke komputer di bawah kendali mereka sendiri, atau bahkan mencuri seluruh mesin, atau menghapus memori BIOS untuk me-reset password…"

msgid "Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> pairs grouped between <literal>[<replaceable>section</replaceable>]</literal> headers. Unit files are stored under <filename>/lib/systemd/system/</filename> and <filename>/etc/systemd/system/</filename>; they come in several flavors, but we will focus on “services” and “targets” here."
msgstr "Systemd mengeksekusi beberapa proses, yang bertanggung jawab menyiapkan sistem: papan ketik, driver, sistem berkas, jaringan, layanan. Itu melakukan hal ini sambil menyimpan pandangan global sistem secara keseluruhan, serta kebutuhan komponen-komponen. Masing-masing komponen digambarkan oleh ”berkas unit” (kadang-kadang lebih); sintaks yang umum diturunkan dari sintaks ”berkas *.ini” yang banyak digunakan, dengan pasangan-pasangan <literal><replaceable>kunci</replaceable> = <replaceable>nilai</replaceable></literal> dikelompokkan antara header-header <literal>[<replaceable>section</replaceable>]</literal>. Berkas unit disimpan di bawah <filename>/lib/systemd/sistem/</filename> dan <filename>/etc/systemd/system/</filename>; mereka datang dalam beberapa rasa, tapi kami akan fokus pada ”layanan” dan ”target” di sini."

msgid "A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:"
msgstr "Suatu ”berkas layanan” systemd menggambarkan proses yang dikelola oleh systemd. Itu kurang lebih berisi informasi yang sama seperti init-script gaya lama, tetapi dinyatakan dalam cara yang deklaratif (dan jauh lebih ringkas). Systemd menangani sebagian besar tugas-tugas yang berulang (memulai dan menghentikan proses, memeriksa status, mencatat log, menurunkan hak, dan sebagainya), dan berkas layanan hanya perlu mengisi spesifik dari proses. Sebagai contoh, berikut adalah berkas layanan untuk SSH:"

msgid ""
"[Unit]\n"
"Description=OpenBSD Secure Shell server\n"
"After=network.target auditd.service\n"
"ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
"\n"
"[Service]\n"
"EnvironmentFile=-/etc/default/ssh\n"
"ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
"ExecReload=/bin/kill -HUP $MAINPID\n"
"KillMode=process\n"
"Restart=on-failure\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target\n"
"Alias=sshd.service"
msgstr ""
"[Unit]\n"
"Description=OpenBSD Secure Shell server\n"
"After=network.target auditd.service\n"
"ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
"\n"
"[Service]\n"
"EnvironmentFile=-/etc/default/ssh\n"
"ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
"ExecReload=/bin/kill -HUP $MAINPID\n"
"KillMode=process\n"
"Restart=on-failure\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target\n"
"Alias=sshd.service"

msgid "As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed."
msgstr "Seperti yang Anda lihat, ada sangat sedikit kode di sana, hanya deklarasi. Systemd mengurus penampilan laporan kemajuan, melacak proses, dan bahkan menjalankan ulang mereka bila diperlukan."

msgid "A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <literal>local-fs.target</literal>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <literal>network-online.target</literal> and <literal>sound.target</literal>. The dependencies of a target can be listed either within the target file (in the <literal>Requires=</literal> line), or using a symbolic link to a service file in the <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> directory. For instance, <filename>/etc/systemd/system/printer.target.wants/</filename> contains a link to <filename>/lib/systemd/system/cups.service</filename>; systemd will therefore ensure CUPS is running in order to reach <literal>printer.target</literal>."
msgstr "Suatu \"berkas target\" Systemd menggambarkan keadaan sistem, dimana satu set layanan diketahui beroperasi. Ini dapat dianggap sebagai setara runlevel gaya lama. Salah satu target adalah <literal>local-fs.target</literal>; ketika itu dicapai, sisa sistem bisa berasumsi bahwa seluruh sistem berkas lokal dikait dan dapat diakses. Target lain termasuk <literal>network-online.target</literal> dan <literal>sound.target</literal>. Dependensi target dapat dicantumkan baik dalam berkas target (di baris <literal>Requires</literal>), atau menggunakan symlink ke berkas layanan di direktori <literal>/lib/systemd/sistem/<replaceable>namatarget</replaceable>.target.wants/ </literal>. Sebagai contoh, <filename>/etc/systemd/system/printer.target.wants/</filename> berisi taut ke <filename>/lib/systemd/system/cups.service</filename>; systemd karena itu akan memastikan CUPS berjalan untuk mencapai <literal>printer.target</literal>."

msgid "Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component."
msgstr "Karena berkas unit deklaratif, bukan skrip atau program, mereka tidak dapat dijalankan secara langsung, dan mereka hanya ditafsirkan oleh systemd; beberapa utilitas karena itu memungkinkan administrator untuk berinteraksi dengan systemd dan mengendalikan keadaan sistem dan setiap komponen."

msgid "The first such utility is <command>systemctl</command>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <command>systemctl status</command> gives a better view of the services, as well as the related processes. If given the name of a service (as in <command>systemctl status ntp.service</command>), it returns even more details, as well as the last few log lines related to the service (more on that later)."
msgstr "Utilitas pertama yang seperti itu adalah <command>systemctl</command>. Ketika dijalankan tanpa argumen, itu menampilkan semua berkas unit yang dikenal systemd (kecuali yang dinonaktifkan), maupun status mereka. <command>systemctl status</command> memberikan pandangan yang lebih baik atas layanan, maupun proses-proses terkait. Bila nama yang diberikan pada suatu layanan (seperti dalam <command>systemctl status ntp.service</command>), itu bahkan mengembalikan lebih banyak rincian, maupun beberapa baris log terakhir yang terkait dengan layanan (lebih jauh tentang ini nanti)."

msgid "Starting a service by hand is a simple matter of running <command>systemctl start <replaceable>servicename</replaceable>.service</command>. As one can guess, stopping the service is done with <command>systemctl stop <replaceable>servicename</replaceable>.service</command>; other subcommands include <command>reload</command> and <command>restart</command>."
msgstr "Memulai suatu layanan secara manual hanya sekedar masalah menjalankan <command>systemctl start <replaceable>namalayanan</replaceable>.service</command>. Seperti dapat diduga, menghentikan layanan dilakukan dengan <command>systemctl stop <replaceable>namalayanan</replaceable>.service</command>; sub perintah lain termasuk <command>reload</command> dan <command>restart</command>."

msgid "To control whether a service is active (i.e. whether it will get started automatically on boot), use <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (or <command>disable</command>). <command>is-enabled</command> allows checking the status of the service."
msgstr "Untuk mengendalikan apakah suatu layanan aktif (yaitu apakah itu akan secara otomatis dijalankan saat boot), gunakan <command>systemctl enable <replaceable>namalayanan</replaceable>.service</command> (atau <command>disable</command>). <command>is-enabled</command> memungkinkan memeriksa status layanan."

msgid "An interesting feature of systemd is that it includes a logging component named <command>journald</command>. It comes as a complement to more traditional logging systems such as <command>syslogd</command>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialization sequence. The messages can be displayed later on, with a little help from the <command>journalctl</command> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:"
msgstr "Fitur menarik dari systemd adalah bahwa itu menyertakan komponen log bernama <command>journald</command>. Datang sebagai pelengkap untuk sistem log yang lebih tradisional seperti <command>syslogd</command>, tetapi itu menambahkan fitur-fitur menarik seperti kaitan formal antara suatu layanan dan pesan-pesan yang dihasilkannya, dan kemampuan untuk menangkap pesan kesalahan yang dihasilkan oleh urutan inisialisasi. Pesan dapat ditampilkan kemudian, dengan sedikit bantuan dari perintah <command>journalctl</command>. Tanpa argumen, itu hanya memunculkan semua pesan log yang terjadi sejak boot sistem; itu akan jarang digunakan dengan cara demikian. Kebanyakan, itu akan digunakan dengan suatu tanda pengenal layanan:"

msgid ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"

msgid "Another useful command-line flag is <command>-f</command>, which instructs <command>journalctl</command> to keep displaying new messages as they are emitted (much in the manner of <command>tail -f <replaceable>file</replaceable></command>)."
msgstr "Bendera baris perintah lain yang berguna adalah <command>-f</command>, yang memerintahkan <command>journalctl</command> untuk tetap menampilkan pesan baru seperti saat mereka dikeluarkan (seperti gaya <command>tail -f <replaceable>berkas</replaceable></command>)."

msgid "If a service doesn't seem to be working as expected, the first step to solve the problem is to check that the service is actually running with <command>systemctl status</command>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:"
msgstr "Jika suatu layanan tampaknya tidak bekerja seperti yang diharapkan, langkah pertama untuk memecahkan masalah adalah memeriksa apakah layanan memang sedang berjalan dengan <command>systemctl status</command>; jika tidak, dan pesan yang diberikan oleh perintah pertama tidak cukup untuk mendiagnosa masalah, periksa log yang dikumpulkan oleh journald tentang layanan tersebut. Sebagai contoh, asumsikan SSH server tidak bekerja:"

msgid ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"

msgid "After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running."
msgstr "Setelah memeriksa status layanan (gagal), kita melanjutkan memeriksa log; mereka menunjukkan satu kesalahan di berkas konfigurasi. Setelah menyunting berkas konfigurasi dan memperbaiki kesalahan, kita jalankan ulang layanan, kemudian memastikan bahwa itu memang berjalan."

msgid "<emphasis>GOING FURTHER</emphasis> Other types of unit files"
msgstr "<emphasis>LEBIH LANJUT</emphasis> Berkas unit tipe lain"

msgid "We have only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we will only list a few here:"
msgstr "Kami hanya menggambarkan kapabilitas systemd yang paling dasar dalam bagian ini. Itu menawarkan banyak fitur menarik lainnya; kami hanya akan mencantumkan beberapa di sini:"

msgid "socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <command>inetd</command>. See <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgstr "aktivasi soket: suatu berkas unit \"socket\" dapat digunakan untuk menggambarkan sebuah jaringan atau soket Unix yang dikelola oleh systemd; ini berarti bahwa soket akan diciptakan oleh systemd, dan layanan yang sebenarnya dapat dimulai saat diminta ketika datang upaya koneksi sebenarnya. Ini kurang lebih mereplikasi set fitur <command>inetd</command>. Lihat <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>."

msgid "timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <command>cron</command> features. See <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgstr "timer: suatu berkas unit \"timer\" menggambarkan peristiwa yang terjadi dengan frekuensi tetap atau pada waktu tertentu; ketika suatu layanan dikaitkan dengan sebuah timer, tugas terkait akan dijalankan setiap kali timer menembak. Hal ini memungkinkan mereplikasi sebagian dari fitur <command>cron</command>. Lihat <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>."

msgid "network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up."
msgstr "jaringan: suatu berkas unit \"network\" menjelaskan sebuah antarmuka jaringan, yang memungkinkan konfigurasi antarmuka tersebut serta mengungkapkan bahwa suatu layanan bergantung kepada satu antarmuka tertentu yang hidup."

msgid "The System V init system"
msgstr "Sistem init System V"

msgid "The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <filename>/etc/inittab</filename> file. The first program that is executed (which corresponds to the <emphasis>sysinit</emphasis> step) is <command>/etc/init.d/rcS</command>, a script that executes all of the programs in the <filename>/etc/rcS.d/</filename> directory. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>"
msgstr "Sistem init System V (yang akan kami namai init agar ringkas) mengeksekusi beberapa proses, mengikuti instruksi dari berkas <filename>/etc/inittab</filename>. Program pertama yang dijalankan (yang sesuai dengan langkah <emphasis>sysinit</emphasis>) adalah <command>/etc/init.d/rcS</command>, sebuah skrip yang menjalankan semua program di direktori <filename>/etc/rcS.d/</filename>. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm ><indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>"

msgid "Among these, you will find successively programs in charge of:"
msgstr "Di antara ini, Anda akan menemukan berturut-turut program-program yang bertanggung jawab atas:"

msgid "configuring the console's keyboard;"
msgstr "mengkonfigurasi papan ketik konsol;"

msgid "loading drivers: most of the kernel modules are loaded by the kernel itself as the hardware is detected; extra drivers are then loaded automatically when the corresponding modules are listed in <filename>/etc/modules</filename>;"
msgstr "memuat driver: sebagian besar modul kernel yang dimuat oleh kernel sendiri saat perangkat keras terdeteksi; driver tambahan kemudian dimuat secara otomatis ketika modul sesuai dicantumkan dalam <filename>/etc/modules</filename>;"

msgid "checking the integrity of filesystems;"
msgstr "memeriksa integritas sistem berkas;"

msgid "mounting local partitions;"
msgstr "mengait partisi lokal;"

msgid "configuring the network;"
msgstr "mengkonfigurasi jaringan;"

msgid "mounting network filesystems (NFS)."
msgstr "mengait network filesystems (NFS)."

msgid "<emphasis>BACK TO BASICS</emphasis> Kernel modules and options"
msgstr "<emphasis>KEMBALI KE DASAR</emphasis> Modul dan opsi kernel"

msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgstr "<primary>modul</primary><secondary>modul kernel</secondary>"

msgid "Kernel modules also have options that can be configured by putting some files in <filename>/etc/modprobe.d/</filename>. These options are defined with directives like this: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. Several options can be specified with a single directive if necessary."
msgstr "Modul kernel juga memiliki pilihan yang dapat dikonfigurasi dengan menempatkan beberapa berkas dalam <filename>/etc/modprobe.d/</filename>. Pilihan ini ditentukan dengan perintah seperti ini: <literal>options <replaceable>nama-modul</replaceable> <replaceable>nama-opsi</replaceable>=<replaceable>nilai-opsi</replaceable></literal>. Beberapa pilihan dapat dispesifikasikan dalam satu baris jika diperlukan."

msgid "These configuration files are intended for <command>modprobe</command> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). This program is provided by the <emphasis role=\"pkg\">kmod</emphasis> package."
msgstr "Berkas konfigurasi ini ditujukan untuk <command>modprobe</command> — program yang memuat suatu modul kernel dengan dependensinya (modul memang dapat memanggil modul lain). Program ini disediakan oleh paket <emphasis role=\"pkg\">kmod</emphasis>."

msgid "<primary><command>modprobe</command></primary>"
msgstr "<primary><command>modprobe</command></primary>"

msgid "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"

msgid "After this stage, <command>init</command> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <command>/etc/init.d/rc 2</command>, a script that starts all services which are listed in <filename>/etc/rc2.d/</filename> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <command>insserv</command>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <command>init</command> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <command>rsyslog</command>, or port assignment with <command>portmap</command>) are started first, followed by standard services and the graphical interface (<command>gdm3</command>)."
msgstr "Setelah tahap ini, <command>init</command> mengambil alih dan memulai program-program yang diaktifkan pada runlevel default (yang biasanya runlevel 2). Itu mengeksekusi <command>/etc/init.d/rc 2</command>, skrip yang memulai semua layanan yang tercantum dalam <filename>/etc/rc2.d/</filename> dan nama-nama yang mulai dengan huruf \"S\". Nomor dua-angka yang mengikuti secara historis digunakan untuk menentukan urutan dimulainya layanan, tetapi saat ini sistem boot default menggunakan <command>insserv</command>, yang menjadwalkan semuanya secara otomatis berdasarkan dependensi skrip. Setiap skrip boot dengan demikian menyatakan kondisi yang harus dipenuhi untuk memulai atau menghentikan layanan (misalnya, jika itu harus dimulai sebelum atau setelah layanan lain); <command>init</command> kemudian meluncurkan mereka dalam urutan yang memenuhi kondisi ini. Penomoran statis skrip karena itu tidak lagi dipertimbangkan (tapi mereka selalu harus mempunyai awal nama dengan \"S\" diikuti oleh dua digit dan nama sebenarnya dari skrip yang digunakan untuk dependensi). Umumnya, layanan dasar (seperti log dengan <command>rsyslog</command>), atau penugasan port dengan <command>portmap</command> yang mulai pertama, diikuti oleh layanan-layanan standar dan antarmuka grafis (<command>gdm3</command>)."

msgid "This dependency-based boot system makes it possible to automate re-numbering, which could be rather tedious if it had to be done manually, and it limits the risks of human error, since scheduling is conducted according to the parameters that are indicated. Another benefit is that services can be started in parallel when they are independent from one another, which can accelerate the boot process."
msgstr "Sistem boot berbasis ketergantungan ini memungkinkan mengotomatisasi penomoran ulang, yang bisa menjadi membosankan jika itu harus dilakukan secara manual, dan itu jadi membatasi resiko kesalahan manusia, karena penjadwalan dilakukan berdasarkan parameter yang ditunjukkan. Manfaat lain adalah bahwa layanan dapat dimulai secara paralel ketika mereka independen dari yang lain, yang dapat mempercepat proses boot."

msgid "<primary>runlevel</primary>"
msgstr "<primary>runlevel</primary>"

msgid "<primary>level, runlevel</primary>"
msgstr "<primary>level, runlevel</primary>"

msgid "<command>init</command> distinguishes several runlevels, so it can switch from one to another with the <command>telinit <replaceable>new-level</replaceable></command> command. Immediately, <command>init</command> executes <command>/etc/init.d/rc</command> again with the new runlevel. This script will then start the missing services and stop those that are no longer desired. To do this, it refers to the content of the <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (where <replaceable>X</replaceable> represents the new runlevel). Scripts starting with “S” (as in “Start”) are services to be started; those starting with “K” (as in “Kill”) are the services to be stopped. The script does not start any service that was already active in the previous runlevel."
msgstr "<command>init</command> membedakan beberapa runlevel, sehingga ia dapat beralih dari satu ke yang lain dengan perintah <command>telinit <replaceable>level-baru</replaceable></command>. Seketika, <command>init</command> mengeksekusi <command>/etc/init.d/rc</command> lagi dengan runlevel baru. Skrip ini kemudian akan memulai pelayanan yang kurang dan menghentikan yang tidak diinginkan. Untuk melakukan ini, mengacu pada isi <filename>/etc/rc <replaceable>X</replaceable> .d</filename> (dimana <replaceable>X</replaceable> mewakili runlevel baru). Skrip yang dimulai dengan \"S\" (seperti dalam \"Start\") adalah layanan yang akan dijalankan; yang dimulai dengan \"K\" (seperti \"Kill\") adalah layanan yang harus dihentikan. Skrip tidak memulai layanan apapun yang sudah aktif pada runlevel sebelumnya."

msgid "By default, System V init in Debian uses four different runlevels:"
msgstr "Secara default, init System V dalam Debian menggunakan empat runlevels yang berbeda:"

msgid "Level 0 is only used temporarily, while the computer is powering down. As such, it only contains many “K” scripts."
msgstr "Level 0 hanya digunakan sementara, ketika komputer menuju mati. Dengan demikian, itu hanya berisi banyak skrip \"K\"."

msgid "Level 1, also known as single-user mode, corresponds to the system in degraded mode; it includes only basic services, and is intended for maintenance operations where interactions with ordinary users are not desired."
msgstr "Level 1, juga dikenal sebagai mode pengguna tunggal, berkaitan dengan sistem dalam mode terdegradasi; itu termasuk hanya layanan dasar, dan ditujukan untuk operasi pemeliharaan dimana interaksi dengan pengguna biasa tidak diinginkan."

msgid "Level 2 is the level for normal operation, which includes networking services, a graphical interface, user logins, etc."
msgstr "Level 2 adalah tingkat untuk operasi normal, yang mencakup layanan jaringan, antarmuka grafis, pengguna login, dll."

msgid "Level 6 is similar to level 0, except that it is used during the shutdown phase that precedes a reboot."
msgstr "Level 6 ini mirip dengan tingkat 0, kecuali bahwa itu digunakan selama fase shutdown yang mendahului reboot."

msgid "Other levels exist, especially 3 to 5. By default they are configured to operate the same way as level 2, but the administrator can modify them (by adding or deleting scripts in the corresponding <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories) to adapt them to particular needs."
msgstr "Ada tingkat lain, terutama 3-5. Secara default mereka telah dikonfigurasi untuk beroperasi dengan cara yang sama sebagai tingkat 2, namun administrator dapat memodifikasi mereka (dengan menambahkan atau menghapus skrip di direktori <filename>/etc/rc<replaceable>X</replaceable>.d</filename> yang sesuai) untuk beradaptasi atas kebutuhan tertentu."

msgid "Boot sequence of a computer running Linux with System V init"
msgstr "Urutan boot dari komputer yang menjalankan Linux dengan init System V"

msgid "<primary>initialization script</primary>"
msgstr "<primary>skrip inisialisasi</primary>"

msgid "All the scripts contained in the various <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories are really only symbolic links — created upon package installation by the <command>update-rc.d</command> program — pointing to the actual scripts which are stored in <filename>/etc/init.d/</filename>. The administrator can fine tune the services available in each runlevel by re-running <command>update-rc.d</command> with adjusted parameters. The <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <literal>remove</literal> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <command>update-rc.d</command> has a somewhat convoluted interface, you may prefer using <command>rcconf</command> (from the <emphasis role=\"pkg\">rcconf</emphasis> package) which provides a more user-friendly interface."
msgstr "Semua skrip yang terkandung dalam berbagai direktori <filename>/etc/rc<replaceable>X</replaceable>.d</filename> benar-benar hanya link simbolik — dibuat saat instalasi paket oleh program <command>update-rc.d</command> — menunjuk ke skrip sebenarnya yang disimpan dalam <filename>/etc/init.d/</filename>. Administrator dapat menala layanan yang tersedia pada masing-masing runlevel dengan kembali menjalankan <command>update-rc.d</command> dengan parameter yang disesuaikan. Halaman manual <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> menjelaskan sintaks secara rinci. Harap dicatat bahwa menghapus semua link simbolik (dengan parameter <literal>remove</literal>) bukanlah metode yang baik untuk menonaktifkan layanan yang ada. Sebaliknya Anda hanya harus mengkonfigurasi itu untuk tidak mulai berjalan pada runlevel yang diinginkan (sambil mempertahankan panggilan yang sesuai untuk menghentikannya apabila layanan berjalan pada runlevel sebelumnya). Karena <command>update-rc.d</command> memiliki antarmuka yang agak rumit, Anda mungkin lebih suka menggunakan <command>rcconf</command> (dari paket <emphasis role=\"pkg\">rcconf</emphasis>) yang menyediakan antar muka yang lebih mudah dipakai."

msgid "<primary><command>update-rc.d</command></primary>"
msgstr "<primary><command>update-rc.d</command></primary>"

msgid "<emphasis>DEBIAN POLICY</emphasis> Restarting services"
msgstr "<emphasis>KEBIJAKAN DEBIAN</emphasis> Restart layanan"

msgid "<primary><command>invoke-rc.d</command></primary>"
msgstr "<primary><command>invoke-rc.d</command></primary>"

msgid "<primary>service</primary><secondary>restart</secondary>"
msgstr "<primary>service</primary><secondary>restart</secondary>"

msgid "<primary>restarting services</primary>"
msgstr "<primary>menjalankan ulang layanan</primary>"

msgid "The maintainer scripts for Debian packages will sometimes restart certain services to ensure their availability or get them to take certain options into account. The command that controls a service — <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> — doesn't take runlevel into consideration, assumes (wrongly) that the service is currently being used, and may thus initiate incorrect operations (starting a service that was deliberately stopped, or stopping a service that is already stopped, etc.). Debian therefore introduced the <command>invoke-rc.d</command> program: this program must be used by maintainer scripts to run services initialization scripts and it will only execute the necessary commands. Note that, contrary to common usage, the <filename>.d</filename> suffix is used here in a program name, and not in a directory."
msgstr "Skrip pengelola paket Debian kadang-kadang akan me-restart layanan tertentu untuk memastikan ketersediaan mereka atau membuat mereka memperhitungkan opsi tertentu. Perintah yang mengontrol layanan — <command>service <replaceable>layanan</replaceable> <replaceable>operasi</replaceable></command> — tidak mempertimbangkan runlevel, (salah) mengasumsikan bahwa layanan ini sedang digunakan, dan mungkin dengan demikian memulai operasi salah (memulai layanan yang sengaja dihentikan, atau menghentikan layanan yang sudah dihentikan, dll.). Maka Debian memperkenalkan program <command>invoke-rc.d</command>: program ini harus digunakan oleh pengelola skrip untuk menjalankan skrip inisialisasi layanan dan itu hanya akan menjalankan perintah yang diperlukan. Catat bahwa, bertentangan dengan penggunaan umum, akhiran <filename>.d</filename> yang digunakan di sini di dalam nama program, dan bukan dalam sebuah direktori."

msgid "Finally, <command>init</command> starts control programs for various virtual consoles (<command>getty</command>). It displays a prompt, waiting for a username, then executes <command>login <replaceable>user</replaceable></command> to initiate a session."
msgstr "Akhirnya, <command>init</command> memulai program kontrol untuk berbagai konsol virtual (<command>getty</command>). Menampilkan sebuah prompt, menunggu nama pengguna, kemudian mengeksekusi <command>login <replaceable>pengguna</replaceable></command> untuk memulai sesi."

msgid "<primary><command>getty</command></primary>"
msgstr "<primary><command>getty</command></primary>"

msgid "<emphasis>VOCABULARY</emphasis> Console and terminal"
msgstr "<emphasis>KOSA KATA</emphasis> Konsol dan terminal"

msgid "The first computers were usually separated into several, very large parts: the storage enclosure and the central processing unit were separate from the peripheral devices used by the operators to control them. These were part of a separate furniture, the “console”. This term was retained, but its meaning has changed. It has become more or less synonymous with “terminal”, being a keyboard and a screen."
msgstr "Komputer pertama biasanya dipisahkan menjadi beberapa bagian yang sangat besar: kandang penyimpanan dan unit pemroses sentral yang terpisah dari perangkat periferal yang digunakan oleh operator untuk mengendalikan mereka. Ini adalah bagian dari furnitur yang terpisah, \"konsol\". Istilah ini dipertahankan, tapi artinya berubah. Hal ini kurang lebih identik dengan \"terminal\", karena berupa sebuah papan ketik dan suatu layar."

msgid "With the development of computers, operating systems have offered several virtual consoles to allow for several independent sessions at the same time, even if there is only one keyboard and screen. Most GNU/Linux systems offer six virtual consoles (in text mode), accessible by typing the key combinations <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> through <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>."
msgstr "Dengan perkembangan komputer, sistem operasi telah menawarkan beberapa konsol virtual untuk memungkinkan beberapa sesi independen pada saat yang sama, bahkan jika ada hanya satu papan ketik dan layar. Kebanyakan sistem GNU/Linux menawarkan enam virtual konsol (dalam modus teks), dapat diakses dengan mengetikkan kombinasi tombol <keycombo action=\"simul\"><keycap>Control</keycap> <keycap>Alt</keycap><keycap>F1</keycap></keycombo> sampai <keycombo action=\"simul\"><keycap>Control</keycap><keycap>Alt</keycap><keycap>F6</keycap></keycombo>."

msgid "By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical X11 session (such as <command>xterm</command>, <command>gnome-terminal</command> or <command>konsole</command>)."
msgstr "Diperluas, istilah \"konsol\" dan \"terminal\" juga dapat merujuk ke emulator terminal dalam sesi X11 grafis (seperti misalnya <command>xterm</command>, <command>gnome-terminal</command>, atau <command>konsole</command>)."

msgid "Remote Login"
msgstr "Log Masuk Jarak Jauh"

msgid "It is essential for an administrator to be able to connect to a computer remotely. Servers, confined in their own room, are rarely equipped with permanent keyboards and monitors — but they are connected to the network."
msgstr "Sangat penting bagi administrator untuk dapat menyambung ke suatu komputer dari jarak jauh. Server, dikurung dalam kamar mereka sendiri, jarang dilengkapi dengan papan ketik dan monitor permanen — tetapi mereka terhubung ke jaringan."

msgid "<emphasis>BACK TO BASICS</emphasis> Client, server"
msgstr "<emphasis>KEMBALI KE DASAR</emphasis> Klien, server"

msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>klien</primary><secondary>arsitektur klien/server</secondary>"

msgid "<primary>server</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>server</primary><secondary>arsitektur klien/server</secondary>"

msgid "A system where several processes communicate with each other is often described with the “client/server” metaphor. The server is the program that takes requests coming from a client and executes them. It is the client that controls operations, the server doesn't take any initiative of its own."
msgstr "Sebuah sistem yang beberapa prosesnya berkomunikasi satu sama lain sering digambarkan dengan metafora \"klien/server\". Server adalah program yang mengambil permintaan yang datang dari klien dan mengeksekusi mereka. Ini adalah klien yang mengendalikan operasi, server tidak mengambil setiap inisiatif sendiri."

msgid "<primary>login</primary><secondary>remote login</secondary>"
msgstr "<primary>login</primary><secondary>login jarak jauh</secondary>"

msgid "<primary>remote login</primary>"
msgstr "<primary>login jarak jauh</primary>"

msgid "Secure Remote Login: SSH"
msgstr "Login Jarak Jauh Aman: SSH"

msgid "<primary>SSH</primary>"
msgstr "<primary>SSH</primary>"

msgid "<primary>Secure Shell</primary>"
msgstr "<primary>Secure Shell</primary>"

msgid "The <emphasis>SSH</emphasis> (Secure SHell) protocol was designed with security and reliability in mind. Connections using SSH are secure: the partner is authenticated and all data exchanges are encrypted."
msgstr "Protokol <emphasis>SSH</emphasis> (Secure SHell) dirancang dengan keamanan dan kehandalan. Koneksi yang menggunakan SSH aman: mitra diotentikasi dan semua pertukaran data dienkripsi."

msgid "<emphasis>CULTURE</emphasis> Telnet and RSH are obsolete"
msgstr "<emphasis>BUDAYA</emphasis> Telnet dan RSH itu usang"

msgid "<primary><command>telnet</command></primary>"
msgstr "<primary><command>telnet</command></primary>"

msgid "<primary><command>rsh</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

msgid "Before SSH, <emphasis>Telnet</emphasis> and <emphasis>RSH</emphasis> were the main tools used to login remotely. They are now largely obsolete and should no longer be used even if Debian still provides them."
msgstr "Sebelum SSH, <emphasis>Telnet</emphasis> dan <emphasis>RSH</emphasis> adalah alat utama yang digunakan untuk login jarak jauh. Mereka sekarang sebagian besar usang dan sebaiknya tidak lagi digunakan bahkan walaupun Debian masih menyediakan mereka."

msgid "<emphasis>VOCABULARY</emphasis> Authentication, encryption"
msgstr "<emphasis>KOSAKATA</emphasis> Otentikasi, enkripsi"

msgid "When you need to give a client the ability to conduct or trigger actions on a server, security is important. You must ensure the identity of the client; this is authentication. This identity usually consists of a password that must be kept secret, or any other client could get the password. This is the purpose of encryption, which is a form of encoding that allows two systems to communicate confidential information on a public channel while protecting it from being readable to others."
msgstr "Ketika Anda perlu memberikan klien kemampuan untuk melakukan atau memicu tindakan pada server, keamanan penting. Anda harus memastikan identitas dari klien; ini adalah otentikasi. Identitas ini biasanya terdiri dari password yang harus dirahasiakan, atau klien lain jadi bisa mendapatkankan password tersebut. Ini adalah tujuan dari enkripsi, yang merupakan bentuk enkoding yang memungkinkan dua sistem untuk mengkomunikasikan informasi rahasia pada saluran umum sekaligus melindungi dari dapat dibaca oleh orang lain."

msgid "Authentication and encryption are often mentioned together, both because they are frequently used together, and because they are usually implemented with similar mathematical concepts."
msgstr "Otentikasi dan enkripsi sering disebut bersama, baik karena mereka sering digunakan bersama-sama, dan karena mereka biasanya diimplementasikan dengan konsep-konsep matematika yang serupa."

msgid "SSH also offers two file transfer services. <command>scp</command> is a command line tool that can be used like <command>cp</command>, except that any path to another machine is prefixed with the machine's name, followed by a colon."
msgstr "SSH juga menawarkan dua layanan transfer berkas. <command>SCP</command> adalah alat baris perintah yang dapat digunakan seperti <command>cp</command>, kecuali bahwa sebarang path ke mesin lain diawali dengan nama mesin, diikuti oleh titik dua."

msgid "<computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput>"
msgstr "<computeroutput>$ </computeroutput><userinput>scp berkas mesin:/tmp/</userinput>"

msgid "<command>sftp</command> is an interactive command, similar to <command>ftp</command>. In a single session, <command>sftp</command> can transfer several files, and it is possible to manipulate remote files with it (delete, rename, change permissions, etc.)."
msgstr "<command>sftp</command> adalah perintah yang interaktif, mirip dengan <command>ftp</command>. Dalam satu sesi, <command>sftp</command> dapat mentransfer beberapa berkas, dan mungkin untuk memanipulasi berkas remote dengannya (menghapus, mengubah nama, mengubah hak akses, dll)."

msgid "<primary><command>scp</command></primary>"
msgstr "<primary><command>scp</command></primary>"

msgid "<primary><command>sftp</command></primary>"
msgstr "<primary><command>sftp</command></primary>"

msgid "Debian uses OpenSSH, a free version of SSH maintained by the <command>OpenBSD</command> project (a free operating system based on the BSD kernel, focused on security) and fork of the original SSH software developed by the SSH Communications Security Corp company, of Finland. This company initially developed SSH as free software, but eventually decided to continue its development under a proprietary license. The OpenBSD project then created OpenSSH to maintain a free version of SSH."
msgstr "Debian menggunakan OpenSSH, sebuah SSH versi gratis yang dikelola oleh proyek <command>OpenBSD</command> (sistem operasi bebas berbasis pada kernel BSD, berfokus pada keamanan) dan fork dari perangkat lunak SSH asli yang dikembangkan oleh perusahaan SSH Communication Corp, dari Finlandia. Perusahaan ini awalnya mengembangkan SSH sebagai perangkat lunak bebas, tetapi akhirnya memutuskan untuk melanjutkan perkembangan di bawah lisensi tak bebas. Proyek OpenBSD kemudian menciptakan OpenSSH untuk mempertahankan versi gratis dari SSH."

msgid "<primary>OpenSSH</primary>"
msgstr "<primary>OpenSSH</primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> <foreignphrase>Fork</foreignphrase>"
msgstr "<emphasis>KEMBALI KE DASAR</emphasis> <foreignphrase>Fork</foreignphrase>"

msgid "<primary>fork</primary>"
msgstr "<primary>fork</primary>"

msgid "A “fork”, in the software field, means a new project that starts as a clone of an existing project, and that will compete with it. From there on, both software will usually quickly diverge in terms of new developments. A fork is often the result of disagreements within the development team."
msgstr "\"Fork\", dalam bidang perangkat lunak, berarti sebuah proyek baru yang dimulai sebagai klon dari proyek yang sudah ada, dan akan bersaing dengannya. Dari sana, kedua perangkat lunak biasanya cepat akan menyimpang dalam hal perkembangan baru. Fork ini sering merupakan akibat dari perselisihan dalam tim pengembangan."

msgid "The option to fork a project is a direct result of the very nature of free software; a fork is a healthy event when it enables the continuation of a project as free software (for example in case of license changes). A fork arising from technical or personal disagreements is often a waste of human resources; another resolution would be preferable. Mergers of two projects that previously went through a prior fork are not unheard of."
msgstr "Pilihan untuk melakukan fork atas sebuah proyek adalah akibat langsung dari sifat perangkat lunak bebas; fork merupakan kejadian yang sehat saat itu memungkinkan keberlanjutan proyek sebagai perangkat lunak bebas (misalnya dalam kasus perubahan lisensi). Sebuah fork yang timbul dari perselisihan teknis atau pribadi sering membuang-buang sumber daya manusia; resolusi lain akan lebih baik. Merger dua proyek yang sebelumnya mengalami fork bukan tidak pernah terjadi."

msgid "OpenSSH is split into two packages: the client part is in the <emphasis role=\"pkg\">openssh-client</emphasis> package, and the server is in the <emphasis role=\"pkg\">openssh-server</emphasis> package. The <emphasis role=\"pkg\">ssh</emphasis> meta-package depends on both parts and facilitates installation of both (<command>apt install ssh</command>)."
msgstr "OpenSSH dipecah menjadi dua paket: bagian klien dalam paket <emphasis role=\"pkg\">openssh-client</emphasis>, dan server dalam paket <emphasis role=\"pkg\">openssh-server</emphasis>. Meta-paket <emphasis role=\"pkg\">ssh</emphasis> bergantung pada kedua bagian dan memfasilitasi instalasi keduanya (<command>apt install ssh</command>)."

msgid "Key-Based Authentication"
msgstr "Otentikasi Berbasis Kunci"

msgid "Each time someone logs in over SSH, the remote server asks for a password to authenticate the user. This can be problematic if you want to automate a connection, or if you use a tool that requires frequent connections over SSH. This is why SSH offers a key-based authentication system."
msgstr "Setiap kali seseorang log masuk melalui SSH, server remote meminta password untuk mengotentikasi pengguna. Ini bisa menjadi bermasalah jika Anda ingin mengotomatisasi sambungan, atau jika Anda menggunakan alat yang membutuhkan koneksi sering melalui SSH. Inilah sebabnya mengapa SSH menawarkan sistem otentikasi berbasis kunci."

msgid "The user generates a key pair on the client machine with <command>ssh-keygen -t rsa</command>; the public key is stored in <filename>~/.ssh/id_rsa.pub</filename>, while the corresponding private key is stored in <filename>~/.ssh/id_rsa</filename>. The user then uses <command>ssh-copy-id <replaceable>server</replaceable></command> to add their public key to the <filename>~/.ssh/authorized_keys</filename> file on the server. If the private key was not protected with a “passphrase” at the time of its creation, all subsequent logins on the server will work without a password. Otherwise, the private key must be decrypted each time by entering the passphrase. Fortunately, <command>ssh-agent</command> allows us to keep private keys in memory to not have to regularly re-enter the password. For this, you simply use <command>ssh-add</command> (once per work session) provided that the session is already associated with a functional instance of <command>ssh-agent</command>. Debian activates it by default in graphical sessions, but this can be deactivated by changing <filename>/etc/X11/Xsession.options</filename>. For a console session, you can manually start it with <command>eval $(ssh-agent)</command>."
msgstr "Pengguna membuat sepasang kunci pada mesin klien dengan <command>ssh-keygen-t rsa</command>; kunci publik disimpan dalam <filename>~/.ssh/id_rsa.pub</filename>, sementara kunci privat disimpan dalam <filename>~/.ssh/id_rsa</filename>. Pengguna kemudian menggunakan <command>ssh-copy-id <replaceable>server</replaceable></command> untuk menambahkan kunci publik mereka ke berkas <filename>~/.ssh/authorized_keys</filename> pada server. Jika kunci privat tidak dilindungi dengan \"frasa sandi\" pada saat penciptaan, semua login berikutnya pada server akan bekerja tanpa kata sandi. Sebaliknya, kunci pribadi harus didekripsi setiap kali dengan memasukkan kata sandi. Untungnya, <command>ssh-agent</command> memungkinkan kita untuk menjaga kunci privat dalam memori untuk tidak perlu secara teratur memasukkan kembali kata sandi. Untuk ini, Anda hanya menggunakan <command>ssh-add</command> (sekali per sesi) asalkan sesi sudah terkait dengan instansi fungsional <command>ssh-agent</command>. Debian mengaktifkannya secara default dalam sesi grafis, tapi ini dapat dinonaktifkan dengan mengubah <filename>/etc/X11/Xsession.options</filename>. Untuk sesi konsol, Anda dapat secara manual memulainya dengan <command>eval $(ssh-agent)</command>."

msgid "<emphasis>SECURITY</emphasis> Protection of the private key"
msgstr "<emphasis>KEAMANAN</emphasis> Perlindungan kunci privat"

msgid "Whoever has the private key can login on the account thus configured. This is why access to the private key is protected by a “passphrase”. Someone who acquires a copy of a private key file (for example, <filename>~/.ssh/id_rsa</filename>) still has to know this phrase in order to be able to use it. This additional protection is not, however, impregnable, and if you think that this file has been compromised, it is best to disable that key on the computers in which it has been installed (by removing it from the <filename>authorized_keys</filename> files) and replacing it with a newly generated key."
msgstr "Barangsiapa memiliki kunci privat tersebut dapat login di akun yang dikonfigurasi. Inilah sebabnya mengapa akses ke kunci privat dilindungi oleh \"frasa sandi\". Seseorang yang memperoleh salinan berkas kunci pribvat (misalnya, <filename>~/.ssh/id_rsa</filename>) masih harus tahu frasa ini agar dapat menggunakannya. Perlindungan tambahan ini tidak anti tembus, dan jika Anda berpikir bahwa berkas ini telah dikompromikan, paling baik untuk menonaktifkan kunci tersebut pada komputer tempat itu telah diinstal (dengan menghapus dari berkas <filename>authorized_keys</filename>) dan menggantikannya dengan kunci baru yang dibuat."

msgid "<emphasis>CULTURE</emphasis> OpenSSL flaw in Debian <emphasis role=\"distribution\">Etch</emphasis>"
msgstr "<emphasis>KULTUR</emphasis> Cacat OpenSSL dalam Debian <emphasis role=\"distribution\">Etch</emphasis>"

msgid "The OpenSSL library, as initially provided in Debian <emphasis role=\"distribution\">Etch</emphasis>, had a serious problem in its random number generator (RNG). Indeed, the Debian maintainer had made a change so that applications using it would no longer generate warnings when analyzed by memory testing tools like <command>valgrind</command>. Unfortunately, this change also meant that the RNG was employing only one source of entropy corresponding to the process number (PID) whose 32,000 possible values do not offer enough randomness. <ulink type=\"block\" url=\"https://www.debian.org/security/2008/dsa-1571\" />"
msgstr "Pustaka OpenSSL, sebagaimana awalnya disediakan di Debian <emphasis role=\"distribution\">Etch</emphasis>, memiliki masalah yang serius dalam pembangkit angka acak (RNG). Memang, pengelola Debian telah membuat perubahan sehingga aplikasi yang menggunakan itu tidak lagi menghasilkan peringatan ketika dianalisis oleh alat pengujian memori seperti <command>valgrind</command>. Sayangnya, perubahan ini juga berarti bahwa RNG hanya mempekerjakan salah satu sumber entropi sesuai dengan nomor proses (PID) yang 32.000 kemungkinan nilainya tidak menawarkan cukup keacakan. <ulink type=\"block\" url=\"https://www.debian.org/security/2008/dsa-1571\" />"

msgid "Specifically, whenever OpenSSL was used to generate a key, it always produced a key within a known set of hundreds of thousands of keys (32,000 multiplied by a small number of key lengths). This affected SSH keys, SSL keys, and X.509 certificates used by numerous applications, such as OpenVPN. A cracker had only to try all of the keys to gain unauthorized access. To reduce the impact of the problem, the SSH daemon was modified to refuse problematic keys that are listed in the <emphasis role=\"pkg\">openssh-blacklist</emphasis> and <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis> packages. Additionally, the <command>ssh-vulnkey</command> command allows identification of possibly compromised keys in the system."
msgstr "Secara khusus, setiap kali OpenSSL digunakan untuk menghasilkan sebuah kunci, itu selalu menghasilkan kunci dalam kumpulan ratusan ribu kunci yang dikenal (32.000 dikalikan dengan sejumlah kecil panjang kunci). Ini mempengaruhi kunci SSH, kunci SSL, dan sertifikat X.509 yang digunakan oleh banyak aplikasi, seperti misalnya OpenVPN. Seorang cracker hanya perlu mencoba semua kunci untuk mendapatkan akses yang tidak sah. Untuk mengurangi dampak dari masalah, SSH daemon diubah untuk menolak bermasalah kunci yang tercantum dalam paket <emphasis role=\"pkg\">openssh-blacklist</emphasis> dan <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis>. Selain itu, perintah <command>ssh-vulnkey</command> memungkinkan identifikasi kunci yang mungkin terkompromikan dalam sistem."

msgid "A more thorough analysis of this incident brings to light that it is the result of multiple (small) problems, both within the OpenSSL project and with the Debian package maintainer. A widely used library like OpenSSL should — without modifications — not generate warnings when tested by <command>valgrind</command>. Furthermore, the code (especially the parts as sensitive as the RNG) should be better commented to prevent such errors. On Debian's side, the maintainer wanted to validate the modifications with the OpenSSL developers, but simply explained the modifications without providing the corresponding patch to review and failed to mention his role within Debian. Finally, the maintenance choices were sub-optimal: the changes made to the original code were not clearly documented; all the modifications were effectively stored in a Subversion repository, but they ended up all lumped into one single patch during creation of the source package."
msgstr "Analisis lebih mendalam terhadap kejadian ini mengungkap bahwa itu adalah hasil dari beberapa masalah (kecil), baik dalam proyek OpenSSL dan dengan para pengelola paket Debian. Sebuah perpustakaan yang banyak digunakan seperti OpenSSL harus — tanpa modifikasi — tidak menghasilkan peringatan saat diuji oleh <command>valgrind</command>. Selain itu, kode (terutama bagian RNG yang sensitif) harus memuat komentar yang lebih baik untuk mencegah kesalahan tersebut. Di sisi Debian, pengelola ingin memvalidasi modifikasi dengan pengembang OpenSSL, tetapi hanya menjelaskan modifikasi tanpa memberikan patch yang sesuai untuk ditinjau dan gagal untuk menyebutkan perannya dalam Debian. Akhirnya, pilihan-pilihan perawatan sub-optimal: perubahan yang dibuat ke kode asli tidak didokumentasikan jelas; semua modifikasi secara efektif tersimpan dalam repositori Subversion, tapi mereka akhirnya semua digabung ke dalam satu patch selama penciptaan sumber paket."

msgid "It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type=\"block\" url=\"https://sources.debian.org\" />"
msgstr "Sulit dalam kondisi seperti ini untuk menemukan tindakan korektif demi mencegah insiden tersebut dari berulang. Pelajaran yang bisa dipetik di sini adalah bahwa setiap perbedaan yang diperkenalkan Debian ke perangkat lunak hulu harus dijustifikasi, didokumentasikan, diserahkan kepada proyek hulu bila mungkin, dan dipublikasikan secara luas. Dari perspektif inilah format paket sumber baru (\"3.0 (quilt)\") dan layanan web sumber Debian dikembangkan. <ulink type=\"block\" url=\"https://sources.debian.net\" />"

msgid "Using Remote X11 Applications"
msgstr "Menggunakan Aplikasi-aplikasi X11 Jarak Jauh"

msgid "The SSH protocol allows forwarding of graphical data (“X11” session, from the name of the most widespread graphical system in Unix); the server then keeps a dedicated channel for those data. Specifically, a graphical program executed remotely can be displayed on the X.org server of the local screen, and the whole session (input and display) will be secure. Since this feature allows remote applications to interfere with the local system, it is disabled by default. You can enable it by specifying <literal>X11Forwarding yes</literal> in the server configuration file (<filename>/etc/ssh/sshd_config</filename>). Finally, the user must also request it by adding the <literal>-X</literal> option to the <command>ssh</command> command-line."
msgstr "Protokol SSH memungkinkan penerusan data grafis (sesi \"X11\", dari nama sistem grafis yang paling terkenal di Unix); server kemudian mempertahankan saluran khusus untuk data tersebut. Secara khusus, program grafis yang dijalankan dari jarak jauh dapat ditampilkan pada layar lokal server XFree86, dan seluruh sesi (masukan dan tampilan) akan aman. Karena fitur ini memungkinkan aplikasi remote untuk mengganggu sistem lokal, ini dinonaktifkan secara default. Anda dapat mengaktifkannya dengan menetapkan <literal>X11Forwarding yes</literal> di berkas konfigurasi server (<filename>/etc/ssh/sshd_config</filename>). Akhirnya, pengguna juga harus memintanya dengan menambahkan opsi <literal>-X</literal> untuk baris perintah <command>ssh</command>."

msgid "Creating Encrypted Tunnels with Port Forwarding"
msgstr "Menciptakan Tunnel Terenkripsi dengan Penerusan Port"

msgid "<primary>port forwarding</primary>"
msgstr "<primary>penerusan port</primary>"

msgid "Its <literal>-R</literal> and <literal>-L</literal> options allow <command>ssh</command> to create “encrypted tunnels” between two machines, securely forwarding a local TCP port (see sidebar <xref linkend=\"sidebar.tcp-udp\" />) to a remote machine or vice versa."
msgstr "Opsi <literal>-R</literal> dan <literal>-L</literal> memungkinkan <command>ssh</command> untuk menciptakan \"terowongan terenkripsi\" antara dua mesin, secara aman meneruskan port TCP lokal (lihat sidebar <xref linkend=\"sidebar.tcp-udp\" />) ke mesin remote atau sebaliknya."

msgid "<emphasis>VOCABULARY</emphasis> Tunnel"
msgstr "<emphasis>KOSAKATA</emphasis> Tunnel"

msgid "<primary>tunnel (SSH)</primary><seealso>VPN</seealso>"
msgstr "<primary>tunnel (SSH)</primary><seealso>VPN</seealso>"

msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgstr "<primary>SSH tunnel</primary><seealso>VPN</seealso>"

msgid "The Internet, and most LANs that are connected to it, operate in packet mode and not in connected mode, meaning that a packet issued from one computer to another is going to be stopped at several intermediary routers to find its way to its destination. You can still simulate a connected operation where the stream is encapsulated in normal IP packets. These packets follow their usual route, but the stream is reconstructed unchanged at the destination. We call this a “tunnel”, analogous to a road tunnel in which vehicles drive directly from the entrance (input) to the exit (output) without encountering any intersections, as opposed to a path on the surface that would involve intersections and changing direction."
msgstr "Internet, dan kebanyakan LAN yang terhubung, beroperasi dalam mode paket dan tidak dalam modus yang terhubung, berarti bahwa paket yang diterbitkan dari satu komputer ke yang lain akan berhenti di beberapa router perantara untuk menemukan jalan ke tujuan. Anda masih dapat mensimulasikan operasi yang terhubung dimana stream dibungkus dalam paket-paket IP normal. Paket ini mengikuti rute biasa mereka, tapi stream ini direkonstruksi tidak berubah di tujuan. Kami menyebutnya \"tunnel\", analog dengan terowongan jalan tempat kendaraan langsung berjalan dari pintu masuk (masukan) ke tempat keluar (keluaran) tanpa menemui persimpangan apapun, dibandingkan dengan jalur pada permukaan yang akan melibatkan persimpangan dan mengubah arah."

msgid "You can use this opportunity to add encryption to the tunnel: the stream that flows through it is then unrecognizable from the outside, but it is returned in decrypted form at the exit of the tunnel."
msgstr "Anda dapat menggunakan kesempatan ini untuk menambahkan enkripsi ke tunnel: stream yang mengalir melaluinya kemudian tidak dikenali dari luar, tapi dikembalikan ke dalam bentuk terdekripsi di pintu keluar tunnel."

msgid "<command>ssh -L 8000:server:25 intermediary</command> establishes an SSH session with the <replaceable>intermediary</replaceable> host and listens to local port 8000 (see <xref linkend=\"figure.ssh-L\" />). For any connection established on this port, <command>ssh</command> will initiate a connection from the <replaceable>intermediary</replaceable> computer to port 25 on the <replaceable>server</replaceable>, and will bind both connections together."
msgstr "<command>ssh -L 8000:server:25 perantara</command> menjalin suatu sesi SSH dengan host <replaceable>perantara</replaceable> dan mendengarkan port lokal 8000 (lihat <xref linkend=\"figure.ssh-L\" />). Untuk sebarang koneksi yang terjalin pada port ini, <command>ssh</command> akan memulai koneksi dari komputer <replaceable>perantara</replaceable> ke port 25 pada <replaceable>server</replaceable>, dan akan mengikat kedua koneksi bersama-sama."

msgid "<command>ssh -R 8000:server:25 intermediary</command> also establishes an SSH session to the <replaceable>intermediary</replaceable> computer, but it is on this machine that <command>ssh</command> listens to port 8000 (see <xref linkend=\"figure.ssh-R\" />). Any connection established on this port will cause <command>ssh</command> to open a connection from the local machine on to port 25 of the <replaceable>server</replaceable>, and to bind both connections together."
msgstr "<command>ssh -R 8000:server:25 perantara</command> juga menjalin sesi SSH ke komputer <replaceable>perantara</replaceable>, tetapi pada mesin ini <command>ssh</command> mendengarkan port 8000 (lihat <xref linkend=\"figure.ssh-R\" />). Sebarang koneksi yang dijalin pada port ini akan menyebabkan <command>ssh</command> membuka koneksi dari mesin lokal ke port 25 <replaceable>server</replaceable> dan mengikat kedua koneksi bersama-sama."

msgid "In both cases, connections are made to port 25 on the <replaceable>server</replaceable> host, which pass through the SSH tunnel established between the local machine and the <replaceable>intermediary</replaceable> machine. In the first case, the entrance to the tunnel is local port 8000, and the data move towards the <replaceable>intermediary</replaceable> machine before being directed to the <replaceable>server</replaceable> on the “public” network. In the second case, the input and output in the tunnel are reversed; the entrance is port 8000 on the <replaceable>intermediary</replaceable> machine, the output is on the local host, and the data are then directed to the <replaceable>server</replaceable>. In practice, the server is usually either the local machine or the intermediary. That way SSH secures the connection from one end to the other."
msgstr "Dalam kedua kasus, sambungan dibuat ke port 25 pada host <replaceable>server</replaceable>, melewati tunnel SSH yang dijalin antara mesin lokal dan mesin <replaceable>perantara</replaceable>. Dalam kasus pertama, pintu masuk ke tunnel adalah port lokal 8000, dan data bergerak menuju mesin <replaceable>perantara</replaceable> sebelum diarahkan ke <replaceable>server</replaceable> pada jaringan \"publik\". Dalam kedua kasus, masukan dan keluaran di tunnel dibalik; pintu masuk adalah port 8000 pada mesin <replaceable>perantara</replaceable>, keluaran adalah pada host lokal, dan data diarahkan ke <replaceable>server</replaceable>. Dalam prakteknya, server ini biasanya mesin lokal atau perantara. Dengan cara itu SSH mengamankan koneksi dari satu ujung ke yang lain."

msgid "Forwarding a local port with SSH"
msgstr "Penerusan suatu port lokal dengan SSH"

msgid "Forwarding a remote port with SSH"
msgstr "Penerusan suatu port jauh dengan SSH"

msgid "Using Remote Graphical Desktops"
msgstr "Memakai Desktop Grafis Jarak Jauh"

msgid "VNC (Virtual Network Computing) allows remote access to graphical desktops."
msgstr "VNC (Virtual Network Computing) memungkinkan akses remote ke desktop grafis."

msgid "<primary>VNC</primary>"
msgstr "<primary>VNC</primary>"

msgid "<primary>Virtual Network Computing</primary>"
msgstr "<primary>Virtual Network Computing</primary>"

msgid "<primary>graphical desktop</primary><secondary>remote</secondary>"
msgstr "<primary>desktop grafis</primary><secondary>remote</secondary>"

msgid "<primary>remote graphical desktop</primary>"
msgstr "<primary>remote desktop grafis</primary>"

msgid "<primary>desktop, remote graphical desktop</primary>"
msgstr "<primary>desktop, remote desktop grafis</primary>"

msgid "This tool is mostly used for technical assistance; the administrator can see the errors that the user is facing, and show them the correct course of action without having to stand by them."
msgstr "Alat ini banyak digunakan untuk bantuan teknis; administrator dapat melihat kesalahan yang dihadapi pengguna, dan menunjukkan kepada mereka tindakan yang benar tanpa harus berdiri di samping mereka."

msgid "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"

msgid "<primary><emphasis role=\"pkg\">krfb</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">krfb</emphasis></primary>"

msgid "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary>"

msgid "First, the user must authorize sharing their session. The GNOME graphical desktop environment from <emphasis role=\"distribution\">Jessie</emphasis> onward includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). KDE Plasma still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon."
msgstr "Pertama, pengguna harus mengotorisasi berbagi sesi mereka. Grafis lingkungan desktop GNOME di <emphasis role=\"distribution\">Jessie</emphasis> dan setelahnya menyertakan pilihan itu di panel konfigurasi (berbeda dengan versi Debian sebelumnya, di mana pengguna harus menginstal dan menjalankan <command>vino</command>). KDE masih perlu menggunakan <command>krfb</command> untuk memungkinkan berbagi sesi yang ada melalui VNC. Untuk lingkungan desktop grafis lainnya, perintah <command>x11vnc</command> (dari paket Debian dengan nama yang sama) melayani tujuan yang sama; Anda dapat membuatnya tersedia untuk pengguna dengan ikon eksplisit."

msgid "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary>"

msgid "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"

msgid "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"

msgid "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"

msgid "When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while the KDE project provides <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xvnc4viewer</command> in the Debian package of the same name. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed."
msgstr "Ketika sesi grafis dibuat tersedia oleh VNC, administrator harus menyambung ke sana dengan klien VNC. GNOME memiliki <command>vinagre</command> dan <command>remmina</command> untuk itu, sementara KDE menyertakan <command>krdc</command> (pada menu di <menuchoice><guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Klien Remote Desktop</guimenuitem></menuchoice>). Ada klien VNC lainnya yang menggunakan baris perintah, seperti <command>xvnc4viewer</command> dalam paket Debian dengan nama yang sama. Setelah terhubung, administrator dapat melihat apa yang terjadi, bekerja pada mesin dari jarak jauh, dan menunjukkan ke pengguna bagaimana untuk melanjutkan."

msgid "<emphasis>SECURITY</emphasis> VNC over SSH"
msgstr "<emphasis>KEAMANAN</emphasis> VNC di atas SSH"

msgid "<primary>SSH tunnel</primary><secondary>VNC</secondary>"
msgstr "<primary>tunnel SSH</primary><secondary>VNC</secondary>"

msgid "If you want to connect by VNC, and you don't want your data sent in clear text on the network, it is possible to encapsulate the data in an SSH tunnel (see <xref linkend=\"sect.ssh-port-forwarding\" />). You simply have to know that VNC uses port 5900 by default for the first screen (called “localhost:0”), 5901 for the second (called “localhost:1”), etc."
msgstr "Jika Anda ingin terhubung oleh VNC, dan Anda tidak ingin data Anda dikirim dalam bentuk teks polos pada jaringan, mungkin untuk membungkus data dalam tunnel SSH (lihat <xref linkend=\"sect.ssh-port-forwarding\" />). Anda hanya perlu tahu bahwa VNC menggunakan port 5900 secara default untuk layar pertama (disebut \"localhost:0\"), 5901 untuk kedua (disebut \"localhost:1\"), dll."

msgid "The <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> command creates a tunnel between local port 5901 in the localhost interface and port 5900 of the <replaceable>machine</replaceable> host. The first “localhost” restricts SSH to listening to only that interface on the local machine. The second “localhost” indicates the interface on the remote machine which will receive the network traffic entering in “localhost:5901”. Thus <command>vncviewer localhost:1</command> will connect the VNC client to the remote screen, even though you indicate the name of the local machine."
msgstr "Perintah <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>mesin</replaceable></command> menciptakan sebuah tunnel antara port lokal 5901 di antarmuka localhost dan port 5900 host <replaceable>mesin</replaceable>. \"localhost\" pertama membatasi SSH untuk mendengarkan hanya pada antarmuka tersebut di komputer lokal. \"localhost\" kedua menunjukkan antarmuka pada mesin remote yang akan menerima lalu lintas jaringan masuk \"localhost:5901\". Dengan demikian <command>vncviewer localhost:1</command> akan menghubungkan klien VNC ke layar remote, meskipun Anda menunjukkan nama dari mesin lokal."

msgid "When the VNC session is closed, remember to close the tunnel by also quitting the corresponding SSH session."
msgstr "Ketika sesi VNC ditutup, ingatlah untuk menutup tunnel juga dengan menghentikan sesi SSH yang sesuai."

msgid "<emphasis>BACK TO BASICS</emphasis> Display manager"
msgstr "<emphasis>KEMBALI KE DASAR</emphasis> Manajer tampilan"

msgid "<primary><command>gdm3</command></primary>"
msgstr "<primary><command>gdm3</command></primary>"

msgid "<primary><command>kdm</command></primary>"
msgstr "<primary><command>kdm</command></primary>"

msgid "<primary><command>xdm</command></primary>"
msgstr "<primary><command>xdm</command></primary>"

msgid "<primary><command>lightdm</command></primary>"
msgstr "<primary><command>lightdm</command></primary>"

msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgstr "<primary>manajer</primary><secondary>manajer tampilan</secondary>"

msgid "<primary>display manager</primary>"
msgstr "<primary>manajer tampilan</primary>"

msgid "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, and <command>xdm</command> are Display Managers. They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session."
msgstr "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, dan <command>xdm</command> adalah Manajer Tampilan. Mereka mengambil kontrol antarmuka grafis tak lama setelah boot untuk menyediakan layar login ke pengguna. Setelah pengguna login, mereka menjalankan program-program yang dibutuhkan untuk memulai sesi grafis."

msgid "VNC also works for mobile users, or company executives, who occasionally need to login from their home to access a remote desktop similar to the one they use at work. The configuration of such a service is more complicated: you first install the <emphasis role=\"pkg\">vnc4server</emphasis> package, change the configuration of the display manager to accept <literal>XDMCP Query</literal> requests (for <command>gdm3</command>, this can be done by adding <literal>Enable=true</literal> in the “xdmcp” section of <filename>/etc/gdm3/daemon.conf</filename>), and finally, start the VNC server with <command>inetd</command> so that a session is automatically started when a user tries to login. For example, you may add this line to <filename>/etc/inetd.conf</filename>:"
msgstr "VNC juga bekerja untuk pengguna ponsel, atau eksekutif perusahaan, yang kadang-kadang perlu untuk login dari rumah mereka untuk mengakses desktop remote seperti yang mereka gunakan di tempat kerja. Konfigurasi layanan seperti itu lebih rumit: Anda pertama memasang paket <emphasis role=\"pkg\">vnc4server</emphasis>, mengubah konfigurasi dari layar manajer untuk menerima permintaan <literal>XDMCP Query</literal> (untuk <command>gdm3 </command>, ini dapat dilakukan dengan menambahkan <literal>Enable=true</literal> di bagian \"xdmcp\" <filename>/etc/gdm3/daemon.conf</filename>), dan akhirnya, memulai server VNC dengan <command>inetd</command> sehingga sesi secara otomatis dimulai ketika pengguna mencoba untuk login. Misalnya, Anda dapat menambahkan baris ini untuk <filename>/etc/inetd.conf</filename>:"

msgid "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"
msgstr "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"

msgid "Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <command>gdm3</command> login screen (or equivalent <command>kdm</command>, <command>xdm</command>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <command>vncviewer <replaceable>server</replaceable>:50</command>, because the port used is 5950."
msgstr "Mengarahkan koneksi masuk ke manajer tampilan memecahkan masalah otentikasi, karena hanya pengguna dengan akun lokal yang akan melewati layar login <command>gdm3</command> (atau yang setara <command>kdm</command>, <command>xdm</command>, dll). Karena operasi ini memungkinkan beberapa login simultan tanpa masalah (asal server cukup kuat), bahkan dapat digunakan untuk menyediakan desktop yang lengkap bagi pengguna ponsel (atau untuk sistem desktop yang kurang kuat, dikonfigurasi sebagai thin client). Pengguna cukup login ke layar server dengan <command>vncviewer <replaceable>server</replaceable>:50</command>, karena port yang digunakan adalah 5950."

msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

msgid "Managing Rights"
msgstr "Mengelola Hak"

msgid "Linux is definitely a multi-user system, so it is necessary to provide a permission system to control the set of authorized operations on files and directories, which includes all the system resources and devices (on a Unix system, any device is represented by a file or directory). This principle is common to all Unix systems, but a reminder is always useful, especially as there are some interesting and relatively unknown advanced uses."
msgstr "Linux tentu saja adalah sistem multi-pengguna, sehingga perlu untuk menyediakan sistem izin untuk mengontrol set operasi terotorisasi pada berkas dan direktori, yang mencakup semua sumber daya sistem dan perangkat (pada sebuah sistem Unix, setiap perangkat diwakili oleh sebuah berkas atau direktori). Prinsip ini umum untuk semua sistem Unix, tetapi pengingat selalu berguna, terutama karena ada beberapa penggunaan tingkat lanjut yang menarik dan relatif tidak dikenal."

msgid "<primary>rights</primary>"
msgstr "<primary>hak</primary>"

msgid "<primary>permissions</primary>"
msgstr "<primary>izin</primary>"

msgid "<primary>user</primary><secondary>owner</secondary>"
msgstr "<primary>pengguna</primary><secondary>pemilik</secondary>"

msgid "<primary>group</primary><secondary>owner</secondary>"
msgstr "<primary>kelompok</primary><secondary>pemilik</secondary>"

msgid "<primary>owner</primary><secondary>user</secondary>"
msgstr "<primary>pemilik</primary><secondary>pengguna</secondary>"

msgid "<primary>owner</primary><secondary>group</secondary>"
msgstr "<primary>pemilik</primary><secondary>kelompok</secondary>"

msgid "Each file or directory has specific permissions for three categories of users:"
msgstr "Setiap berkas atau direktori memiliki izin khusus untuk tiga kategori pengguna:"

msgid "its owner (symbolized by <literal>u</literal> as in “user”);"
msgstr "pemiliknya (dilambangkan oleh <literal>u</literal> seperti \"user/pengguna\");"

msgid "its owner group (symbolized by <literal>g</literal> as in “group”), representing all the members of the group;"
msgstr "grup pemilik (dilambangkan oleh <literal>g</literal> dalam \"grup\"), yang mewakili semua anggota kelompok;"

msgid "the others (symbolized by <literal>o</literal> as in “other”)."
msgstr "yang lain (dilambangkan oleh <literal>o</literal> seperti \"other/yang lain\")."

msgid "Three types of rights can be combined:"
msgstr "Tiga jenis hak dapat digabungkan:"

msgid "reading (symbolized by <literal>r</literal> as in “read”);"
msgstr "membaca (symbolized oleh <literal>r</literal> seperti \"read/baca\");"

msgid "writing (or modifying, symbolized by <literal>w</literal> as in “write”);"
msgstr "menulis (atau memodifikasi, dilambangkan oleh <literal>w</literal> seperti \"write/menulis\");"

msgid "executing (symbolized by <literal>x</literal> as in “eXecute”)."
msgstr "mengeksekusi (dilambangkan oleh <literal>x</literal> seperti \"eXecute/menjalankan\")."

msgid "<primary>read, right</primary>"
msgstr "<primary>baca, hak</primary>"

msgid "<primary>write, right</primary>"
msgstr "<primary>tulis, hak</primary>"

msgid "<primary>modification, right</primary>"
msgstr "<primary>modifikasi, hak</primary>"

msgid "<primary>execution, right</primary>"
msgstr "<primary>eksekusi, hak</primary>"

msgid "In the case of a file, these rights are easily understood: read access allows reading the content (including copying), write access allows changing it, and execute access allows you to run it (which will only work if it is a program)."
msgstr "Dalam kasus berkas, hak-hak ini yang mudah dipahami: akses baca memungkinkan membaca konten (termasuk menyalin), akses menulis memungkinkan mengubah, dan akses mengeksekusi memungkinkan Anda untuk menjalankannya (yang hanya akan bekerja jika itu adalah sebuah program)."

msgid "<emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables"
msgstr "<emphasis>KEAMANAN</emphasis> executable dengan <literal>setuid</literal> dan <literal>setgid</literal>"

msgid "Two particular rights are relevant to executable files: <literal>setuid</literal> and <literal>setgid</literal> (symbolized with the letter “s”). Note that we frequently speak of “bit”, since each of these boolean values can be represented by a 0 or a 1. These two rights allow any user to execute the program with the rights of the owner or the group, respectively. This mechanism grants access to features requiring higher level permissions than those you would usually have."
msgstr "Dua hak khusus relevan ke berkas yang dapat dieksekusi: <literal>setuid</literal> dan <literal>setgid</literal> (dilambangkan dengan huruf \"s\"). Perhatikan bahwa kita sering berbicara tentang \"bit\", karena setiap nilai-nilai boolean ini dapat diwakili oleh 0 atau 1. Dua hak ini memungkinkan pengguna untuk mengeksekusi program dengan hak-hak pemilik atau kelompok. Mekanisme ini memberikan akses ke fitur yang memerlukan izin tingkat yang lebih tinggi daripada yang Anda biasa miliki."

msgid "<primary><literal>setuid</literal>, right</primary>"
msgstr "<primary><literal>setuid</literal>, hak</primary>"

msgid "<primary><literal>setgid</literal>, right</primary>"
msgstr "<primary><literal>setgid</literal>, hak</primary>"

msgid "Since a <literal>setuid</literal> root program is systematically run under the super-user identity, it is very important to ensure it is secure and reliable. Indeed, a user who would manage to subvert it to call a command of their choice could then impersonate the root user and have all rights on the system."
msgstr "Karena program dengan <literal>setuid</literal> root secara sistematis berjalan di bawah identitas pengguna super, sangat penting untuk memastikan itu aman dan handal. Memang, pengguna yang akan berhasil membelokkan itu untuk memanggil perintah pilihan mereka kemudian bisa menyaru sebagai pengguna root dan memiliki semua hak pada sistem."

msgid "A directory is handled differently. Read access gives the right to consult the list of its entries (files and directories), write access allows creating or deleting files, and execute access allows crossing through it (especially to go there with the <command>cd</command> command). Being able to cross through a directory without being able to read it gives permission to access the entries therein that are known by name, but not to find them if you do not know their existence or their exact name."
msgstr "Direktori ditangani secara berbeda. Akses baca memberikan hak untuk berkonsultasi ke daftar entri (berkas dan direktori), akses tulis mengizinkan membuat atau menghapus berkas, dan akses mengeksekusi memungkinkan melintasinya (terutama untuk pergi ke sana dengan perintah <command>cd</command>). Mampu untuk melintasi sebuah direktori tanpa bisa membacanya memberikan izin untuk mengakses entri di dalamnya yang dikenal dengan nama, tetapi tidak untuk menemukan mereka jika Anda tidak tahu keberadaan mereka atau nama yang tepat."

msgid "<emphasis>SECURITY</emphasis> <literal>setgid</literal> directory and <emphasis>sticky bit</emphasis>"
msgstr "<emphasis>KEAMANAN</emphasis> direktori <literal>setgid</literal> dan <emphasis>bit sticky</emphasis>"

msgid "<primary><literal>setgid</literal> directory</primary>"
msgstr "<primary>direktori <literal>setgid</literal></primary>"

msgid "The <literal>setgid</literal> bit also applies to directories. Any newly-created item in such directories is automatically assigned the owner group of the parent directory, instead of inheriting the creator's main group as usual. This setup avoids the user having to change its main group (with the <command>newgrp</command> command) when working in a file tree shared between several users of the same dedicated group."
msgstr "Bit <literal>setgid</literal> juga berlaku untuk direktori. Objek yang baru dibuat dalam direktori tersebut secara otomatis dimasukkan ke grup pemilik direktori induk, bukan mewarisi grup utama pencipta seperti biasa. Konfigurasi ini menghindari pengguna harus mengubah grup utama (dengan perintah <command>newgrp</command>) ketika bekerja di pohon berkas yang dipakai bersama antara beberapa pengguna dari grup khusus yang sama."

msgid "<primary>sticky bit</primary>"
msgstr "<primary>bit sticky</primary>"

msgid "The “sticky” bit (symbolized by the letter “t”) is a permission that is only useful in directories. It is especially used for temporary directories where everybody has write access (such as <filename>/tmp/</filename>): it restricts deletion of files so that only their owner (or the owner of the parent directory) can do it. Lacking this, everyone could delete other users' files in <filename>/tmp/</filename>."
msgstr "Bit \"sticky\" (dilambangkan dengan huruf \"t\") adalah izin yang hanya berguna dalam direktori. Hal ini terutama digunakan untuk direktori sementara tempat setiap orang memiliki akses tulis (seperti <filename>/tmp/</filename>): membatasi penghapusan berkas sehingga hanya pemilik (atau pemilik direktori induk) yang dapat melakukannya. Tanpa ini, semua orang bisa menghapus berkas milik pengguna lain dalam <filename>/tmp/</filename>."

msgid "Three commands control the permissions associated with a file:"
msgstr "Tiga perintah mengontrol izin yang terkait dengan berkas:"

msgid "<command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command> changes the owner of the file;"
msgstr "<command>chown <replaceable>pengguna</replaceable> <replaceable>berkas</replaceable></command> mengubah pemilik berkas;"

msgid "<command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command> alters the owner group;"
msgstr "<command>chgrp <replaceable>grup</replaceable> <replaceable>berkas</replaceable></command> mengubah kelompok pemilik;"

msgid "<command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command> changes the permissions for the file."
msgstr "<command>chmod <replaceable>hak</replaceable> <replaceable>berkas</replaceable></command> mengubah izin untuk berkas."

msgid "There are two ways of presenting rights. Among them, the symbolic representation is probably the easiest to understand and remember. It involves the letter symbols mentioned above. You can define rights for each category of users (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), by setting them explicitly (with <literal>=</literal>), by adding (<literal>+</literal>), or subtracting (<literal>-</literal>). Thus the <literal>u=rwx,g+rw,o-r</literal> formula gives the owner read, write, and execute rights, adds read and write rights for the owner group, and removes read rights for other users. Rights not altered by the addition or subtraction in such a command remain unmodified. The letter <literal>a</literal>, for “all”, covers all three categories of users, so that <literal>a=rx</literal> grants all three categories the same rights (read and execute, but not write)."
msgstr "Ada dua cara untuk menyajikan hak. Di antara mereka, representasi simbolik adalah mungkin yang paling mudah untuk dipahami dan diingat. Ini melibatkan huruf simbol yang disebutkan di atas. Anda bisa mendefinisikan hak untuk setiap kategori pengguna (<literal>u</literal> <literal>g</literal>/<literal>o</literal>), dengan menetapkan mereka secara eksplisit (dengan <literal>=</literal>), dengan menambahkan (<literal>+</literal>), atau mengurangi (<literal>-</literal>). Dengan demikian rumus <literal>u=rwx,g+rw,o-r</literal> memberikan pemilik hak baca, tulis, dan eksekusi, menambahkan hak baca dan tulis untuk pemilik grup, dan menghilangkan hak-hak baca untuk pengguna lain. Hak-hak yang tidak diubah oleh penambahan atau pengurangan dalam perintah tersebut tetap tak berubah. Huruf <literal>a</literal>, untuk \"all/semua\", mencakup semua kategori pengguna, sehingga <literal>a=rx</literal> menghibahkan ke ketiga kategori hak yang sama (membaca dan mengeksekusi, tapi tidak menulis)."

msgid "<primary><command>chmod</command></primary>"
msgstr "<primary><command>chmod</command></primary>"

msgid "<primary><command>chown</command></primary>"
msgstr "<primary><command>chown</command></primary>"

msgid "<primary><command>chgrp</command></primary>"
msgstr "<primary><command>chgrp</command></primary>"

msgid "<primary>octal representation of rights</primary>"
msgstr "<primary>representasi oktal hak</primary>"

msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgstr "<primary>hak</primary><secondary>representasi oktal</secondary>"

msgid "The (octal) numeric representation associates each right with a value: 4 for read, 2 for write, and 1 for execute. We associate each combination of rights with the sum of the figures. Each value is then assigned to different categories of users by putting them end to end in the usual order (owner, group, others)."
msgstr "Representasi numerik (oktal) mengasosiasikan hak masing-masing dengan suatu nilai: 4 untuk baca, 2 untuk tulis, dan 1 untuk eksekusi. Kita menghubungkan setiap kombinasi hak dengan menjumlah angka-angka. Setiap nilai kemudian ditugaskan untuk berbagai kategori pengguna dengan meletakkan mereka dalam urutan biasa (pemilik, kelompok, lain-lain)."

msgid "For instance, the <command>chmod 754 <replaceable>file</replaceable></command> command will set the following rights: read, write and execute for the owner (since 7 = 4 + 2 + 1); read and execute for the group (since 5 = 4 + 1); read-only for others. The <literal>0</literal> means no rights; thus <command>chmod 600 <replaceable>file</replaceable></command> allows for read/write rights for the owner, and no rights for anyone else. The most frequent right combinations are <literal>755</literal> for executable files and directories, and <literal>644</literal> for data files."
msgstr "Misalnya, perintah <command>chmod 754<replaceable>berkas</replaceable></command> akan menetapkan hak-hak berikut: baca, tulis dan, jalankan untuk pemilik (karena 7 = 4 + 2 + 1); baca dan jalankan untuk group (karena 5 = 4 + 1); hanya-baca untuk orang lain. <literal>0</literal> berarti tidak ada hak; dengan demikian <command>chmod 600<replaceable>berkas</replaceable></command> memungkinkan hak baca/tulis untuk pemilik, dan tidak ada hak untuk orang lain. Kombinasi tepat yang paling sering adalah <literal>755</literal> untuk berkas yang dapat dieksekusi dan direktori, dan <literal>644</literal> untuk berkas data."

msgid "To represent special rights, you can prefix a fourth digit to this number according to the same principle, where the <literal>setuid</literal>, <literal>setgid</literal> and <literal>sticky</literal> bits are 4, 2 and 1, respectively. <command>chmod 4754</command> will associate the <literal>setuid</literal> bit with the previously described rights."
msgstr "Untuk mewakili hak khusus, Anda dapat memberi awalan digit keempat ke nomor ini sesuai dengan prinsip yang sama, dengan bit <literal>setuid</literal>, <literal>setgid</literal>, dan <literal>sticky</literal> masing-masing adalah 4, 2, dan 1. <command>chmod 4754</command> akan mengasosiasikan bit <literal>setuid</literal> dengan hak-hak yang dijelaskan sebelumnya."

msgid "Note that the use of octal notation only allows to set all the rights at once on a file; you cannot use it to simply add a new right, such as read access for the group owner, since you must take into account the existing rights and compute the new corresponding numerical value."
msgstr "Perhatikan bahwa penggunaan notasi oktal hanya memungkinkan untuk mengatur semua hak sekaligus pada berkas; Anda tidak dapat menggunakannya untuk menambahkan hak baru, seperti akses baca untuk pemilik grup, karena Anda harus memperhitungkan hak-hak yang ada dan menghitung nilai numerik baru yang sesuai."

msgid "<emphasis>TIP</emphasis> Recursive operation"
msgstr "<emphasis>TIP</emphasis> Operasi rekursif"

msgid "Sometimes we have to change rights for an entire file tree. All the commands above have a <literal>-R</literal> option to operate recursively in sub-directories."
msgstr "Kadang-kadang kita harus mengubah hak untuk seluruh pohon berkas. Semua perintah di atas memiliki opsi <literal>-R</literal> untuk beroperasi secara rekursif di sub-direktori."

msgid "The distinction between directories and files sometimes causes problems with recursive operations. That is why the “X” letter has been introduced in the symbolic representation of rights. It represents a right to execute which applies only to directories (and not to files lacking this right). Thus, <command>chmod -R a+X <replaceable>directory</replaceable></command> will only add execute rights for all categories of users (<literal>a</literal>) for all of the sub-directories and files for which at least one category of user (even if their sole owner) already has execute rights."
msgstr "Perbedaan antara direktori dan berkas kadang-kadang menyebabkan masalah dengan operasi rekursif. Itu sebabnya huruf \"X\" telah diperkenalkan di representasi simbolik dari hak-hak. Ini mewakili hak untuk menjalankan yang berlaku hanya untuk direktori (dan tidak untuk berkas yang tidak memiliki hak ini). Dengan demikian, <command>chmod -R a+X<replaceable>direktori</replaceable></command> hanya akan menambah hak mengeksekusi bagi semua kategori pengguna (<literal>a</literal>) untuk semua sub direktori dan berkas yang setidaknya satu kategori pengguna (bahkan jika pemilik satu-satunya) sudah memiliki hak mengeksekusi."

msgid "<emphasis>TIP</emphasis> Changing the user and group"
msgstr "<emphasis>TIP</emphasis> Mengubah pengguna dan grup"

msgid "Frequently you want to change the group of a file at the same time that you change the owner. The <command>chown</command> command has a special syntax for that: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>"
msgstr "Sering Anda ingin mengubah kelompok berkas pada waktu yang sama dengan Anda mengubah pemilik. Perintah <command>chown</command> memiliki sintaks yang khusus untuk itu: <command>chown <replaceable>pengguna</replaceable>:<replaceable>kelompok</replaceable> <replaceable>berkas</replaceable></command>"

msgid "<emphasis>GOING FURTHER</emphasis> <command>umask</command>"
msgstr "<emphasis>LEBIH LANJUT</emphasis> <command>umask</command>"

msgid "When an application creates a file, it assigns indicative permissions, knowing that the system automatically removes certain rights, given by the command <command>umask</command>. Enter <command>umask</command> in a shell; you will see a mask such as <computeroutput>0022</computeroutput>. This is simply an octal representation of the rights to be systematically removed (in this case, the write right for the group and other users)."
msgstr "Ketika sebuah aplikasi menciptakan sebuah berkas, itu menetapkan izin indikatif, mengetahui bahwa sistem secara otomatis menghapus hak tertentu, yang diberikan oleh perintah <command>umask</command>. Masukkan <command>umask</command> dalam shell; Anda akan melihat sebuah mask seperti <computeroutput>0022</computeroutput>. Ini adalah sekadar representasi oktal hak untuk yang secara sistematis dihapus (dalam kasus ini, hak tulis untuk grup dan pengguna lain)."

msgid "<primary>umask</primary>"
msgstr "<primary>umask</primary>"

msgid "<primary>rights</primary><secondary>mask</secondary>"
msgstr "<primary>hak</primary><secondary>mask</secondary>"

msgid "<primary>mask</primary><secondary>rights mask</secondary>"
msgstr "<primary>mask</primary><secondary>mask hak</secondary>"

msgid "If you give it a new octal value, the <command>umask</command> command modifies the mask. Used in a shell initialization file (for example, <filename>~/.bash_profile</filename>), it will effectively change the default mask for your work sessions."
msgstr "Jika Anda memberikan nilai oktal baru, perintah <command>umask</command> memodifikasi mask. Digunakan dalam berkas inisialisasi shell (misalnya, <filename>~/.bash_profile</filename>), ini akan secara efektif mengubah mask baku untuk sesi kerja Anda."

msgid "Administration Interfaces"
msgstr "Antarmuka Administrasi"

msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgstr "<primary>antarmuka</primary><secondary>antarmuka administrasi</secondary>"

msgid "<primary>administration, interfaces</primary>"
msgstr "<primary>administrasi, antarmuka</primary>"

msgid "Using a graphical interface for administration is interesting in various circumstances. An administrator does not necessarily know all the configuration details for all their services, and doesn't always have the time to go seeking out the documentation on the matter. A graphical interface for administration can thus accelerate the deployment of a new service. It can also simplify the setup of services which are hard to configure."
msgstr "Menggunakan antarmuka grafis untuk administrasi menarik di berbagai keadaan. Administrator tidak perlu mengetahui semua rincian konfigurasi untuk semua layanan mereka, dan tidak selalu punya waktu untuk pergi mencari dokumentasi tentang masalah. Antarmuka grafis untuk administrasi karenanya dapat mempercepat penyebaran layanan baru. Itu juga dapat menyederhanakan penyiapan layanan yang sulit untuk dikonfigurasi."

msgid "Such an interface is only an aid, and not an end in itself. In all cases, the administrator must master its behavior in order to understand and work around any potential problem."
msgstr "Sebuah antarmuka adalah hanya bantuan, dan bukan tujuan itu sendiri. Dalam semua kasus, administrator harus menguasai perilakunya untuk memahami dan mengatasi masalah potensial."

msgid "Since no interface is perfect, you may be tempted to try several solutions. This is to be avoided as much as possible, since different tools are sometimes incompatible in their work methods. Even if they all aim to be very flexible and try to adopt the configuration file as a single reference, they are not always able to integrate external changes."
msgstr "Karena tidak ada antarmuka yang sempurna, Anda mungkin tergoda untuk mencoba beberapa solusi. Ini harus dihindari sebisa mungkin, karena alat yang berbeda kadang-kadang tidak kompatibel dalam metode kerja mereka. Bahkan jika mereka semua bertujuan untuk menjadi sangat fleksibel dan mencoba untuk mengadopsi berkas konfigurasi sebagai referensi tunggal, mereka tidak selalu mampu mengintegrasikan perubahan-perubahan eksternal."

msgid "Administrating on a Web Interface: <command>webmin</command>"
msgstr "Pengadministrasian pada Antarmuka Web: <command>webmin</command>"

msgid "<primary><emphasis>webmin</emphasis></primary>"
msgstr "<primary><emphasis>webmin</emphasis></primary>"

msgid "This is, without a doubt, one of the most successful administration interfaces. It is a modular system managed through a web browser, covering a wide array of areas and tools. Furthermore, it is internationalized and available in many languages."
msgstr "Ini, tak diragukan lagi, adalah salah satu antarmuka administrasi yang paling sukses. Ini adalah sebuah sistem modular yang dikelola melalui peramban web, meliputi area dan peralatan yang luas. Lebih jauh, itu diinternasionalisasi dan tersedia dalam banyak bahasa."

msgid "Webmin dashboard"
msgstr "Dasbor Webmin"

msgid "Sadly, <command>webmin</command> is no longer part of Debian. Its Debian maintainer — Jaldhar H. Vyas — removed the packages he created because he no longer had the time required to maintain them at an acceptable quality level. Nobody has officially taken over, so <emphasis role=\"distribution\">Buster</emphasis> does not have the <command>webmin</command> package."
msgstr "Sayangnya, <command>webmin</command> tidak lagi merupakan bagian dari Debian. Para pengelola Debian — Jaldhar H. Vyas — menghapus paket yang diciptakannya karena ia tidak lagi memiliki waktu yang dibutuhkan untuk mempertahankan mereka pada tingkat kualitas yang dapat diterima. Tak seorang pun telah secara resmi mengambil alih, sehingga <emphasis role=\"distribution\">Buster</emphasis> tidak memiliki paket <command>webmin</command>."

msgid "There is, however, an unofficial package distributed on the <literal>webmin.com</literal> website. Contrary to the original Debian packages, this package is monolithic; all of its configuration modules are installed and activated by default, even if the corresponding service is not installed on the machine."
msgstr "Namun, ada sebuah paket tidak resmi yang didistribusikan pada <literal>webmin.com</literal> website. Bertentangan dengan paket-paket Debian asli, paket ini monolitik; semua modul konfigurasinya dipasang dan diaktifkan secara default, bahkan jika layanan yang sesuai tidak dipasang pada mesin."

msgid "<emphasis>SECURITY</emphasis> Changing the root password"
msgstr "<emphasis>KEAMANAN</emphasis> Mengubah password root"

msgid "On the first login, identification is conducted with the root username and its usual password. It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the root password for the server will not be involved, even if this confers important administrative rights to the machine."
msgstr "Saat login pertama, identifikasi dilakukan dengan nama pengguna root dan kata sandi yang biasa. Dianjurkan untuk mengubah sandi yang digunakan untuk <command>webmin</command> secepat mungkin, sehingga jika itu disusupi, kata sandi root untuk server tidak akan terlibat, bahkan jika ini menganugerahkan hak administratif yang penting untuk mesin."

msgid "Beware! Since <command>webmin</command> has so many features, a malicious user accessing it could compromise the security of the entire system. In general, interfaces of this kind are not recommended for important systems with strong security constraints (firewall, sensitive servers, etc.)."
msgstr "Berhati-hatilah! Karena <command>webmin</command> memiliki begitu banyak fitur, pengguna jahat yang mengakses itu dapat membahayakan keamanan seluruh sistem. Secara umum, antarmuka semacam ini tidak dianjurkan untuk sistem penting dengan kendala-kendala keamanan yang kuat (firewall, server sensitif, dll.)."

msgid "Webmin is used through a web interface, but it does not require Apache to be installed. Essentially, this software has its own integrated mini web server. This server listens by default on port 10000 and accepts secure HTTP connections."
msgstr "Webmin digunakan melalui antarmuka web, tetapi tidak memerlukan Apache untuk diinstal. Pada dasarnya, perangkat lunak ini memiliki server web mini terpadu sendiri. Server ini mendengarkan secara default pada port 10000 dan menerima koneksi HTTP aman."

msgid "Included modules cover a wide variety of services, among which:"
msgstr "Modul-modul yang disertakan mencakup berbagai macam layanan, diantaranya:"

msgid "all base services: creation of users and groups, management of <filename>crontab</filename> files, init scripts, viewing of logs, etc."
msgstr "semua layanan dasar: penciptaan pengguna dan kelompok, manajemen berkas <filename>crontab</filename>, init script, melihat log, dll."

msgid "bind: DNS server configuration (name service);"
msgstr "bind: konfigurasi server DNS (layanan nama);"

msgid "postfix: SMTP server configuration (e-mail);"
msgstr "postfix: konfigurasi server SMTP (e-mail);"

msgid "inetd: configuration of the <command>inetd</command> super-server;"
msgstr "inetd: konfigurasi server super <command>inetd</command>;"

msgid "quota: user quota management;"
msgstr "kuota: manajemen kuota pengguna;"

msgid "dhcpd: DHCP server configuration;"
msgstr "dhcpd: konfigurasi server DHCP;"

msgid "proftpd: FTP server configuration;"
msgstr "proftpd: konfigurasi server FTP;"

msgid "samba: Samba file server configuration;"
msgstr "samba: konfigurasi server berkas Samba;"

msgid "software: installation or removal of software from Debian packages and system updates."
msgstr "perangkat lunak: instalasi atau penghapusan perangkat lunak dari paket-paket Debian dan pembaruan sistem."

msgid "The administration interface is available in a web browser at <literal>https://localhost:10000</literal>. Beware! Not all the modules are directly usable. Sometimes they must be configured by specifying the locations of the corresponding configuration files and some executable files (program). Frequently the system will politely prompt you when it fails to activate a requested module."
msgstr "Antarmuka administrasi tersedia di peramban web di <literal>https://localhost:10000</literal>. Berhati-hatilah! Tidak semua modul secara langsung dapat digunakan. Kadang-kadang mereka harus dikonfigurasi dengan menentukan lokasi berkas-berkas konfigurasi yang sesuai dan beberapa berkas yang dapat dieksekusi (program). Sering sistem secara sopan akan meminta Anda ketika gagal untuk mengaktifkan sebuah modul yang diminta."

msgid "<emphasis>ALTERNATIVE</emphasis> GNOME control center"
msgstr "<emphasis>ALTERNATIF</emphasis> Pusat kendali GNOME"

msgid "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"

msgid "The GNOME project also provides multiple administration interfaces that are usually accessible via the “Settings” entry in the user menu on the top right. <command>gnome-control-center</command> is the main program that brings them all together but many of the system wide configuration tools are effectively provided by other packages (<emphasis role=\"pkg\">accountsservice</emphasis>, <emphasis role=\"pkg\">system-config-printer</emphasis>, etc.). Although they are easy to use, these applications cover only a limited number of base services: user management, time configuration, network configuration, printer configuration, and so on."
msgstr "Proyek GNOME juga menyediakan beberapa antarmuka administrasi yang biasanya dapat diakses melalui entri \"Pengaturan\" di menu pengguna di kanan atas. <command>gnome-control-center</command> adalah program utama yang membawa mereka bersama-sama tetapi banyak dari alat konfigurasi seluruh sistem secara efektif disediakan oleh paket lainnya (<emphasis role=\"pkg\">accountsservice</emphasis>, <emphasis role=\"pkg\">system-config-printer</emphasis>, dll). Meskipun mereka mudah digunakan, aplikasi ini mencakup hanya sejumlah terbatas layanan dasar: manajemen pengguna, konfigurasi waktu, konfigurasi jaringan, konfigurasi pencetak, dan sebagainya."

msgid "Configuring Packages: <command>debconf</command>"
msgstr "Mengkonfigurasi Paket: <command>debconf</command>"

msgid "<primary><command>debconf</command></primary>"
msgstr "<primary><command>debconf</command></primary>"

msgid "<primary><command>dpkg-reconfigure</command></primary>"
msgstr "<primary><command>dpkg-reconfigure</command></primary>"

msgid "Many packages are automatically configured after asking a few questions during installation through the Debconf tool. These packages can be reconfigured by running <command>dpkg-reconfigure <replaceable>package</replaceable></command>."
msgstr "Banyak paket secara otomatis dikonfigurasi setelah mengajukan beberapa pertanyaan selama instalasi melalui alat Debconf. Paket-paket ini dapat dikonfigurasi ulang dengan menjalankan <command>dpkg-reconfigure <replaceable>paket</replaceable></command>."

msgid "For most cases, these settings are very simple; only a few important variables in the configuration file are changed. These variables are often grouped between two “demarcation” lines so that reconfiguration of the package only impacts the enclosed area. In other cases, reconfiguration will not change anything if the script detects a manual modification of the configuration file, in order to preserve these human interventions (because the script can't ensure that its own modifications will not disrupt the existing settings)."
msgstr "Untuk kebanyakan kasus, pengaturan ini sangat sederhana; hanya beberapa variabel penting di berkas konfigurasi diganti. Variabel ini sering dikelompokkan antara dua garis \"demarkasi\" sehingga konfigurasi ulang paket hanya berdampak ke daerah tertentu. Dalam kasus lain, konfigurasi ulang tidak akan mengubah apa-apa jika skrip mendeteksi modifikasi manual berkas konfigurasi, dalam rangka untuk mempertahankan intervensi manusia ini (karena skrip tidak dapat memastikan bahwa modifikasinya tidak akan mengganggu pengaturan yang ada)."

msgid "<emphasis>DEBIAN POLICY</emphasis> Preserving changes"
msgstr "<emphasis>KEBIJAKAN DEBIAN</emphasis> Melestarikan perubahan"

msgid "The Debian Policy expressly stipulates that everything should be done to preserve manual changes made to a configuration file, so more and more scripts take precautions when editing configuration files. The general principle is simple: the script will only make changes if it knows the status of the configuration file, which is verified by comparing the checksum of the file against that of the last automatically generated file. If they are the same, the script is authorized to change the configuration file. Otherwise, it determines that the file has been changed and asks what action it should take (install the new file, save the old file, or try to integrate the new changes with the existing file). This precautionary principle has long been unique to Debian, but other distributions have gradually begun to embrace it."
msgstr "Kebijakan Debian secara tegas menyebutkan bahwa segala sesuatu harus dilakukan untuk melestarikan perubahan manual yang dibuat untuk berkaskonfigurasi, maka semakin banyak skrip yang mengambil tindakan pencegahan saat menyunting berkas konfigurasi. Prinsip umumnya sederhana: skrip hanya akan membuat perubahan jika itu tahu status berkas konfigurasi yang diverifikasi dengan membandingkan checksum berkas terhadap berkas yang terakhir dikonfigurasi secara otomatis. Jika mereka sama, skrip berwenang untuk mengubah berkaskonfigurasi. Jika tidak, itu menganggap bahwa berkas telah berubah dan bertanya apa tindakan yang diperlukan (menginstal berkas baru, menyimpan berkas lama, atau mencoba untuk mengintegrasikan perubahan baru dengan berkas yang sudah ada). Prinsip pencegahan ini telah lama unik untuk Debian, tetapi distro lain secara bertahap mulai menerimanya."

msgid "The <command>ucf</command> program (from the Debian package of the same name) can be used to implement such a behavior."
msgstr "Program <command>ucf</command> (dari paket Debian dengan nama yang sama) dapat digunakan untuk menerapkan perilaku seperti itu."

msgid "<primary><command>ucf</command></primary>"
msgstr "<primary><command>ucf</command></primary>"

msgid "<command>syslog</command> System Events"
msgstr "<command>syslog</command> Kejadian Sistem"

msgid "<primary><command>rsyslogd</command></primary>"
msgstr "<primary><command>rsyslogd</command></primary>"

msgid "<primary>files</primary><secondary>log files</secondary>"
msgstr "<primary>berkas</primary><secondary>berkas log</secondary>"

msgid "<primary>logs</primary><secondary>dispatching</secondary>"
msgstr "<primary>log</primary><secondary>pengiriman</secondary>"

msgid "Principle and Mechanism"
msgstr "Prinsip dan Mekanisme"

msgid "The <command>rsyslogd</command> daemon is responsible for collecting service messages coming from applications and the kernel, then dispatching them into log files (usually stored in the <filename>/var/log/</filename> directory). It obeys the <filename>/etc/rsyslog.conf</filename> configuration file."
msgstr "Daemon <command>rsyslogd</command> bertanggung jawab untuk mengumpulkan pesan layanan yang berasal dari aplikasi dan kernel, lalu mengirim mereka ke dalam berkas log (biasanya disimpan dalam direktori <filename>/var/log/</filename>). Ini mematuhi berkas konfigurasi <filename>/etc/rsyslog.conf</filename>."

msgid "Each log message is associated with an application subsystem (called “facility” in the documentation):"
msgstr "Setiap pesan log terkait dengan suatu subsistem aplikasi (disebut 'fasilitas' dalam dokumentasi):"

msgid "<literal>auth</literal> and <literal>authpriv</literal>: for authentication;"
msgstr "<literal>auth</literal> dan <literal>authpriv</literal>: untuk otentikasi;"

msgid "<literal>cron</literal>: comes from task scheduling services, <command>cron</command> and <command>atd</command>;"
msgstr "<literal>cron</literal>: berasal dari layanan penjadwalan tugas, <command>cron</command> dan <command>atd</command>;"

msgid "<literal>daemon</literal>: affects a daemon without any special classification (DNS, NTP, etc.);"
msgstr "<literal>daemon</literal>: mempengaruhi daemon tanpa klasifikasi khusus apapun (DNS, NTP, dll);"

msgid "<literal>ftp</literal>: concerns the FTP server;"
msgstr "<literal>ftp</literal>: menyangkut server FTP;"

msgid "<literal>kern</literal>: message coming from the kernel;"
msgstr "<literal>kern</literal>: pesan yang datang dari kernel;"

msgid "<literal>lpr</literal>: comes from the printing subsystem;"
msgstr "<literal>lpr</literal>: berasal dari subsistem pencetakan;"

msgid "<literal>mail</literal>: comes from the e-mail subsystem;"
msgstr "<literal>mail</literal>: berasal dari subsistem surel;"

msgid "<literal>news</literal>: Usenet subsystem message (especially from an NNTP — Network News Transfer Protocol — server that manages newsgroups);"
msgstr "<literal>news</literal>: pesan subsistem Usenet (terutama dari NNTP — Network News Transfer Protocol — server yang mengelola newsgroup);"

msgid "<literal>syslog</literal>: messages from the <command>syslogd</command> server, itself;"
msgstr "<literal>syslog</literal>: pesan-pesan dari server <command>syslogd</command> itu sendiri;"

msgid "<literal>user</literal>: user messages (generic);"
msgstr "<literal>user</literal>: pesan-pesan pengguna (generik);"

msgid "<literal>uucp</literal>: messages from the UUCP server (Unix to Unix Copy Program, an old protocol notably used to distribute e-mail messages);"
msgstr "<literal>uucp</literal>: pesan dari server UUCP (Unix to Unix Copy Program, protokol tua yang terutama digunakan untuk mendistribusikan pesan surel);"

msgid "<literal>local0</literal> to <literal>local7</literal>: reserved for local use."
msgstr "<literal>local0</literal> sampai <literal>local7</literal>: disediakan untuk penggunaan lokal."

msgid "Each message is also associated with a priority level. Here is the list in decreasing order:"
msgstr "Setiap pesan ini juga dikaitkan dengan tingkat prioritas. Berikut adalah daftar yang terurut turun:"

msgid "<literal>emerg</literal>: “Help!” There is an emergency, the system is probably unusable."
msgstr "<literal>emerg</literal>: \"Tolong!\" Ada keadaan darurat, sistem ini mungkin tidak dapat digunakan."

msgid "<literal>alert</literal>: hurry up, any delay can be dangerous, action must be taken immediately;"
msgstr "<literal>alert</literal>: buru-buru, penundaan bisa berbahaya, tindakan harus diambil segera;"

msgid "<literal>crit</literal>: conditions are critical;"
msgstr "<literal>crit</literal>: kondisi kritis;"

msgid "<literal>err</literal>: error;"
msgstr "<literal>err</literal>: kesalahan;"

msgid "<literal>warn</literal>: warning (potential error);"
msgstr "<literal>warn</literal>: peringatan (potensi kesalahan);"

msgid "<literal>notice</literal>: conditions are normal, but the message is important;"
msgstr "<literal>notice</literal>: kondisi normal, tapi pesan tersebut penting;"

msgid "<literal>info</literal>: informative message;"
msgstr "<literal>info</literal>: pesan informatif;"

msgid "<literal>debug</literal>: debugging message."
msgstr "<literal>debug</literal>: pesan pengawakutuan (debug)."

msgid "The Configuration File"
msgstr "Berkas Konfigurasi"

msgid "The syntax of the <filename>/etc/rsyslog.conf</filename> file is detailed in the <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page, but there is also HTML documentation available in the <emphasis role=\"pkg\">rsyslog-doc</emphasis> package (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). The overall principle is to write “selector” and “action” pairs. The selector defines all relevant messages, and the actions describes how to deal with them."
msgstr "Sintaks berkas <filename>/etc/rsyslog.conf</filename> dirinci dalam halaman manual <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>, tetapi ada juga dokumentasi HTML yang tersedia di paket <emphasis role=\"pkg\">rsyslog-doc</emphasis> (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Prinsip keseluruhan adalah untuk menulis pasangan \"pemilih\" dan \"tindakan\". Pemilih mendefinisikan semua pesan yang relevan, dan tindakan yang menjelaskan bagaimana menangani mereka."

msgid "Syntax of the Selector"
msgstr "Sintaks dari Pemilih"

msgid "The selector is a semicolon-separated list of <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> pairs (example: <literal>auth.notice;mail.info</literal>). An asterisk may represent all subsystems or all priorities (examples: <literal>*.alert</literal> or <literal>mail.*</literal>). Several subsystems can be grouped, by separating them with a comma (example: <literal>auth,mail.info</literal>). The priority indicated also covers messages of equal or higher priority; thus <literal>auth.alert</literal> indicates the <literal>auth</literal> subsystem messages of <literal>alert</literal> or <literal>emerg</literal> priority. Prefixed with an exclamation point (!), it indicates the opposite, in other words the strictly lower priorities; <literal>auth.!notice</literal>, thus, indicates messages issued from <literal>auth</literal>, with <literal>info</literal> or <literal>debug</literal> priority. Prefixed with an equal sign (=), it corresponds to precisely and only the priority indicated (<literal>auth.=notice</literal> only concerns messages from <literal>auth</literal> with <literal>notice</literal> priority)."
msgstr "Pemilih adalah sebuah daftar pasangan yang dipisah titik koma <literal><replaceable>subsistem</replaceable>.<replaceable>prioritas</replaceable></literal> (contoh: <literal>auth.notice;mail.info</literal>). Bintang dapat mewakili semua subsistem atau semua prioritas (contoh: <literal>*.alert</literal> atau <literal>mail.*</literal>). Beberapa subsistem dapat dikelompokkan, dengan memisahkan mereka dengan tanda koma (contoh: <literal>auth,mail.info</literal>). Prioritas yang ditunjukkan juga mencakup pesan prioritas yang sama atau lebih tinggi; dengan demikian <literal>auth.alert</literal> menunjukkan subsistem pesan <literal>auth</literal> dengan prioritas <literal>alert</literal> atau <literal>emerg</literal>. Diawali dengan tanda seru (!), ini menunjukkan sebaliknya, dengan kata lain hanya prioritas yang lebih rendah; <literal>auth.!notice</literal>, dengan demikian, menunjukkan pesan yang dikeluarkan dari <literal>auth</literal>, dengan prioritas <literal>info</literal> atau <literal>debug</literal>. Diawali dengan tanda sama dengan (=), sesuai dengan hanya prioritas ditunjukkan (<literal>oauth.=notice</literal> pesan dari <literal>auth</literal> ini hanya berkenaan dengan prioritas <literal>notice</literal>)."

msgid "Each element in the list on the selector overrides previous elements. It is thus possible to restrict a set or to exclude certain elements from it. For example, <literal>kern.info;kern.!err</literal> means messages from the kernel with priority between <literal>info</literal> and <literal>warn</literal>. The <literal>none</literal> priority indicates the empty set (no priorities), and may serve to exclude a subsystem from a set of messages. Thus, <literal>*.crit;kern.none</literal> indicates all the messages of priority equal to or higher than <literal>crit</literal> not coming from the kernel."
msgstr "Setiap elemen dalam daftar pada pemilih menimpa unsur-unsur sebelumnya. Dengan demikian dimungkinkan untuk membatasi satu set atau untuk mengecualikan unsur-unsur tertentu dari itu. Sebagai contoh, <literal>kern.info;kern.!err</literal> berarti pesan dari kernel dengan prioritas antara <literal>info</literal> dan <literal>warn</literal>. Prioritas <literal>none</literal> menunjukkan kumpulan kosong (tidak ada prioritas), dan dapat dipakai untuk mengecualikan subsistem dari serangkaian pesan. Dengan demikian, <literal>*. crit;kern.none</literal> menunjukkan semua pesan prioritas yang sama dengan atau lebih tinggi dari <literal>crit</literal> yang bukan berasal dari kernel."

msgid "Syntax of Actions"
msgstr "Sintaks Tindakan"

msgid "<emphasis>BACK TO BASICS</emphasis> The named pipe, a persistent pipe"
msgstr "<emphasis>KEMBALI KE DASAR</emphasis> Pipa bernama (named pipe), pipa persisten"

msgid "<primary>named pipe</primary>"
msgstr "<primary>named pipe</primary>"

msgid "<primary>pipe, named pipe</primary>"
msgstr "<primary>pipe, named pipe</primary>"

msgid "A named pipe is a particular type of file that operates like a traditional pipe (the pipe that you make with the “|” symbol on the command line), but via a file. This mechanism has the advantage of being able to relate two unrelated processes. Anything written to a named pipe blocks the process that writes until another process attempts to read the data written. This second process reads the data written by the first, which can then resume execution."
msgstr "Pipa bernama adalah berkas jenis khusus yang beroperasi seperti pipa tradisional (pipa yang Anda buat dengan simbol \"|\" pada baris perintah), tetapi melalui berkas. Mekanisme ini memiliki keuntungan yang mampu menghubungkan dua proses yang tidak terkait. Apa pun yang ditulis ke pipa bernama memblokir proses yang menulis sampai proses lain berusaha untuk membaca data yang dituliskan. Proses kedua ini membaca data yang ditulis oleh yang pertama, yang kemudian dapat melanjutkan eksekusi."

msgid "Such a file is created with the <command>mkfifo</command> command."
msgstr "Berkas seperti itu dibuat dengan perintah <command>mkfifo</command>."

msgid "The various possible actions are:"
msgstr "Berbagai tindakan yang mungkin adalah:"

msgid "add the message to a file (example: <filename>/var/log/messages</filename>);"
msgstr "menambahkan pesan ke berkas (contoh: <filename>/var/log/messages</filename>);"

msgid "send the message to a remote <command>syslog</command> server (example: <literal>@log.falcot.com</literal>);"
msgstr "mengirim pesan ke server <command>syslog</command> remote (contoh: <literal>@log.falcot.com</literal>);"

msgid "send the message to an existing named pipe (example: <literal>|/dev/xconsole</literal>);"
msgstr "mengirim pesan ke pipa bernama yang ada (contoh: <literal>|/dev/xconsole</literal>);"

msgid "send the message to one or more users, if they are logged in (example: <literal>root,rhertzog</literal>);"
msgstr "mengirim pesan ke satu atau lebih pengguna, jika mereka login (contoh: <literal>root, rhertzog</literal>);"

msgid "send the message to all logged in users (example: <literal>*</literal>);"
msgstr "mengirim pesan ke semua pengguna yang login (contoh: <literal>*</literal>);"

msgid "write the message in a text console (example: <literal>/dev/tty8</literal>)."
msgstr "menulis pesan dalam konsol teks (contoh: <literal>/dev/tty8</literal>)."

msgid "<emphasis>SECURITY</emphasis> Forwarding logs"
msgstr "<emphasis>KEAMANAN</emphasis> Meneruskan log"

msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgstr "<primary>log</primary><secondary>meneruskan</secondary>"

msgid "It is a good idea to record the most important logs on a separate machine (perhaps dedicated for this purpose), since this will prevent any possible intruder from removing traces of their intrusion (unless, of course, they also compromise this other server). Furthermore, in the event of a major problem (such as a kernel crash), you have the logs available on another machine, which increases your chances of determining the sequence of events that caused the crash."
msgstr "Ini adalah ide yang baik untuk merekam log-log yang paling penting pada mesin terpisah (mungkin didedikasikan untuk tujuan ini), karena ini akan mencegah penyusup apapun mungkin menghapus jejak-jejak intrusi mereka (kecuali, tentu saja, mereka juga mengkompromi server lain ini). Selanjutnya, dalam hal masalah besar (seperti kernel crash), Anda memiliki log yang tersedia pada mesin lain, yang akan meningkatkan kesempatan Anda untuk menentukan urutan peristiwa yang menyebabkan crash."

msgid "To accept log messages sent by other machines, you must reconfigure <emphasis>rsyslog</emphasis>: in practice, it is sufficient to activate the ready-for-use entries in <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> and <literal>$UDPServerRun 514</literal>)."
msgstr "Untuk menerima log pesan yang dikirim oleh mesin lainnya, Anda harus mengkonfigurasi ulang <emphasis>rsyslog</emphasis>: dalam praktek, cukup untuk mengaktifkan entri siap pakai dalam <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> dan <literal>$UDPServerRun 514</literal>)."

msgid "The <command>inetd</command> Super-Server"
msgstr "Super Server <command>inetd</command>"

msgid "Inetd (often called “Internet super-server”) is a server of servers. It executes rarely used servers on demand, so that they do not have to run continuously."
msgstr "Inetd (sering disebut \"Internet super-server\") adalah sebuah server dari server. Itu mengeksekusi server yang jarang digunakan sesuai permintaan, sehingga mereka tidak perlu berjalan terus menerus."

msgid "<primary><command>inetd</command></primary>"
msgstr "<primary><command>inetd</command></primary>"

msgid "<primary>super-server</primary>"
msgstr "<primary>super-server</primary>"

msgid "The <filename>/etc/inetd.conf</filename> file lists these servers and their usual ports. The <command>inetd</command> command listens to all of them; when it detects a connection to any such port, it executes the corresponding server program."
msgstr "Berkas <filename>/etc/inetd.conf</filename> memuat daftar server tersebut dan nomor port biasa mereka. Perintah <command>inetd</command> mendengarkan semua dari mereka; ketika mendeteksi koneksi ke salah satu port tersebut, itu mengeksekusi program server yang sesuai."

msgid "<emphasis>DEBIAN POLICY</emphasis> Register a server in <filename>inetd.conf</filename>"
msgstr "<emphasis>KEBIJAKAN DEBIAN</emphasis> Mendaftarkan suatu server di <filename>inetd.conf</filename>"

msgid "Packages frequently want to register a new server in the <filename>/etc/inetd.conf</filename> file, but Debian Policy prohibits any package from modifying a configuration file that it doesn't own. This is why the <command>update-inetd</command> script (in the package with the same name) was created: It manages the configuration file, and other packages can thus use it to register a new server to the super-server's configuration."
msgstr "Paket seringkali ingin mendaftarkan server baru dalam berkas <filename>/etc/inetd.conf</filename>, tetapi Kebijakan Debian melarang setiap paket memodifikasi berkas konfigurasi yang bukan milik sendiri. Inilah sebabnya mengapa skrip <command>update-inetd</command> (dalam paket dengan nama yang sama) dibuat: mengelola berkas konfigurasi, maka paket lain dapat menggunakannya untuk mendaftarkan server baru ke konfigurasi super-server."

msgid "Each significant line of the <filename>/etc/inetd.conf</filename> file describes a server through seven fields (separated by spaces):"
msgstr "Setiap baris yang signifikan dari berkas <filename>/etc/inetd.conf</filename> menggambarkan sebuah server melalui tujuh ruas (yang dipisah dengan spasi):"

msgid "The TCP or UDP port number, or the service name (which is mapped to a standard port number with the information contained in the <filename>/etc/services</filename> file)."
msgstr "Nomor port TCP atau UDP, atau nama layanan (yang dipetakan ke nomor port standar dengan informasi yang terkandung dalam berkas <filename>/etc/services</filename>)."

msgid "The socket type: <literal>stream</literal> for a TCP connection, <literal>dgram</literal> for UDP datagrams."
msgstr "Jenis soket: <literal>stream</literal> untuk koneksi TCP, <literal>dgram</literal> untuk datagram UDP."

msgid "The protocol: <literal>tcp</literal> or <literal>udp</literal>."
msgstr "Protokol: <literal>tcp</literal> atau <literal>udp</literal>."

msgid "The options: two possible values: <literal>wait</literal> or <literal>nowait</literal>, to tell <command>inetd</command> whether it should wait or not for the end of the launched process before accepting another connection. For TCP connections, easily multiplexable, you can usually use <literal>nowait</literal>. For programs responding over UDP, you should use <literal>nowait</literal> only if the server is capable of managing several connections in parallel. You can suffix this field with a period, followed by the maximum number of connections authorized per minute (the default limit is 256)."
msgstr "Pilihan: dua nilai yang mungkin: <literal>wait</literal> atau <literal>nowait</literal>, untuk memberitahu <command>inetd</command> apakah itu harus menunggu atau tidak untuk akhir dari proses diluncurkan sebelum menerima koneksi lain. Untuk koneksi TCP, yang mudah dimultiplekskan, Anda dapat biasanya menggunakan <literal>nowait</literal>. Untuk program yang merespon melalui UDP, Anda harus menggunakan <literal>nowait</literal> hanya jika server mampu mengelola beberapa koneksi secara paralel. Anda dapat menambahkan akhiran pada ruas ini dengan titik dua, diikuti oleh jumlah maksimum koneksi resmi per menit (batas default adalah 256)."

msgid "The user name of the user under whose identity the server will run."
msgstr "Nama pengguna yang di bawah identitasnya server akan berjalan."

msgid "The full path to the server program to execute."
msgstr "Path lengkap ke program server yang akan dijalankan."

msgid "The arguments: this is a complete list of the program's arguments, including its own name (<literal>argv[0]</literal> in C)."
msgstr "Argumen: ini adalah daftar lengkap dari argumen program, termasuk nama sendiri (<literal>argv[0]</literal> dalam C)."

msgid "The following example illustrates the most common cases:"
msgstr "Contoh berikut menggambarkan kasus-kasus yang paling umum:"

msgid "Excerpt from <filename>/etc/inetd.conf</filename>"
msgstr "Kutipan dari <filename>/etc/inetd.conf</filename>"

msgid ""
"talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
"finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
"ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"
msgstr ""
"talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
"finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
"ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"

msgid "<primary><command>tcpd</command></primary>"
msgstr "<primary><command>tcpd</command></primary>"

msgid "The <command>tcpd</command> program is frequently used in the <filename>/etc/inetd.conf</filename> file. It allows limiting incoming connections by applying access control rules, documented in the <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page, and which are configured in the <filename>/etc/hosts.allow</filename> and <filename>/etc/hosts.deny</filename> files. Once it has been determined that the connection is authorized, <command>tcpd</command> executes the real server (like <command>in.fingerd</command> in our example). It is worth noting that <command>tcpd</command> relies on the name under which it was invoked (that is the first argument, <literal>argv[0]</literal>) to identify the real program to run. So you should not start the arguments list with <literal>tcpd</literal> but with the program that must be wrapped."
msgstr "Program <command>tcpd</command> sering digunakan dalam berkas <filename>/etc/inetd.conf</filename>. Hal ini memungkinkan membatasi koneksi masuk dengan menerapkan aturan kontrol akses, didokumentasikan di halaman manual <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry>, yang dikonfigurasi di berkas <filename>/etc/hosts.allow</filename> dan <filename>/etc/hosts.deny</filename>. Setelah ditentukan bahwa sambungan diizinkan, <command>tcpd</command> mengeksekusi server sebenarnya (seperti <command>in.fingerd</command> dalam contoh kita). Perlu dicatat bahwa <command>tcpd</command> mengandalkan nama apa dia dipanggil (yaitu argumen pertama, <literal>argv [0]</literal>) untuk mengidentifikasi program nyata yang akan dijalankan. Jadi Anda tidak harus memulai daftar argumen dengan <literal>tcpd</literal> tapi dengan program yang harus dibungkus."

msgid "<emphasis>COMMUNITY</emphasis> Wietse Venema"
msgstr "<emphasis>KOMUNITAS</emphasis> Wietse Venema"

msgid "<primary>Wietse Venema</primary>"
msgstr "<primary>Wietse Venema</primary>"

msgid "<primary>Venema, Wietse</primary>"
msgstr "<primary>Venema, Wietse</primary>"

msgid "Wietse Venema, whose expertise in security has made him a renowned programmer, is the author of the <command>tcpd</command> program. He is also the main creator of Postfix, the modular e-mail server (SMTP, Simple Mail Transfer Protocol), designed to be safer and more reliable than <command>sendmail</command>, which features a long history of security vulnerabilities."
msgstr "Wietse Venema, yang keahliannya dalam keamanan telah membuatnya menjadi programmer yang terkenal, adalah penulis program <command>tcpd</command>. Ia adalah pencipta utama Postfix, server modular surel (SMTP, Simple Mail Transfer Protocol), yang dirancang untuk menjadi lebih aman dan lebih dapat diandalkan daripada <command>sendmail</command>, yang memiliki sejarah panjang kerentanan keamanan."

msgid "<emphasis>ALTERNATIVE</emphasis> Other <command>inetd</command> commands"
msgstr "<emphasis>ALTERNATIF</emphasis> Perintah <command>inetd</command> lain"

msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> and <emphasis role=\"pkg\">xinetd</emphasis>."
msgstr "Walaupun Debian menginstal <emphasis role=\"pkg\">openbsd-inetd</emphasis> secara default, ada tidak ada kekurangan alternatif: kita dapat menyebutkan <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis>, dan <emphasis role=\"pkg\">xinetd</emphasis>."

msgid "This last incarnation of a super-server offers very interesting possibilities. Most notably, its configuration can be split into several files (stored, of course, in the <filename>/etc/xinetd.d/</filename> directory), which can make an administrator's life easier."
msgstr "Inkarnasi ini terakhir server super menawarkan kemungkinan yang sangat menarik. Paling menonjol, konfigurasinya dapat dibagi menjadi beberapa berkas (disimpan, tentu saja, dalam direktori <filename>/etc/xinetd.d/</filename>), yang dapat membuat hidup seorang administrator lebih mudah."

msgid "Last but not least, it is even possible to emulate <command>inetd</command>'s behavior with <command>systemd</command>'s socket-activation mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "Terakhir tetapi bukan tidak penting, bahkan mungkin untuk meniru perilaku <command>inetd</command> dengan mekanisme aktivasi soket <command>systemd</command> (lihat <xref linkend=\"sect.systemd\" />)."

msgid "Scheduling Tasks with <command>cron</command> and <command>atd</command>"
msgstr "Menjadwalkan Tugas dengan <command>cron</command> dan <command>atd</command>"

msgid "<primary><command>cron</command></primary>"
msgstr "<primary><command>cron</command></primary>"

msgid "<primary><command>atd</command></primary>"
msgstr "<primary><command>atd</command></primary>"

msgid "<primary>scheduled commands</primary>"
msgstr "<primary>perintah-perintah yang dijadwalkan</primary>"

msgid "<primary>command scheduling</primary>"
msgstr "<primary>penjadwalan perintah</primary>"

msgid "<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every day, every week, etc.); <command>atd</command> is that which deals with commands to be executed a single time, but at a specific moment in the future."
msgstr "<command>cron</command> adalah daemon yang bertanggung jawab untuk mengeksekusi perintah terjadwal dan berulang (setiap hari, setiap minggu, dll.); <command>atd</command> adalah yang berurusan dengan perintah yang akan dieksekusi sekali, tapi pada waktu tertentu di masa depan."

msgid "In a Unix system, many tasks are scheduled for regular execution:"
msgstr "Dalam sistem Unix, banyak tugas yang dijadwalkan untuk dieksekusi berkala:"

msgid "rotating the logs;"
msgstr "merotasi log;"

msgid "updating the database for the <command>locate</command> program;"
msgstr "memperbarui basis data untuk program <command>locate</command>;"

msgid "back-ups;"
msgstr "back-up;"

msgid "maintenance scripts (such as cleaning out temporary files)."
msgstr "skrip pemeliharaan (misalnya pembersihan berkas sementara)."

msgid "By default, all users can schedule the execution of tasks. Each user has thus their own <emphasis>crontab</emphasis> in which they can record scheduled commands. It can be edited by running <command>crontab -e</command> (its content is stored in the <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> file)."
msgstr "Secara default, semua pengguna dapat menjadwalkan pelaksanaan tugas. Dengan demikian, setiap pengguna memiliki sendiri <emphasis>crontab</emphasis> di mana mereka dapat merekam perintah yang dijadwalkan. Ini dapat diedit dengan menjalankan <command>crontab -e</command> (isinya disimpan dalam berkas <filename>/var/spool/cron/crontabs/<replaceable>pengguna</replaceable></filename>)."

msgid "<emphasis>SECURITY</emphasis> Restricting <command>cron</command> or <command>atd</command>"
msgstr "<emphasis>KEAMANAN</emphasis> Membatasi <command>cron</command> atau <command>atd</command>"

msgid "You can restrict access to <command>cron</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files."
msgstr "Anda dapat membatasi akses ke <command>cron</command> dengan membuat berkas otorisasi eksplisit (whitelist) di <filename>/etc/cron.allow</filename>, di mana Anda menunjukkan hanya pengguna yang berwenang untuk menjadwalkan perintah. Semua yang lain akan secara otomatis kehilangan fitur ini. Sebaliknya, hanya untuk memblokir satu atau dua pengacau, Anda bisa menulis nama mereka dalam file larangan eksplisit (blacklist), <filename>/etc/cron.deny</filename>. Fitur yang sama tersedia untuk <command>atd</command>, dengan berkas <filename>/etc/at.allow</filename> dan <filename>/etc/at.deny</filename>."

msgid "The root user has their own <emphasis>crontab</emphasis>, but can also use the <filename>/etc/crontab</filename> file, or write additional <emphasis>crontab</emphasis> files in the <filename>/etc/cron.d</filename> directory. These last two solutions have the advantage of being able to specify the user identity to use when executing the command."
msgstr "Pengguna root punya <emphasis>crontab</emphasis> mereka sendiri, tapi dapat juga menggunakan berkas <filename>/etc/crontab</filename>, atau menulis berkas <emphasis>crontab</emphasis> tambahan dalam direktori <filename>/etc/cron.d</filename>. Dua solusi terakhir ini memiliki keuntungan menjadi dapat menentukan identitas pengguna yang dimanfaatkan ketika mengeksekusi perintah."

msgid "The <emphasis>cron</emphasis> package includes by default some scheduled commands that execute:"
msgstr "Paket <emphasis>cron</emphasis> termasuk secara default beberapa perintah terjadwal yang mengeksekusi:"

msgid "programs in the <filename>/etc/cron.hourly/</filename> directory once per hour;"
msgstr "program-program dalam direktori <filename>/etc/cron.hourly/</filename> sekali per jam;"

msgid "programs in <filename>/etc/cron.daily/</filename> once per day;"
msgstr "program-program di <filename>/etc/cron.daily/</filename> sekali per hari;"

msgid "programs in <filename>/etc/cron.weekly/</filename> once per week;"
msgstr "program-program di <filename>/etc/cron.weekly/</filename> sekali per minggu;"

msgid "programs in <filename>/etc/cron.monthly/</filename> once per month."
msgstr "program-program di <filename>/etc/cron.monthly/</filename> sekali per bulan."

msgid "Many Debian packages rely on this service: by putting maintenance scripts in these directories, they ensure optimal operation of their services."
msgstr "Banyak paket Debian yang banyak bergantung pada layanan ini: dengan menempatkan skrip pemeliharaan dalam direktori ini, mereka memastikan pengoperasian yang optimal atas layanan mereka."

msgid "Format of a <filename>crontab</filename> File"
msgstr "Format dari sebuah Berkas <filename>crontab</filename>"

msgid "<primary><filename>crontab</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

msgid "<emphasis>TIP</emphasis> Text shortcuts for <command>cron</command>"
msgstr "<emphasis>TIP</emphasis> Pintasan teks untuk <command>cron</command>"

msgid "<command>cron</command> recognizes some abbreviations which replace the first five fields in a <filename>crontab</filename> entry. They correspond to the most classic scheduling options:"
msgstr "<command>cron</command> mengenali beberapa singkatan yang menggantikan lima ruas pertama dalam entri <filename>crontab</filename>. Mereka sesuai dengan pilihan penjadwalan yang paling klasik:"

msgid "<literal>@yearly</literal>: once per year (January 1, at 00:00);"
msgstr "<literal>@yearly</literal>: sekali per tahun (1 Januari, pukul 24:00);"

msgid "<literal>@monthly</literal>: once per month (the 1st of the month, at 00:00);"
msgstr "<literal>@monthly</literal>: sekali per bulan (tanggal 1, pukul 24:00);"

msgid "<literal>@weekly</literal>: once per week (Sunday at 00:00);"
msgstr "<literal>@weekly</literal>: sekali per minggu (hari Minggu pukul 24:00);"

msgid "<literal>@daily</literal>: once per day (at 00:00);"
msgstr "<literal>@daily</literal>: sekali per hari (pukul 24:00);"

msgid "<literal>@hourly</literal>: once per hour (at the beginning of each hour)."
msgstr "<literal>@hourly</literal>: sekali per jam (pada permulaan setiap jam)."

msgid "<emphasis>SPECIAL CASE</emphasis> <command>cron</command> and daylight savings time"
msgstr "<emphasis>KASUS KHUSUS</emphasis> <command>cron</command> dan daylight saving time"

msgid "In Debian, <command>cron</command> takes the time change (for Daylight Savings Time, or in fact for any significant change in the local time) into account as best as it can. Thus, the commands that should have been executed during an hour that never existed (for example, tasks scheduled at 2:30 am during the Spring time change in France, since at 2:00 am the clock jumps directly to 3:00 am) are executed shortly after the time change (thus around 3:00 am DST). On the other hand, in autumn, when commands would be executed several times (2:30 am DST, then an hour later at 2:30 am standard time, since at 3:00 am DST the clock turns back to 2:00 am) are only executed once."
msgstr "Di Debian, <command>cron</command> memperhitungkan perubahan waktu (Daylight Savings Time, atau bahkan untuk perubahan signifikan dalam waktu setempat) sebaik mungkin. Dengan demikian, perintah yang harus dilaksanakan selama satu jam yang tidak pernah ada (misalnya, tugas-tugas yang dijadwalkan di 2:30 selama musim semi waktu perubahan di Perancis, karena pada pukul 2:00 waktu melompat secara langsung ke 3:00) dijalankan tak lama setelah perubahan waktu (dengan demikian sekitar 3:00 am DST). Di sisi lain, di musim gugur, ketika perintah akan dijalankan beberapa kali (2:30 am DST, kemudian sejam kemudian di 2:30 am waktu standar, karena pada 3:00 am DST jam berubah kembali untuk 2:00 am) hanya dilakukan sekali."

msgid "Be careful, however, if the order in which the different scheduled tasks and the delay between their respective executions matters, you should check the compatibility of these constraints with <command>cron</command>'s behavior; if necessary, you can prepare a special schedule for the two problematic nights per year."
msgstr "Namun hati-hati, jika urutan antara tugas berbeda yang dijadwalkan dan penundaan antara eksekusi mereka masing-masing penting, Anda harus memeriksa kompatibilitas kendala dengan perilaku <command>cron</command>; jika perlu, Anda dapat mempersiapkan jadwal khusus untuk dua malam bermasalah per tahun."

msgid "Each significant line of a <emphasis>crontab</emphasis> describes a scheduled command with the six (or seven) following fields:"
msgstr "Setiap baris yang signifikan dari <emphasis>crontab</emphasis> menggambarkan perintah yang dijadwalkan dengan enam (atau tujuh) ruas berikut:"

msgid "the value for the minute (number from 0 to 59);"
msgstr "nilai untuk menit (angka dari 0-59);"

msgid "the value for the hour (from 0 to 23);"
msgstr "nilai untuk jam (dari 0 sampai 23);"

msgid "the value for the day of the month (from 1 to 31);"
msgstr "nilai untuk tanggal (dari 1 sampai 31);"

msgid "the value for the month (from 1 to 12);"
msgstr "nilai untuk bulan (dari 1 untuk 12);"

msgid "the value for the day of the week (from 0 to 7, 1 corresponding to Monday, Sunday being represented by both 0 and 7; it is also possible to use the first three letters of the name of the day of the week in English, such as <literal>Sun</literal>, <literal>Mon</literal>, etc.);"
msgstr "nilai hari pada suatu minggu (dari 0 sampai 7, 1 berarti Senin, Minggu diwakili oleh 0 atau 7; juga dimungkinkan untuk menggunakan tiga huruf pertama dari nama hari dalam seminggu dalam bahasa Inggris, seperti <literal>Sun</literal>, <literal>Mon</literal>, dll.);"

msgid "the user name under whose identity the command must be executed (in the <filename>/etc/crontab</filename> file and in the fragments located in <filename>/etc/cron.d/</filename>, but not in the users' own crontab files);"
msgstr "nama pengguna yang identitasnya akan dipakai untuk menjalankan perintah (di berkas <filename>/etc/crontab</filename> dan dalam fragmen yang terletak di <filename>/etc/cron.d/</filename>, tetapi tidak di berkas crontab pengguna sendiri);"

msgid "the command to execute (when the conditions defined by the first five columns are met)."
msgstr "perintah yang akan dilaksanakan (ketika kondisi yang didefinisikan oleh ke lima kolom pertama terpenuhi)."

msgid "All these details are documented in the <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgstr "Semua rincian ini didokumentasikan di halaman manual <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."

msgid "Each value can be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values."
msgstr "Setiap nilai dapat dinyatakan dalam bentuk daftar nilai yang mungkin (dipisahkan dengan koma). Sintaks <literal>a-b</literal> menjelaskan interval semua nilai antara <literal>a</literal> dan <literal>b</literal>. Sintaks <literal>a-b/c</literal> menggambarkan interval dengan kenaikan <literal>c</literal> (contoh: <literal>0-10/2</literal> berarti <literal>0,2,4,6,8,10</literal>). Asterisk <literal>*</literal> adalah wildcard, mewakili semua nilai yang mungkin."

msgid "Sample <filename>crontab</filename> file"
msgstr "Sampel berkas <filename>crontab</filename>"

msgid ""
"#Format\n"
"#min hour day mon dow  command\n"
"\n"
"# Download data every night at 7:25 pm\n"
" 25  19   *   *   *    $HOME/bin/get.pl\n"
"\n"
"# 8:00 am, on weekdays (Monday through Friday)\n"
" 00  08   *   *   1-5  $HOME/bin/dosomething\n"
"\n"
"# Restart the IRC proxy after each reboot\n"
"@reboot /usr/bin/dircproxy"
msgstr "#Format\n#min jam hari bul dow perintah\n\n# Unduh data setiap malam pukul 19.25\n 25 19 * * * $HOME /bin/get.pl\n\n# 08:00, pada hari kerja (Senin hingga Jumat)\n 00 08 * * 1-5 $HOME/bin/dosomething\n\n# Mulai ulang proxy IRC setelah setiap reboot\n@reboot /usr/bin/dircproxy"

msgid "<emphasis>TIP</emphasis> Executing a command on boot"
msgstr "<emphasis>TIPS</emphasis> Mengeksekusi perintah saat boot"

msgid "To execute a command a single time, just after booting the computer, you can use the <literal>@reboot</literal> macro (a simple restart of <command>cron</command> does not trigger a command scheduled with <literal>@reboot</literal>). This macro replaces the first five fields of an entry in the <emphasis>crontab</emphasis>."
msgstr "Untuk mengeksekusi perintah sekali saja, hanya setelah komputer boot, Anda dapat menggunakan makro <literal>@reboot</literal> (sekadar merestart <command>cron</command> tidak memicu perintah yang dijadwalkan dengan <literal>@reboot</literal>). Makro ini menggantikan lima ruas entri pertama di <emphasis>crontab</emphasis>."

msgid "<emphasis>ALTERNATIVE</emphasis> Emulating <command>cron</command> with <command>systemd</command>"
msgstr "<emphasis>ALTERNATIF</emphasis> Mengemulasi <command>cron</command> dengan <command>systemd</command>"

msgid "It is possible to emulate part of <command>cron</command>'s behavior with <command>systemd</command>'s timer mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "Mungkin untuk meniru sebagian perilaku <command>cron</command> dengan mekanisme timer <command>systemd</command> (lihat <xref linkend=\"sect.systemd\" />)."

msgid "Using the <command>at</command> Command"
msgstr "Menggunakan Perintah <command>at</command>"

msgid "<primary><command>at</command></primary>"
msgstr "<primary><command>at</command></primary>"

msgid "The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.15</literal> thus representing 27 July 2015), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2015-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (ie., <literal>12/25/15</literal> or <literal>12/25/2015</literal> will be December 25, 2015), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122515</literal> or <literal>12252015</literal> will, likewise, represent December 25, 2015). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory."
msgstr "<command>at</command> mengeksekusi perintah pada saat tertentu di masa depan. Ini membutuhkan masukan waktu dan tanggal sebagai parameter baris perintah, dan perintah akan dieksekusi di masukan standar. Perintah akan dieksekusi seolah-olah itu telah dimasukkan di shell saat ini. <command>at</command> bahkan mempertahankan lingkungan saat ini, untuk mereproduksi kondisi yang sama ketika itu mengeksekusi perintah. Waktu ditunjukkan dengan mengikuti konvensi biasa: <literal>16:12</literal> atau <literal>4:12 pm</literal> mewakili 4:12 pm. Tanggal dapat ditentukan dalam beberapa format Eropa dan Barat, termasuk <literal>DD. MM. YY</literal> (<literal>27.07.15</literal> dengan demikian mewakili 27 Juli 2015), <literal>YYYY-MM-DD</literal> (tanggal yang sama ini dinyatakan sebagai <literal>2015-07-27</literal>), <literal>MM/DD/ [CC]YY</literal> (yaitu, <literal>12/25/15</literal> atau <literal>12/25/2015</literal> akan menjadi 25 Desember 2015), atau sekadar <literal>MMDD[CC]YY</literal> (Jadi <literal>122515</literal> atau <literal>12252015</literal> akan juga mewakili 25 Desember 2015). Tanpa itu, perintah akan dilaksanakan segera setelah jam mencapai waktu yang ditunjukkan (hari yang sama, atau besok jika waktu itu telah melewati pada hari yang sama). Anda juga dapat menulis \"today (hari ini)\" atau \"tomorrow (besok)\", yang sudah cukup jelas."

msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"

msgid "An alternative syntax postpones the execution for a given duration: <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command>. The <replaceable>period</replaceable> can be <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal>, or <literal>weeks</literal>. The <replaceable>number</replaceable> simply indicates the number of said units that must elapse before execution of the command."
msgstr "Suatu sintaks alternatif menunda eksekusi untuk durasi tertentu: <command>at now + <replaceable>angka</replaceable> <replaceable>periode</replaceable></command>. <replaceable>periode</replaceable> bisa berupa <literal>minutes</literal> (menit), <literal>hours</literal> (jam), <literal>days</literal> (hari), atau <literal>weeks</literal> (minggu). <replaceable>angka</replaceable> hanya menunjukkan banyaknya unit yang harus dilalui sebelum pelaksanaan perintah."

msgid "To cancel a task scheduled by <command>cron</command>, simply run <command>crontab -e</command> and delete the corresponding line in the <emphasis>crontab</emphasis> file. For <command>at</command> tasks, it is almost as easy: run <command>atrm <replaceable>task-number</replaceable></command>. The task number is indicated by the <command>at</command> command when you scheduled it, but you can find it again with the <command>atq</command> command, which gives the current list of scheduled tasks."
msgstr "Untuk membatalkan tugas yang dijadwalkan oleh <command>cron</command>, cukup menjalankan <command>crontab -e</command> dan menghapus baris yang sesuai dalam berkas <emphasis>crontab</emphasis>. Untuk tugas <command>at</command>, hampir sama mudahnya: jalankan <command>atrm <replaceable>nomor-tugas</replaceable></command>. Nomor tugas ditunjukkan oleh perintah <command>at</command> saat Anda menjadwalkan itu, tetapi Anda dapat menemukannya lagi dengan perintah <command>atq</command>, yang memberikan daftar tugas terjadwal."

msgid "<primary><command>atrm</command></primary>"
msgstr "<primary><command>atrm</command></primary>"

msgid "<primary><command>atq</command></primary>"
msgstr "<primary><command>atq</command></primary>"

msgid "Scheduling Asynchronous Tasks: <command>anacron</command>"
msgstr "Menjadwalkan Tugas-tugas Asinkron: <command>anacron</command>"

msgid "<command>anacron</command> is the daemon that completes <command>cron</command> for computers that are not on at all times. Since regular tasks are usually scheduled for the middle of the night, they will never be executed if the computer is off at that time. The purpose of <command>anacron</command> is to execute them, taking into account periods in which the computer is not working."
msgstr "<command>anacron</command> adalah daemon yang melengkapi <command>cron</command> untuk komputer yang tidak menyala setiap saat. Karena tugas-tugas rutin biasanya dijadwalkan untuk dieksekusi di tengah malam, mereka akan tidak pernah dijalankan jika komputer pada waktu itu. Tujuan <command>anacron</command> adalah untuk mengeksekusi mereka, mempertimbangkan periode saat komputer tidak bekerja."

msgid "<primary><command>anacron</command></primary>"
msgstr "<primary><command>anacron</command></primary>"

msgid "Please note that <command>anacron</command> will frequently execute such activity a few minutes after booting the machine, which can render the computer less responsive. This is why the tasks in the <filename>/etc/anacrontab</filename> file are started with the <command>nice</command> command, which reduces their execution priority and thus limits their impact on the rest of the system. Beware, the format of this file is not the same as that of <filename>/etc/crontab</filename>; if you have particular needs for <command>anacron</command>, see the <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page."
msgstr "Harap dicatat bahwa <command>anacron</command> sering akan melaksanakan kegiatan tersebut beberapa menit setelah komputer boot, yang dapat membuat komputer kurang responsif. Inilah sebabnya mengapa tugas-tugas di berkas <filename>/etc/anacrontab</filename> dimulai dengan perintah <command>nice</command>, yang mengurangi prioritas eksekusi mereka dan dengan demikian membatasi dampak mereka di seluruh sistem. Berhati-hatilah, format berkas ini tidak sama dengan <filename>/etc/crontab</filename>; jika Anda memiliki kebutuhan khusus untuk <command>anacron</command>, lihat halaman manual <citerefentry><refentrytitle>anacrontab</refentrytitle><manvolnum>5</manvolnum></citerefentry>."

msgid "<emphasis>BACK TO BASICS</emphasis> Priorities and <command>nice</command>"
msgstr "<emphasis>KEMBALI KE DASAR</emphasis> Prioritas dan <command>nice</command>"

msgid "Unix systems (and thus Linux) are multi-tasking and multi-user systems. Indeed, several processes can run in parallel, and be owned by different users: the kernel mediates access to the resources between the different processes. As a part of this task, it has a concept of priority, which allows it to favor certain processes over others, as needed. When you know that a process can run in low priority, you can indicate so by running it with <command>nice <replaceable>program</replaceable></command>. The program will then have a smaller share of the CPU, and will have a smaller impact on other running processes. Of course, if no other processes needs to run, the program will not be artificially held back."
msgstr "Sistem Unix (dan dengan demikian Linux) adalah sistem multi-tasking dan multi-user. Memang, beberapa proses dapat berjalan secara paralel, dan dimiliki oleh pengguna yang berbeda: kernel menengahi akses ke sumber daya antara proses yang berbeda. Sebagai bagian dari tugas ini, ada konsep prioritas, yang memungkinkan untuk lebih mendukung proses tertentu daripada yang lain, sesuai kebutuhan. Ketika Anda tahu bahwa proses dapat berjalan dalam prioritas rendah, Anda dapat menunjukkannya dengan menjalankan <command>nice <replaceable>program</replaceable></command>. Program akan memiliki bagian lebih kecil dari CPU, dan akan memiliki dampak yang lebih kecil pada proses berjalan lainnya. Tentu saja, jika tidak ada proses lain yang perlu berjalan, program itu tidak akan dihambat."

msgid "<command>nice</command> works with levels of “niceness”: the positive levels (from 1 to 19) progressively lower the priority, while the negative levels (from -1 to -20) will increase it — but only root can use these negative levels. Unless otherwise indicated (see the <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry> manual page), <command>nice</command> increases the current level by 10."
msgstr "<command>nice</command> bekerja dengan tingkat \"niceness\": tingkat positif (dari 1 sampai 19) semakin menurunkan prioritas, sementara tingkat negatif (dari -1 untuk-20) akan meningkatkan — tetapi hanya root yang dapat menggunakan tingkat negatif ini. Kecuali jika dinyatakan (lihat halaman manual <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry>), <command>nice</command> menaikkan tingkat saat ini sebanyak 10."

msgid "If you discover that an already running task should have been started with <command>nice</command> it is not too late to fix it; the <command>renice</command> command changes the priority of an already running process, in either direction (but reducing the “niceness” of a process is reserved for the root user)."
msgstr "Jika Anda menemukan bahwa tugas yang sudah berjalan seharusnya dimulai dengan <command>nice</command> tidaklah terlalu terlambat untuk memperbaikinya; perintah <command>renice</command> mengubah prioritas proses yang sudah berjalan, di kedua arah (tapi mengurangi nilai \"nice\" proses hanya disediakan untuk pengguna root)."

msgid "Installation of the <emphasis role=\"pkg\">anacron</emphasis> package deactivates execution by <command>cron</command> of the scripts in the <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, and <filename>/etc/cron.monthly/</filename> directories. This avoids their double execution by <command>anacron</command> and <command>cron</command>. The <command>cron</command> command remains active and will continue to handle the other scheduled tasks (especially those scheduled by users)."
msgstr "Instalasi paket <emphasis role=\"pkg\">anacron</emphasis> menonaktifkan eksekusi oleh skrip <command>cron</command> di direktori <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, dan <filename>/etc/cron.monthly/</filename>. Ini menghindari eksekusinya ganda oleh <command>anacron</command> dan <command>cron</command>. Perintah <command>cron</command> tetap aktif dan akan terus menangani tugas terjadwal lain (terutama mereka yang dijadwalkan oleh pengguna)."

msgid "Quotas"
msgstr "Kuota"

msgid "<primary>quota</primary>"
msgstr "<primary>kuota</primary>"

msgid "The quota system allows limiting disk space allocated to a user or group of users. To set it up, you must have a kernel that supports it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is the case with Debian kernels. The quota management software is found in the <emphasis role=\"pkg\">quota</emphasis> Debian package."
msgstr "Sistem kuota memungkinkan membatasi ruang disk yang dialokasikan ke pengguna atau grup pengguna. Untuk mengatur itu, Anda harus memiliki sebuah kernel yang mendukung (dikompail dengan opsi <varname>CONFIG_QUOTA</varname>) — seperti halnya kernel Debian. Perangkat lunak manajemen kuota ada dalam paket Debian <emphasis role=\"pkg\">quota</emphasis>."

msgid "To activate quota in a filesystem, you have to indicate the <literal>usrquota</literal> and <literal>grpquota</literal> options in <filename>/etc/fstab</filename> for the user and group quotas, respectively. Rebooting the computer will then update the quotas in the absence of disk activity (a necessary condition for proper accounting of already used disk space)."
msgstr "Untuk mengaktifkan kuota di sebuah sistem berkas, Anda harus menyatakan pilihan <literal>usrquota</literal> dan <literal>grpquota</literal> di <filename>/etc/fstab</filename> masing-masing untuk kuota pengguna dan grup. Setelah reboot komputer kemudian akan memperbarui kuota ketika tidak ada kegiatan disk (kondisi yang diperlukan untuk akuntansi yang tepat dari ruang disk yang sudah digunakan)."

msgid "The <command>edquota <replaceable>user</replaceable></command> (or <command>edquota -g <replaceable>group</replaceable></command>) command allows you to change the limits while examining current disk space usage."
msgstr "Perintah <command>edquota <replaceable>pengguna</replaceable></command> (atau <command>edquota -g <replaceable>kelompok</replaceable></command>) memungkinkan Anda untuk mengubah batas ketika memeriksa penggunaan disk saat ini."

msgid "<primary><command>edquota</command></primary>"
msgstr "<primary><command>edquota</command></primary>"

msgid "<emphasis>GOING FURTHER</emphasis> Defining quotas with a script"
msgstr "<emphasis>LEBIH LANJUT</emphasis> Menentukan kuota dengan suatu skrip"

msgid "<primary><command>setquota</command></primary>"
msgstr "<primary><command>setquota</command></primary>"

msgid "The <command>setquota</command> program can be used in a script to automatically change many quotas. Its <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> manual page details the syntax to use."
msgstr "Program <command>setquota</command> dapat digunakan dalam skrip untuk secara otomatis mengubah banyak kuota. Halaman manual <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> merinci sintaks yang digunakan."

msgid "The quota system allows you to set four limits:"
msgstr "Sistem kuota memungkinkan Anda untuk mengatur empat batas:"

msgid "two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, a block contains 1024 bytes from the same file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will, however, be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total."
msgstr "dua batas (disebut \"lunak\" dan \"keras\") mengacu pada jumlah blok yang dikonsumsi. Jika sistem berkas diciptakan dengan ukuran blok 1 kibibyte, blok berisi 1024 byte dari berkas yang sama. Blok tak penuh akan menyebabkan kerugian ruang disk. Kuota 100 blok, yang secara teoritis memungkinkan penyimpanan 102,400 byte, akan jenuh dengan hanya 100 berkas yang masing-masing berukuran 500 byte, hanya mewakili 50.000 byte total."

msgid "two limits (soft and hard) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files."
msgstr "dua batas (lembut dan keras) mengacu pada cacah inode yang digunakan. Setiap berkas menempati setidaknya satu inode untuk menyimpan informasi tentangnya (izin, pemilik, stempel waktu akses terakhir, dll). Karena itu, membatasi banyaknya berkas pengguna."

msgid "A “soft” limit can be temporarily exceeded; the user will simply be warned that they are exceeding the quota by the <command>warnquota</command> command, which is usually invoked by <command>cron</command>. A “hard” limit can never be exceeded: the system will refuse any operation that will cause a hard quota to be exceeded."
msgstr "Batas \"lunak\" dapat dilewati sementara; pengguna hanya akan diperingatkan bahwa mereka melebihi kuota oleh perintah <command>warnquota</command>, yang biasanya dipanggil oleh <command>cron</command>. Batas \"keras\" tidak boleh dilampaui: sistem akan menolak setiap operasi yang akan menyebabkan kuota keras dilampaui."

msgid "<emphasis>VOCABULARY</emphasis> Blocks and inodes"
msgstr "<emphasis>KOSAKATA</emphasis> Blok dan inode"

msgid "<primary>block (disk)</primary>"
msgstr "<primary>blok (disk)</primary>"

msgid "<primary>inode</primary>"
msgstr "<primary>inode</primary>"

msgid "The filesystem divides the hard drive into blocks — small contiguous areas. The size of these blocks is defined during creation of the filesystem, and generally varies between 1 and 8 kibibytes."
msgstr "Sistem berkas membagi hard disk menjadi blok-blok — daerah-daerah berurutan yang kecil. Ukuran blok-blok ini didefinisikan selama penciptaan sistem berkas, dan biasanya bervariasi antara 1 dan 8 kibibyte."

msgid "A block can be used either to store the real data of a file, or for meta-data used by the filesystem. Among this meta-data, you will especially find the inodes. An inode uses a block on the hard drive (but this block is not taken into consideration in the block quota, only in the inode quota), and contains both the information on the file to which it corresponds (name, owner, permissions, etc.) and the pointers to the data blocks that are actually used. For very large files that occupy more blocks than it is possible to reference in a single inode, there is an indirect block system; the inode references a list of blocks that do not directly contain data, but another list of blocks."
msgstr "Suatu blok dapat digunakan baik untuk menyimpan data yang nyata dari sebuah berkas, atau untuk digunakan oleh meta-data sistem berkas. Diantara data meta ini, terutama Anda akan menemukan inode. Inode menggunakan blok pada hard disk (tapi blok ini tidak dihitung dalam kuota blok, hanya di kuota inode), dan berisi informasi tentang berkas yang sesuai (nama, pemilik, izin, dll) dan pointer ke blok data yang benar-benar digunakan. Untuk berkas yang sangat besar yang menempati blok lebih daripada yang mungkin untuk diacu dalam inode tunggal, ada sistem blok yang tidak langsung; inode mengacu daftar blok yang tidak langsung berisi data, tetapi daftar lain dari blok."

msgid "<primary><command>warnquota</command></primary>"
msgstr "<primary><command>warnquota</command></primary>"

msgid "With the <command>edquota -t</command> command, you can define a maximum authorized “grace period” within which a soft limit may be exceeded. After this period, the soft limit will be treated like a hard limit, and the user will have to reduce their disk space usage to within this limit in order to be able to write anything to the hard drive."
msgstr "Dengan perintah <command>edquota -t</command>, Anda dapat menetapkan \"masa tenggang\" maksimum yang diizinkan kapan suatu batas lembut boleh dilampaui. Setelah masa ini, batas lembut akan diperlakukan seperti batas keras, dan pengguna harus mengurangi penggunaan ruang disk mereka ke dalam batas ini agar dapat menulis apapun ke hard disk."

msgid "<emphasis>GOING FURTHER</emphasis> Setting up a default quota for new users"
msgstr "<emphasis>LEBIH LANJUT</emphasis> Menetapkan kuota default untuk pengguna baru"

msgid "To automatically setup a quota for new users, you have to configure a template user (with <command>edquota</command> or <command>setquota</command>) and indicate their user name in the <varname>QUOTAUSER</varname> variable in the <filename>/etc/adduser.conf</filename> file. This quota configuration will then be automatically applied to each new user created with the <command>adduser</command> command."
msgstr "Untuk secara otomatis mengkonfigurasi kuota bagi pengguna baru, Anda harus mengkonfigurasi templat pengguna (dengan <command>edquota</command> atau <command>setquota</command>) dan menunjukkan nama pengguna dalam variabel <varname>QUOTAUSER</varname> di berkas <filename>/etc/ adduser.conf</filename>. Konfigurasi kuota ini akan kemudian secara otomatis diterapkan untuk setiap pengguna baru yang dibuat dengan perintah <command>adduser</command>."

msgid "Making backups is one of the main responsibilities of any administrator, but it is a complex subject, involving powerful tools which are often difficult to master."
msgstr "Membuat cadangan adalah salah satu tanggung jawab utama administrator manapun, tetapi itu adalah subjek yang kompleks, yang melibatkan alat yang seringkali sulit untuk dikuasai."

msgid "<primary>backup</primary>"
msgstr "<primary>backup</primary>"

msgid "<primary>restoration</primary>"
msgstr "<primary>pemulihan</primary>"

msgid "Many programs exist, such as <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Those are client/server system featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. But Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>."
msgstr "Banyak program yang ada, seperti <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Mereka adalah sistem klien/server yang menampilkan banyak pilihan, yang konfigurasi yang agak sulit. Beberapa diantaranya menyediakan antarmuka web yang ramah pengguna untuk mengurangi ini. Tapi Debian berisi puluhan perangkat lunak cadangan lain yang meliputi semua kemungkinan penggunaan kasus, yang Anda dapat Anda konfirmasi dengan mudah memakai <command>apt-cache search backup</command>."

msgid "<primary><command>amanda</command></primary>"
msgstr "<primary><command>amanda</command></primary>"

msgid "<primary><command>bacula</command></primary>"
msgstr "<primary><command>bacula</command></primary>"

msgid "<primary><command>BackupPC</command></primary>"
msgstr "<primary><command>BackupPC</command></primary>"

msgid "Rather than detailing some of them, this section will present the thoughts of the Falcot Corp administrators when they defined their backup strategy."
msgstr "Daripada merinci beberapa dari mereka, artikel ini akan menyajikan pikiran para administrator Falcot Corp ketika mereka mendefinisikan strategi cadangan mereka."

msgid "At Falcot Corp, backups have two goals: recovering erroneously deleted files, and quickly restoring any computer (server or desktop) whose hard drive has failed."
msgstr "Di Falcot Corp, cadangan memiliki dua tujuan: memulihkan berkas yang salah hapus, dan cepat memulihkan komputer (server atau desktop) yang hard disknya gagal."

msgid "Backing Up with <command>rsync</command>"
msgstr "Back Up dengan <command>rsync</command>"

msgid "Backups on tape having been deemed too slow and costly, data will be backed up on hard drives on a dedicated server, on which the use of software RAID (see <xref linkend=\"sect.raid-soft\" />) will protect the data from hard drive failure. Desktop computers are not backed up individually, but users are advised that their personal account on their department's file server will be backed up. The <command>rsync</command> command (from the package of the same name) is used daily to back up these different servers."
msgstr "Cadangan pada tape telah dianggap terlalu lambat dan mahal, data akan disimpan pada hard drive dalam server terdedikasi, yang penggunaan RAID perangkat lunak (lihat <xref linkend=\"sect.raid-soft\" />) akan melindungi data dari kegagalan hard drive. Komputer desktop tidak dibuat cadangannya secara individual, tetapi pengguna disarankan bahwa akun pribadi mereka pada server berkas departemen mereka yang akan dibackup. Perintah <command>rsync</command> (dari paket dengan nama yang sama) digunakan sehari-hari untuk membuat cadangan server-server yang berbeda ini."

msgid "<primary><command>rsync</command></primary>"
msgstr "<primary><command>rsync</command></primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> The hard link, a second name for the file"
msgstr "<emphasis>KEMBALI KE DASAR</emphasis> Hard link, nama kedua untuk berkas"

msgid "<primary>link</primary><secondary>hard link</secondary>"
msgstr "<primary>link</primary><secondary>hard link</secondary>"

msgid "<primary>hard link</primary>"
msgstr "<primary>hard link</primary>"

msgid "A hard link, as opposed to a symbolic link, cannot be differentiated from the linked file. Creating a hard link is essentially the same as giving an existing file a second name. This is why the deletion of a hard link only removes one of the names associated with the file. As long as another name is still assigned to the file, the data therein remain present on the filesystem. It is interesting to note that, unlike a copy, the hard link does not take up additional space on the hard drive."
msgstr "Hard link, sebagai lawan dari link simbolik, tidak bisa dibedakan dari berkas tertautnya. Membuat hard link pada dasarnya adalah sama dengan memberikan nama kedua pada berkas yang ada. Inilah sebabnya mengapa penghapusan hard link hanya menghapus salah satu dari nama-nama yang terkait dengan berkas. Selama nama lain masih diberikan ke berkas, data di dalamnya tetap ada pada sistem berkas. Hal ini menarik untuk dicatat bahwa, tidak seperti salinan, hard link tidak mengambil tambahan ruang pada hard drive."

msgid "A hard link is created with the <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> command. The <replaceable>link</replaceable> file is then a new name for the <replaceable>target</replaceable> file. Hard links can only be created on the same filesystem, while symbolic links are not subject to this limitation."
msgstr "Hard link dibuat dengan perintah <command>ln <replaceable>target</replaceable> <replaceable>tautan</replaceable></command>. Berkas <replaceable>tautan</replaceable> ini adalah nama baru untuk berkas <replaceable>target</replaceable>. Hard link hanya dapat dibuat pada sistem berkas yang sama, sementara link simbolik tidak tunduk pada pembatasan ini."

msgid "The available hard drive space prohibits implementation of a complete daily backup. As such, the <command>rsync</command> command is preceded by a duplication of the content of the previous backup with hard links, which prevents usage of too much hard drive space. The <command>rsync</command> process then only replaces files that have been modified since the last backup. With this mechanism a great number of backups can be kept in a small amount of space. Since all backups are immediately available and accessible (for example, in different directories of a given share on the network), you can quickly make comparisons between two given dates."
msgstr "Ruang hard drive yang tersedia melarang pelaksanaan pembuatan cadangan harian yang lengkap. Dengan demikian, perintah <command>rsync</command> didahului oleh duplikasi konten cadangan sebelumnya dengan hard link, yang mencegah penggunaan terlalu banyak ruang hard drive. Proses <command>rsync</command> kemudian hanya menggantikan berkas yang telah diubah sejak terakhir dibuat cadangan. Dengan mekanisme ini sejumlah besar cadangan akan disimpan dalam ruang yang kecil. Karena semua cadangan seketika tersedia dan dapat diakses (misalnya, di berbagai direktori bersama pada jaringan), Anda dapat dengan cepat membuat perbandingan antara dua tanggal yang diberikan."

msgid "<primary>copy, backup copy</primary>"
msgstr "<primary>salinan, salinan cadangan</primary>"

msgid "<primary>backup</primary><secondary>copy</secondary>"
msgstr "<primary>cadangan</primary><secondary>salinan</secondary>"

msgid "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"

msgid "This backup mechanism is easily implemented with the <command>dirvish</command> program. It uses a backup storage space (“bank” in its vocabulary) in which it places timestamped copies of sets of backup files (these sets are called “vaults” in the dirvish documentation)."
msgstr "Mekanisme pembuatan cadangan ini mudah diimplementasikan dengan program <command>dirvish</command>. Menggunakan ruang penyimpanan cadangan (\"bank\" dalam kosa katanya) untuk menempatkan salinan set berkas cadangan yang diberi stempel waktu (set ini yang disebut \"vault\" dalam dokumentasi dirvish)."

msgid "The main configuration is in the <filename>/etc/dirvish/master.conf</filename> file. It defines the location of the backup storage space, the list of “vaults” to manage, and default values for expiration of the backups. The rest of the configuration is located in the <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> files and contains the specific configuration for the corresponding set of files."
msgstr "Konfigurasi utama ada di berkas <filename>/etc/dirvish/master.conf</filename>. Itu mendefinisikan lokasi ruang penyimpanan cadangan, daftar \"vault\" yang dikelola, dan nilai default bagi kedaluwarsa cadangan. Sisa konfigurasi terletak di berkas <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> dan berisi konfigurasi spesifik untuk set berkas yang terkait."

msgid "The <filename>/etc/dirvish/master.conf</filename> file"
msgstr "Berkas <filename>/etc/dirvish/master.conf</filename>"

msgid ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   MIN HR    DOM MON       DOW  STRFTIME_FMT\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"
msgstr ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   MIN HR    DOM MON       DOW  STRFTIME_FMT\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"

msgid "The <literal>bank</literal> setting indicates the directory in which the backups are stored. The <literal>exclude</literal> setting allows you to indicate files (or file types) to exclude from the backup. The <literal>Runall</literal> is a list of file sets to backup with a time-stamp for each set, which allows you to assign the correct date to the copy, in case the backup is not triggered at precisely the assigned time. You have to indicate a time just before the actual execution time (which is, by default, 10:04 pm in Debian, according to <filename>/etc/cron.d/dirvish</filename>). Finally, the <literal>expire-default</literal> and <literal>expire-rule</literal> settings define the expiration policy for backups. The above example keeps forever backups that are generated on the first Sunday of each quarter, deletes after one year those from the first Sunday of each month, and after 3 months those from other Sundays. Other daily backups are kept for 15 days. The order of the rules does matter, Dirvish uses the last matching rule, or the <literal>expire-default</literal> one if no other <literal>expire-rule</literal> matches."
msgstr "Pengaturan <literal>bank</literal> menunjukkan direktori di mana cadangan disimpan. Pengaturan <literal>exclude</literal> memungkinkan Anda untuk menunjukkan berkas (atau jenis berkas) yang dikecualikan dari cadangan. <literal>Runall</literal> adalah daftar set berkas yang akan dibuat cadangannya dengan sebuah stempel waktu untuk setiap set, yang memungkinkan Anda untuk menetapkan tanggal yang benar yang akan disalin, dalam kasus cadangan tidak dipicu pada tepat waktu yang ditetapkan. Anda harus menunjukkan waktu yang tepat sebelum waktu eksekusi yang sebenarnya (yang, secara default, 22:04 di Debian, menurut <filename>/etc/cron.d/dirvish</filename>). Akhirnya, pengaturan <literal>expire-default</literal> dan <literal>expire-rule</literal> menetapkan kebijakan kedaluwarsa untuk cadangan. Contoh di atas menyimpan selamanya cadangan yang dihasilkan pada hari Minggu pertama setiap kuartal, menghapus setelah satu tahun dari hari Minggu pertama setiap bulan, dan setelah 3 bulan dari hari Minggu lainnya. Cadangan harian lainnya disimpan selama 15 hari. Urutan aturan penting, Dirvish menggunakan aturan terakhir yang cocok, atau <literal>expire-default</literal> jika tidak ada <literal>expire-rule</literal> yang cocok."

msgid "<emphasis>IN PRACTICE</emphasis> Scheduled expiration"
msgstr "<emphasis>DALAM PRAKTEK</emphasis> Kedaluwarsa terjadwal"

msgid "The expiration rules are not used by <command>dirvish-expire</command> to do its job. In reality, the expiration rules are applied when creating a new backup copy to define the expiration date associated with that copy. <command>dirvish-expire</command> simply peruses the stored copies and deletes those for which the expiration date has passed."
msgstr "Aturan kedaluwarsa tidak digunakan oleh <command>dirvish-expire</command> untuk melakukan tugasnya. Pada kenyataannya, aturan kedaluwarsa diterapkan ketika membuat salinan cadangan baru untuk menentukan tanggal kedaluwarsa yang terkait dengan salinan itu. <command>dirvish-expire</command> cukup memeriksa salinan disimpan dan menghapus berkas yang tanggal kedaluwarsanya telah berlalu."

msgid "The <filename>/backup/root/dirvish/default.conf</filename> file"
msgstr "Berkas <filename>/backup/root/dirvish/default.conf</filename>"

msgid ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"
msgstr ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"

msgid "The above example specifies the set of files to back up: these are files on the machine <emphasis>rivendell.falcot.com</emphasis> (for local data backup, simply specify the name of the local machine as indicated by <command>hostname</command>), especially those in the root tree (<literal>tree: /</literal>), except those listed in <literal>exclude</literal>. The backup will be limited to the contents of one filesystem (<literal>xdev: 1</literal>). It will not include files from other mount points. An index of saved files will be generated (<literal>index: gzip</literal>), and the image will be named according to the current date (<literal>image-default: %Y%m%d</literal>)."
msgstr "Contoh di atas menyatakan set berkas yang akan dibuat cadangannya: ini adalah berkas-berkas pada mesin <emphasis>rivendell.falcot.com</emphasis> (untuk cadangan data lokal, cukup nyatakan nama dari mesin lokal seperti yang ditunjukkan oleh <command>hostname</command>), terutama yang ada di akar pohon (<literal>tree: /</literal>), kecuali yang tercantum dalam <literal>exclude</literal>. Cadangan akan terbatas pada isi dari satu sistem berkas (<literal>xdev: 1</literal>). Itu tidak akan menyertakan berkas dari titik kait lainnya. Suatu indeks dari berkas-berkas yang disimpan akan dihasilkan (<literal>index: gzip</literal>), dan image akan dinamai menurut tanggal saat ini (<literal>image-default: %Y%m%d</literal>)."

msgid "There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired."
msgstr "Ada banyak pilihan yang tersedia, semua didokumentasikan di halaman manual <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>. Setelah berkas konfigurasi ini disiapkan, Anda mesti menginisialisasi setiap set berkas dengan perintah <command>dirvish --vault <replaceable>vault</replaceable>--init</command>. Selanjutnya dari sana eksekusi harian <command>dirvish-runall</command> akan secara otomatis membuat salinan cadangan baru setelah menghapus yang kedaluwarsa."

msgid "<emphasis>IN PRACTICE</emphasis> Remote backup over SSH"
msgstr "<emphasis>DALAM PRAKTEK</emphasis> Cadangan remote melalui SSH"

msgid "When dirvish needs to save data to a remote machine, it will use <command>ssh</command> to connect to it, and will start <command>rsync</command> as a server. This requires the root user to be able to automatically connect to it. The use of an SSH authentication key allows precisely that (see <xref linkend=\"sect.ssh-key-based-auth\" />)."
msgstr "Ketika dirvish perlu menyimpan data ke suatu mesin remote, itu akan menggunakan <command>ssh</command> untuk menyambung ke sana, dan akan memulai <command>rsync</command> sebagai server. Hal ini memerlukan pengguna root untuk dapat secara otomatis menyambung kepadanya. Penggunaan sebuah kunci otentikasi SSH memungkinkan hal itu (lihat <xref linkend=\"sect.ssh-key-based-auth\" />)."

msgid "Restoring Machines without Backups"
msgstr "Memulihkan Mesin tanpa Cadangan"

msgid "Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs prepared with <emphasis>Simple-CDD</emphasis> (see <xref linkend=\"sect.simple-cdd\" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to dconf (see <xref linkend=\"sect.gnome-desktop\" /> for more information about this)."
msgstr "Desktop komputer, yang tidak di backup, akan sangat mudah untuk diinstal ulang dari DVD-ROM kustom yang disiapkan dengan <emphasis>Simple-CDD</emphasis> (lihat <xref linkend=\"sect.simple-cdd\" />). Karena ini melakukan instalasi dari awal, itu kehilangan kustomisasi apapun yang mungkin telah dibuat setelah instalasi awal. Ini tidak apa karena semua sistem terhubung ke direktori LDAP pusat untuk akun dan sebagian besar aplikasi desktop yang telah diprakonfigurasikan berkat dconf (lihat <xref linkend=\"sect.gnome-desktop\" /> untuk informasi lebih lanjut tentang ini)."

msgid "The Falcot Corp administrators are aware of the limits in their backup policy. Since they can't protect the backup server as well as a tape in a fireproof safe, they have installed it in a separate room so that a disaster such as a fire in the server room won't destroy backups along with everything else. Furthermore, they do an incremental backup on DVD-ROM once per week — only files that have been modified since the last backup are included."
msgstr "Para administrator Falcot Corp menyadari batas kebijakan cadangan mereka. Karena mereka tidak bisa melindungi server cadangan serta tape di tempat yang aman yang tahan api, mereka telah terinstal di ruang yang terpisah sehingga bencana seperti kebakaran pada ruang server tidak akan menghancurkan backup bersama dengan segala sesuatu yang lain. Selain itu, mereka melakukan backup incremental pada DVD-ROM sekali per minggu — hanya berkas yang telah dimodifikasi sejak cadangan terakhir yang disertakan."

msgid "<emphasis>GOING FURTHER</emphasis> Backing up SQL and LDAP services"
msgstr "<emphasis>LEBIH LANJUT</emphasis> Membuat cadangan layanan LDAP dan SQL"

msgid "Many services (such as SQL or LDAP databases) cannot be backed up by simply copying their files (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times). As such, it is necessary to use an “export” mechanism to create a “data dump” that can be safely backed up. These are often quite large, but they compress well. To reduce the storage space required, you will only store a complete text file per week, and a <command>diff</command> each day, which is created with a command of the type <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. The <command>xdelta</command> program produces incremental differences from binary dumps."
msgstr "Banyak layanan (seperti basis data LDAP atau SQL) tidak dapat dibuat cadangannya hanya dengan menyalin berkas-berkas mereka (kecuali mereka dihentikan dengan benar selama penciptaan cadangan, yang seringkali bermasalah, karena mereka dimaksudkan untuk menjadi tersedia setiap saat). Dengan demikian, perlu menggunakan mekanisme \"ekspor\" untuk membuat \"curah data\" yang dapat dengan aman dibuat cadangannya. Ini sering cukup besar, tetapi mereka juga dapat dimampatkan. Untuk mengurangi ruang penyimpanan yang diperlukan, Anda akan hanya menyimpan berkas teks lengkap per minggu, dan <command>diff</command> setiap hari, yang dibuat dengan perintah jenis <command>diff <replaceable>berkas_kemarin</replaceable> <replaceable>berkas_hari_ini</replaceable></command>. Program <command>xdelta</command> menghasilkan perbedaan inkremental dari curah biner."

msgid "<primary><command>xdelta</command></primary>"
msgstr "<primary><command>xdelta</command></primary>"

msgid "<primary><command>diff</command></primary>"
msgstr "<primary><command>diff</command></primary>"

msgid "<primary>dump</primary>"
msgstr "<primary>dump</primary>"

msgid "<emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>, the standard for tape backups"
msgstr "<emphasis>KULTUR</emphasis> <emphasis>TAR</emphasis>, standar untuk cadangan tape"

msgid "<primary>backup</primary><secondary>on tape</secondary>"
msgstr "<primary>cadangan</primary><secondary>pada tape</secondary>"

msgid "<primary>tape, backup</primary>"
msgstr "<primary>tape, cadangan</primary>"

msgid "<primary>TAR</primary>"
msgstr "<primary>TAR</primary>"

msgid "Historically, the simplest means of making a backup on Unix was to store a <emphasis>TAR</emphasis> archive on a tape. The <command>tar</command> command even got its name from “Tape ARchive”."
msgstr "Secara historis, cara paling sederhana untuk membuat cadangan pada Unix adalah untuk menyimpan arsip <emphasis>TAR</emphasis> pada tape. Perintah <command>tar</command> bahkan mendapat namanya dari \"Tape ARchive\"."

msgid "Hot Plugging: <emphasis>hotplug</emphasis>"
msgstr "Hot Plugging: <emphasis>hotplug</emphasis>"

msgid "Introduction"
msgstr "Pengenalan"

msgid "The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be hotplugged: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory."
msgstr "Subsistem kernel <emphasis>hotplug</emphasis> secara dinamis menangani penambahan dan penghapusan perangkat, dengan memuat driver yang sesuai dan membuat berkas-berkas divais yang sesuai (dengan bantuan <command>udevd</command>). Dengan perangkat keras modern dan virtualisasi, hampir semuanya dapat di-hotplug: dari peripheral PCMCIA/USB/IEEE 1394 yang biasa sampai hard drive SATA, tetapi juga CPU dan memori."

msgid "The kernel has a database that associates each device ID with the required driver. This database is used during boot to load all the drivers for the peripheral devices detected on the different buses, but also when an additional hotplug device is connected. Once the device is ready for use, a message is sent to <command>udevd</command> so it will be able to create the corresponding entry in <filename>/dev/</filename>."
msgstr "Kernel memiliki basis data yang mengaitkan setiap ID perangkat dengan driver yang diperlukan. Basis data ini digunakan selama boot untuk memuat semua driver untuk perangkat periferal yang terdeteksi pada bus berbeda, tetapi juga ketika perangkat tambahan hotplug terhubung. Setelah perangkat siap untuk digunakan, pesan dikirim ke <command>udevd</command> sehingga akan dapat membuat entri yang sesuai di <filename>/dev/</filename>."

msgid "<primary><emphasis>hotplug</emphasis></primary>"
msgstr "<primary><emphasis>hotplug</emphasis></primary>"

msgid "<primary>hotplug</primary>"
msgstr "<primary>hotplug</primary>"

msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

msgid "<primary>PCMCIA</primary>"
msgstr "<primary>PCMCIA</primary>"

msgid "<primary>SATA</primary>"
msgstr "<primary>SATA</primary>"

msgid "The Naming Problem"
msgstr "Masalah Penamaan"

msgid "Before the appearance of hotplug connections, it was easy to assign a fixed name to a device. It was based simply on the position of the devices on their respective bus. But this is not possible when such devices can come and go on the bus. The typical case is the use of a digital camera and a USB key, both of which appear to the computer as disk drives. The first one connected may be <filename>/dev/sdb</filename> and the second <filename>/dev/sdc</filename> (with <filename>/dev/sda</filename> representing the computer's own hard drive). The device name is not fixed; it depends on the order in which devices are connected."
msgstr "Sebelum munculnya koneksi hotplug, mudah untuk memberikan sebuah nama tetap ke suatu perangkat. Hal ini didasarkan hanya pada posisi perangkat di bus mereka masing-masing. Tetapi hal ini tidak mungkin ketika perangkat tersebut dapat datang dan pergi pada bus. Kasus khas adalah menggunakan kamera digital dan USB flash drive, keduanya muncul ke komputer sebagai disk drive. Yang pertama yang terhubung mungkin <filename>akan/dev/sdb</filename> dan yang kedua <filename>/dev/sdc</filename> (dengan <filename>/dev/sda</filename> mewakili hard drive komputer sendiri). Nama perangkat tidak tetap; itu tergantung pada urutan terhubungnya perangkat."

msgid "Additionally, more and more drivers use dynamic values for devices' major/minor numbers, which makes it impossible to have static entries for the given devices, since these essential characteristics may vary after a reboot."
msgstr "Selain itu, driver lebih dan lebih banyak menggunakan nilai-nilai yang dinamis untuk nomor mayor/minor perangkat, yang membuat tidak mungkin untuk memiliki entri statis untuk perangkat tertentu, karena karakteristik penting ini dapat bervariasi setelah reboot."

msgid "<emphasis>udev</emphasis> was created precisely to solve this problem."
msgstr "<emphasis>udev</emphasis> diciptakan justru untuk memecahkan masalah ini."

msgid "How <emphasis>udev</emphasis> Works"
msgstr "Bagaimana <emphasis>udev</emphasis> Bekerja"

msgid "When <emphasis>udev</emphasis> is notified by the kernel of the appearance of a new device, it collects various information on the given device by consulting the corresponding entries in <filename>/sys/</filename>, especially those that uniquely identify it (MAC address for a network card, serial number for some USB devices, etc.)."
msgstr "Ketika <emphasis>udev</emphasis> diberitahu oleh kernel atas kemunculan perangkat baru, itu mengumpulkan berbagai informasi pada perangkat tersebut dengan memeriksa entri terkait di <filename>/sys/</filename>, terutama mereka yang secara unik mengidentifikasinya (Alamat MAC kartu jaringan, nomor seri untuk beberapa perangkat USB, dll.)."

msgid "Armed with all of this information, <emphasis>udev</emphasis> then consults all of the rules contained in <filename>/etc/udev/rules.d/</filename> and <filename>/lib/udev/rules.d/</filename>. In this process it decides how to name the device, what symbolic links to create (to give it alternative names), and what commands to execute. All of these files are consulted, and the rules are all evaluated sequentially (except when a file uses “GOTO” directives). Thus, there may be several rules that correspond to a given event."
msgstr "Dipersenjatai dengan semua informasi ini, <emphasis>udev</emphasis> kemudian berkonsultasi menjalani seluruh aturan yang terkandung dalam <filename>/etc/udev/rules.d/</filename> dan <filename>/lib/udev/rules.d/</filename>. Dalam prosesnya ini memutuskan bagaimana menamai perangkat, taut simbolik apa yang dibuat (untuk memberinya nama alternatif), dan perintah apa yang dieksekusi. Semua berkas ini diperiksa, dan aturan semua dievaluasi secara berurutan (kecuali ketika berkas menggunakan direktif \"GOTO\"). Dengan demikian, mungkin ada beberapa aturan yang sesuai untuk kejadian tertentu."

msgid "The syntax of rules files is quite simple: each row contains selection criteria and variable assignments. The former are used to select events for which there is a need to react, and the latter defines the action to take. They are all simply separated with commas, and the operator implicitly differentiates between a selection criterion (with comparison operators, such as <literal>==</literal> or <literal>!=</literal>) or an assignment directive (with operators such as <literal>=</literal>, <literal>+=</literal> or <literal>:=</literal>)."
msgstr "Sintaks berkas aturan ini cukup sederhana: setiap baris berisi kriteria pemilihan dan penetapan variabel. Yang terdahulu digunakan untuk memilih kejadian yang perlu ada reaksi, dan yang belakangan mendefinisikan tindakan yang akan diambil. Mereka semua hanya dipisahkan dengan koma, dan operator secara implisit membedakan antara kriteria seleksi (dengan operator perbandingan, seperti <literal>==</literal> atau <literal>!=</literal>) atau direktif penugasan (dengan operator seperti <literal>=</literal>, <literal>+=</literal>, atau <literal>:=</literal>)."

msgid "Comparison operators are used on the following variables:"
msgstr "Operator perbandingan yang digunakan pada variabel berikut:"

msgid "<literal>KERNEL</literal>: the name that the kernel assigns to the device;"
msgstr "<literal>KERNEL</literal>: nama yang deberikan oleh kernel ke perangkat;"

msgid "<literal>ACTION</literal>: the action corresponding to the event (“add” when a device has been added, “remove” when it has been removed);"
msgstr "<literal>AKSI</literal>: tindakan yang sesuai untuk acara (\"add\" ketika perangkat telah ditambahkan, \"remove\" ketika dihapus);"

msgid "<literal>DEVPATH</literal>: the path of the device's <filename>/sys/</filename> entry;"
msgstr "<literal>DEVPATH</literal>: path entri <filename>/sys/</filename> perangkat;"

msgid "<literal>SUBSYSTEM</literal>: the kernel subsystem which generated the request (there are many, but a few examples are “usb”, “ide”, “net”, “firmware”, etc.);"
msgstr "<literal>SUBSYSTEM</literal>: subsistem kernel yang menghasilkan permintaan (ada banyak, tapi beberapa contoh adalah \"usb\", \"ide\", \"net\", \"firmware\", dll.);"

msgid "<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: file contents of the <replaceable>attribute</replaceable> file in the <filename>/sys/<replaceable>$devpath</replaceable>/</filename> directory of the device. This is where you find the MAC address and other bus specific identifiers;"
msgstr "<literal>ATTR {<replaceable>atribut</replaceable>}</literal>: isi berkas dari <replaceable>atribut</replaceable> dalam direktori <filename>/sys/ <replaceable>$devpath</replaceable>/</filename> perangkat. Ini adalah tempat Anda menemukan alamat MAC dan pengenal khusus bus lain;"

msgid "<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> and <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> are variations that will try to match the different options on one of the parent devices of the current device;"
msgstr "<literal>KERNELS</literal>, <literal>SUBSYSTEM</literal>, dan <literal>ATTRS {<replaceable>atribut</replaceable>}</literal> adalah variasi yang akan mencoba untuk mencocokkan pilihan yang berbeda pada salah satu perangkat induk dari perangkat saat ini;"

msgid "<literal>PROGRAM</literal>: delegates the test to the indicated program (true if it returns 0, false if not). The content of the program's standard output is stored so that it can be reused by the <literal>RESULT</literal> test;"
msgstr "<literal>PROGRAM</literal>: mendelegasikan tes ke program ditunjukkan (true jika ia mengembalikan 0, false jika tidak). Isi dari keluaran standar program disimpan sehingga dapat digunakan kembali oleh uji <literal>RESULT</literal>;"

msgid "<literal>RESULT</literal>: execute tests on the standard output stored during the last call to <literal>PROGRAM</literal>."
msgstr "<literal>RESULT</literal>: menjalankan tes pada keluaran standar yang disimpan selama pemanggilan terakhir ke <literal>PROGRAM</literal>."

msgid "The right operands can use pattern expressions to match several values at the same time. For instance, <literal>*</literal> matches any string (even an empty one); <literal>?</literal> matches any character, and <literal>[]</literal> matches the set of characters listed between the square brackets (or the opposite thereof if the first character is an exclamation point, and contiguous ranges of characters are indicated like <literal>a-z</literal>)."
msgstr "Operand kanan dapat menggunakan ekspresi pola untuk mencocokkan beberapa nilai pada waktu yang sama. Sebagai contoh, <literal>*</literal> cocok dengan string apapun (bahkan yang kosong); <literal>?</literal> cocok dengan sebarang karakter, dan <literal>[]</literal> sesuai set karakter yang tercantum antara kurung (atau lawan dari itu jika karakter pertama adalah tanda seru, dan rentang karakter berturutan dituliskan seperti <literal>a-z</literal>)."

msgid "Regarding the assignment operators, <literal>=</literal> assigns a value (and replaces the current value); in the case of a list, it is emptied and contains only the value assigned. <literal>:=</literal> does the same, but prevents later changes to the same variable. As for <literal>+=</literal>, it adds an item to a list. The following variables can be changed:"
msgstr "Mengenai penetapan operator, <literal>=</literal> memberikan nilai (dan menggantikan nilai saat ini); dalam kasus sebuah daftar, itu dikosongkan dan mengandung hanya nilai yang diberikan. <literal>:=</literal> melakukan hal yang sama, tetapi mencegah perubahan belakangan atas variabel yang sama. Adapun <literal>+=</literal>, menambahkan item ke daftar. Variabel berikut dapat diubah:"

msgid "<literal>NAME</literal>: the device filename to be created in <filename>/dev/</filename>. Only the first assignment counts; the others are ignored;"
msgstr "<literal>NAME</literal>: nama berkas perangkat yang akan dibuat di <filename>/dev/</filename>. Hanya penugasan pertama yang penting; yang lain diabaikan;"

msgid "<literal>SYMLINK</literal>: the list of symbolic links that will point to the same device;"
msgstr "<literal>SYMLINK</literal>: daftar taut simbolik yang akan mengarah ke perangkat yang sama;"

msgid "<literal>OWNER</literal>, <literal>GROUP</literal> and <literal>MODE</literal> define the user and group that owns the device, as well as the associated permission;"
msgstr "<literal>OWNER</literal>, <literal>GROUP</literal>, dan <literal>MODE</literal> menentukan pengguna dan kelompok yang memiliki perangkat, serta izin terkait;"

msgid "<literal>RUN</literal>: the list of programs to execute in response to this event."
msgstr "<literal>RUN</literal>: daftar program-program yang akan dijalankan sebagai respon atas kejadian ini."

msgid "The values assigned to these variables may use a number of substitutions:"
msgstr "Nilai-nilai yang ditugaskan ke variabel ini dapat menggunakan sejumlah substitusi:"

msgid "<literal>$kernel</literal> or <literal>%k</literal>: equivalent to <literal>KERNEL</literal>;"
msgstr "<literal>$kernel</literal> atau <literal>%k</literal>: setara dengan <literal>KERNEL</literal>;"

msgid "<literal>$number</literal> or <literal>%n</literal>: the order number of the device, for example, for <literal>sda3</literal>, it would be “3”;"
msgstr "<literal>$number</literal> atau <literal>%n</literal>: nomor urut perangkat, misalnya, untuk <literal>sda3</literal>, itu akan \"3\";"

msgid "<literal>$devpath</literal> or <literal>%p</literal>: equivalent to <literal>DEVPATH</literal>;"
msgstr "<literal>$devpath</literal> atau <literal>%p</literal>: setara dengan <literal>DEVPATH</literal>;"

msgid "<literal>$attr{<replaceable>attribute</replaceable>}</literal> or <literal>%s{<replaceable>attribute</replaceable>}</literal>: equivalent to <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;"
msgstr "<literal>$attr{<replaceable>atribut</replaceable>}</literal> atau <literal>%s{<replaceable>atribut</replaceable>}</literal>: setara dengan <literal>ATTRS {<replaceable>atribut</replaceable>}</literal>;"

msgid "<literal>$major</literal> or <literal>%M</literal>: the kernel major number of the device;"
msgstr "<literal>$major</literal> atau <literal>%M</literal>: nomor mayor kernel dari perangkat;"

msgid "<literal>$minor</literal> or <literal>%m</literal>: the kernel minor number of the device;"
msgstr "<literal>$minor</literal> atau <literal>%m</literal>: nomor minor kernel dari perangkat;"

msgid "<literal>$result</literal> or <literal>%c</literal>: the string output by the last program invoked by <literal>PROGRAM</literal>;"
msgstr "<literal>$result</literal> atau <literal>%c</literal>: string keluaran dari program yang terakhir dipanggil oleh <literal>PROGRAM</literal>;"

msgid "and, finally, <literal>%%</literal> and <literal>$$</literal> for the percent and dollar sign, respectively."
msgstr "dan, akhirnya, <literal>%%</literal> dan <literal>$$</literal> masing-masing untuk persen dan tanda dolar."

msgid "The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive."
msgstr "Di atas daftar ini tidak lengkap (mereka hanya menyertakan parameter-parameter terpenting), tetapi halaman manual <citerefentry><refentrytitle>udev</refentrytitle> <manvolnum>7</manvolnum></citerefentry> harus lengkap."

msgid "A concrete example"
msgstr "Contoh konkret"

msgid "Let us consider the case of a simple USB key and try to assign it a fixed name. First, you must find the elements that will identify it in a unique manner. For this, plug it in and run <command>udevadm info -a -n /dev/sdc</command> (replacing <replaceable>/dev/sdc</replaceable> with the actual name assigned to the key)."
msgstr "Mari kita mempertimbangkan kasus kunci USB sederhana dan mencoba memberikan sebuah nama tetap. Pertama, Anda harus menemukan unsur-unsur yang akan mengidentifikasi secara unik. Untuk ini, tancapkan itu dan jalankan <command>udevadm info -a -n /dev/sdc</command> (menggantikan <replaceable>/dev/sdc</replaceable> dengan nama sebenarnya yang ditetapkan ke kunci)."

msgid ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{hidden}==\"0\"\n"
"    ATTR{events}==\"media_change\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{discard_alignment}==\"0\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{events_async}==\"\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"51\"\n"
"    ATTR{events_poll_msecs}==\"-1\"\n"
"    ATTR{stat}==\"     130        0     6328      435        0        0        0        0        0      252      252        0        0        0        0\"\n"
"    ATTR{size}==\"15100224\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{inflight}==\"       0        0\"\n"
"[...]\n"
"\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0':\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1':\n"
"    KERNELS==\"2-1\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{bDeviceProtocol}==\"00\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{busnum}==\"2\"\n"
"    ATTRS{quirks}==\"0x0\"\n"
"    ATTRS{authorized}==\"1\"\n"
"    ATTRS{ltm_capable}==\"no\"\n"
"    ATTRS{speed}==\"480\"\n"
"    ATTRS{product}==\"TF10\"\n"
"    ATTRS{manufacturer}==\"TDK LoR\"\n"
"[...]\n"
"    ATTRS{serial}==\"07032998B60AB777\"\n"
"[...]\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{hidden}==\"0\"\n"
"    ATTR{events}==\"media_change\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{discard_alignment}==\"0\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{events_async}==\"\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"51\"\n"
"    ATTR{events_poll_msecs}==\"-1\"\n"
"    ATTR{stat}==\"     130        0     6328      435        0        0        0        0        0      252      252        0        0        0        0\"\n"
"    ATTR{size}==\"15100224\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{inflight}==\"       0        0\"\n"
"[...]\n"
"\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0':\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1':\n"
"    KERNELS==\"2-1\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{bDeviceProtocol}==\"00\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{busnum}==\"2\"\n"
"    ATTRS{quirks}==\"0x0\"\n"
"    ATTRS{authorized}==\"1\"\n"
"    ATTRS{ltm_capable}==\"no\"\n"
"    ATTRS{speed}==\"480\"\n"
"    ATTRS{product}==\"TF10\"\n"
"    ATTRS{manufacturer}==\"TDK LoR\"\n"
"[...]\n"
"    ATTRS{serial}==\"07032998B60AB777\"\n"
"[...]\n"
"</computeroutput>"

msgid "To create a new rule, you can use tests on the device's variables, as well as those of one of the parent devices. The above case allows us to create two rules like these:"
msgstr "Untuk membuat aturan baru, Anda dapat menggunakan tes pada variabel perangkat, maupun dari salah satu perangkat induk. Kasus di atas memungkinkan kita untuk membuat dua aturan seperti ini:"

msgid ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/part%n\""
msgstr ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/part%n\""

msgid "Once these rules are set in a file, named for example <filename>/etc/udev/rules.d/010_local.rules</filename>, you can simply remove and reconnect the USB key. You can then see that <filename>/dev/usb_key/disk</filename> represents the disk associated with the USB key, and <filename>/dev/usb_key/part1</filename> is its first partition."
msgstr "Setelah aturan-aturan ini ditetapkan dalam berkas, bernama sebagai contoh <filename>/etc/udev/rules.d/010_local.rules</filename>, Anda dapat mencabut dan menancapkan kembali kunci USB. Anda dapat melihat bahwa <filename>/dev/usb_key/disk</filename> mewakili disk terkait kunci USB, dan <filename>/dev/usb_key/part1</filename> adalah partisi pertamanya."

msgid "<emphasis>GOING FURTHER</emphasis> Debugging <emphasis>udev</emphasis>'s configuration"
msgstr "<emphasis>LEBIH LANJUT</emphasis> Men-debug konfigurasi <emphasis>udev</emphasis>"

msgid "Like many daemons, <command>udevd</command> stores logs in <filename>/var/log/daemon.log</filename>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <command>udevadm control --log-priority=info</command> command increases the verbosity level and solves this problem. <command>udevadm control --log-priority=err</command> returns to the default verbosity level."
msgstr "Seperti banyak daemon, <command>udevd</command> menyimpan log dalam <filename>/var/log/daemon.log</filename>. Tetapi hal ini tidak sangat rinci secara default, dan biasanya tidak cukup untuk memahami apa yang terjadi. Perintah <command>udevadm control --log-priority=info</command> meningkatkan tingkat rincian dan memecahkan masalah ini. <command>udevadm control --log-priority=err</command> mengembalikan ke level rincian standar."

msgid "Power Management: Advanced Configuration and Power Interface (ACPI)"
msgstr "Manajemen Daya: Advanced Configuration and Power Interface (ACPI)"

msgid "<primary>power management</primary>"
msgstr "<primary>manajemen daya</primary>"

msgid "<primary>management, power management</primary>"
msgstr "<primary>manajemen, manajemen daya</primary>"

msgid "The topic of power management is often problematic. Indeed, properly suspending the computer requires that all the computer's device drivers know how to put them to standby, and that they properly reconfigure the devices upon waking. Unfortunately, there are still a few devices unable to sleep well under Linux, because their manufacturers have not provided the required specifications."
msgstr "Topik manajemen daya ini sering bermasalah. Memang, mensuspensi komputer secara benar mensyaratkan bahwa semua driver perangkat komputer tahu bagaimana untuk menempatkan mereka ke standby, dan bahwa mereka secara benar mengkonfigurasi perangkat saat bangun. Sayangnya, masih ada beberapa perangkat yang tidak dapat tidur dengan baik di bawah Linux, karena produsen mereka belum memberikan spesifikasi yang dibutuhkan."

msgid "Linux supports ACPI (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role=\"pkg\">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response."
msgstr "Linux mendukung ACPI ((Advanced Configuration and Power Interface) — standar terkini dalam manajemen daya. Paket <emphasis role=\"pkg\">acpid</emphasis> menyediakan daemon yang mencari kejadian-kejadian yang terkait manajemen daya (berpindah antara daya AC dan baterai pada laptop, dll) dan bisa menjalankan berbagai perintah sebagai respon."

msgid "<primary>ACPI</primary>"
msgstr "<primary>ACPI</primary>"

msgid "<primary>Advanced Configuration and Power Interface</primary>"
msgstr "<primary>Advanced Configuration and Power Interface</primary>"

msgid "<primary><command>acpid</command></primary>"
msgstr "<primary><command>acpid</command></primary>"

msgid "<emphasis>BEWARE</emphasis> Graphics card and standby"
msgstr "<emphasis>HATI-HATI</emphasis> Kartu grafis dan standby"

msgid "The graphics card driver is often the culprit when standby doesn't work properly. In that case, it is a good idea to test the latest version of the X.org graphics server."
msgstr "Driver kartu grafis sering adalah biang keladi ketika standby tidak bekerja dengan benar. Dalam hal ini, ide baik untuk menguji versi terbaru dari server grafis X.org."

msgid "After this overview of basic services common to many Unix systems, we will focus on the environment of the administered machines: the network. Many services are required for the network to work properly. They will be discussed in the next chapter."
msgstr "Setelah ikhtisar layanan dasar umum untuk banyak sistem Unix ini, kita akan fokus pada lingkungan mesin yang dikelola: jaringan. Banyak layanan yang diperlukan agar jaringan bekerja dengan baik. Mereka akan dibahas dalam bab berikutnya."

#~ msgid "<emphasis>IN PRACTICE</emphasis> Network card management"
#~ msgstr "<emphasis>DALAM PRAKTEK</emphasis> Manajemen kartu jaringan"

#~ msgid "Many computers have multiple network cards (sometimes two wired interfaces and a wifi interface), and with <emphasis>hotplug</emphasis> support on most bus types, the Linux kernel does not guarantee fixed naming of network interfaces. But users who want to configure their network in <filename>/etc/network/interfaces</filename> need a fixed name!"
#~ msgstr "Banyak komputer yang memiliki beberapa kartu jaringan (kadang-kadang dua antarmuka kabel dan antarmuka wifi), dan dengan dukungan <emphasis>hotplug</emphasis> pada kebanyakan jenis bus, kernel Linux tidak menjamin penamaan tetap atas antarmuka jaringan. Tapi pengguna yang ingin mengkonfigurasi jaringan mereka di <filename>/etc/network/interfaces</filename> memerlukan nama tetap!"

#~ msgid "It would be difficult to ask every user to create their own <emphasis>udev</emphasis> rules to address this problem. This is why <emphasis>udev</emphasis> was configured in a rather peculiar manner; on first boot (and, more generally, each time that a new network card appears) it uses the name of the network interface and its MAC address to create new rules that will reassign the same name on subsequent boots. These rules are stored in <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>."
#~ msgstr "Akan sulit untuk meminta setiap pengguna agar membuat aturan <emphasis>udev</emphasis> mereka sendiri untuk mengatasi masalah ini. Inilah sebabnya mengapa <emphasis>udev</emphasis> dikonfigurasi dengan cara yang agak aneh; pada boot pertama (dan, secara lebih umum, setiap kali suatu kartu jaringan baru muncul) menggunakan nama antarmuka jaringan dan alamat MAC nya untuk membuat aturan baru yang akan menetapkan kembali dengan nama yang sama pada boot-boot berikutnya. Aturan-aturan ini disimpan dalam <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>."

#~ msgid "This mechanism has some side effects that you should know about. Let's consider the case of a computer that has only one PCI network card. The network interface is named <literal>eth0</literal>, logically. Now say the card breaks down, and the administrator replaces it; the new card will have a new MAC address. Since the old card was assigned the name, <literal>eth0</literal>, the new one will be assigned <literal>eth1</literal>, even though the <literal>eth0</literal> card is gone for good (and the network will not be functional because <filename>/etc/network/interfaces</filename> likely configures an <literal>eth0</literal> interface). In this case, it is enough to simply delete the <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> file before rebooting the computer. The new card will then be given the expected <literal>eth0</literal> name."
#~ msgstr "Mekanisme ini memiliki beberapa efek samping yang harus Anda ketahui. Mari kita mempertimbangkan kasus komputer yang memiliki kartu jaringan PCI hanya satu. Antarmuka jaringan secara logis dinamai <literal>eth0</literal>. Sekarang katakanlah kartu rusak, dan administrator menggantikan itu; kartu baru akan memiliki alamat MAC baru. Karena kartu lama diberi nama <literal>eth0</literal>, yang baru akan diberi <literal>eth1</literal>, meskipun kartu <literal>eth0</literal> pergi untuk selamanya (dan jaringan tidak akan berfungsi karena <filename>/etc/network/interfaces</filename> kemungkinan mengkonfigurasi antarmuka <literal>eth0</literal>). Dalam kasus ini, itu sudah cukup untuk hanya menghapus berkas <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> sebelum reboot komputer. Kartu baru akan kemudian diberi nama <literal>eth0</literal> yang diharapkan."
