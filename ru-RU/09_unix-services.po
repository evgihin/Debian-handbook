# Dmitry Mikhirev <mikhirev@gmail.com>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2022-09-27 17:55+0200\n"
"PO-Revision-Date: 2018-09-27 15:34+0000\n"
"Last-Translator: Viktor S <awsswa59@gmail.com>\n"
"Language-Team: Russian <https://hosted.weblate.org/projects/debian-handbook/09_unix-services/ru/>\n"
"Language: ru-RU\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
"X-Generator: Weblate 3.2-dev\n"

msgid "System boot"
msgstr "Загрузка системы"

msgid "Initscripts"
msgstr "Сценарии инициализации"

msgid "SSH"
msgstr "SSH"

msgid "Telnet"
msgstr "Telnet"

msgid "Rights"
msgstr "Права"

msgid "Permissions"
msgstr "Привилегии"

msgid "Supervision"
msgstr "Инспектирование"

msgid "Inetd"
msgstr "Inetd"

msgid "Cron"
msgstr "Cron"

msgid "Backup"
msgstr "Резервное копирование"

msgid "Hotplug"
msgstr "Горячее подключение"

msgid "PCMCIA"
msgstr "PCMCIA"

msgid "APM"
msgstr "APM"

msgid "ACPI"
msgstr "ACPI"

msgid "Unix Services"
msgstr "Сервисы Unix"

msgid "This chapter covers a number of basic services that are common to many Unix systems. All administrators should be familiar with them."
msgstr "Эта глава посвящена нескольким основным сервисам, общим для многих Unix-систем. Все администраторы должны быть хорошо знакомы с ними."

msgid "System Boot"
msgstr "Загрузка системы"

msgid "<primary>booting</primary><secondary>the system</secondary>"
msgstr "<primary>загрузка</primary><secondary>системы</secondary>"

#, fuzzy
#| msgid "<primary>SSH</primary>"
msgid "<primary>BIOS</primary>"
msgstr "<primary>SSH</primary>"

#, fuzzy
#| msgid "<primary>TAR</primary>"
msgid "<primary>MBR</primary>"
msgstr "<primary>TAR</primary>"

#, fuzzy
#| msgid "<primary>SSH</primary>"
msgid "<primary>ESP</primary>"
msgstr "<primary>SSH</primary>"

#, fuzzy
#| msgid "<primary>tunnel (SSH)</primary><seealso>VPN</seealso>"
msgid "<primary>Compatibility Support Mode</primary><see>CSM</see>"
msgstr "<primary>туннель (SSH)</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>SSH</primary>"
msgid "<primary>CSM</primary>"
msgstr "<primary>SSH</primary>"

msgid "When you boot the computer, the many messages scrolling by on the console display many automatic initializations and configurations that are being executed. Sometimes you may wish to slightly alter how this stage works, which means that you need to understand it well. That is the purpose of this section."
msgstr "При загрузке компьютера множество сообщений, пробегающих на консоли, отображает выполнение многочисленных автоматических начальных инициализаций и настроек. Иногда может возникнуть желание несколько изменить работу этого этапа, а значит, необходимо хорошо её понимать. Помочь в этом — назначение данного раздела."

msgid "On systems with a BIOS, first, the BIOS takes control of the computer, initializes the controllers and hardware, detects the disks, and bridges everything together. Then it looks up the <emphasis>Master Boot Record</emphasis> (MBR) of the first disk in the boot order and loads the code stored there (first stage). This code then launches the second stage and finally executes the bootloader."
msgstr ""

msgid "In contrast to the BIOS, UEFI is more sophisticated, it knows filesystems and can read the partition tables. The interface searches the system storage for a partition labeled with a specific globally unique identifier (<acronym>GUID</acronym>) that marks it as the <acronym>EFI System Partition</acronym> (<acronym>ESP</acronym>), where the bootloaders, boot managers, UEFI shell, etc., are located, and launches the desired bootloader. If Secure Boot is enabled, the boot process will verify authenticity of the EFI binaries there by signature (thus <emphasis role=\"pkg\">grub-efi-<replaceable>arch</replaceable>-signed</emphasis> is required in this case). The UEFI specification also defines support for booting in legacy BIOS mode. This is called the <emphasis>Compatibility Support Module</emphasis> (<acronym>CSM</acronym>). If CSM is enabled, it will attempt to boot from a drive's MBR. However, many new systems do no longer support the CSM mode."
msgstr ""

#, fuzzy
#| msgid "First, the BIOS takes control of the computer, detects the disks, loads the <emphasis>Master Boot Record</emphasis>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <command>init</command>. Frequently, this “root partition” and this <command>init</command> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process."
msgid "In both cases then the actual bootloader takes over, finds either a chained bootloader or the kernel on the disk, loads, and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <command>init</command>. Frequently, this “root partition” and this <command>init</command> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process."
msgstr "Сначала BIOS получает контроль над компьютером, определяет диски, считывает <emphasis>главную загрузочную запись</emphasis> и запускает загрузчик. Загрузчик принимает управление, находит ядро на диске, считывает и запускает его. Затем ядро инициализируется и начинает поиск и монтирование корневой файловой системы и, наконец, запускает первую программу — <command>init</command>. Зачастую эти «корневой раздел» и <command>init</command> на самом деле находятся на виртуальной файловой системе, существующей только в ОЗУ (отсюда её название — initramfs, ранее — initrd, от \"initialization RAM disk\"). Эта файловая система загружается в память загрузчиком, часто из файла на жёстком диске или по сети. Он содержит самый минимум, необходимый для того, чтобы ядро загрузило «настоящую» корневую файловую систему: сюда могут входить модуля ядра для жёсткого диска или других устройств, без которых система не способна загрузиться, или, чаще, сценарии инициализации и модули для сборки массивов RAID, открытия зашифрованных разделов, активации томов LVM и т. п. Когда корневой раздел примонтирован, initramfs передаёт управление настоящему процессу \"init\", и система возвращается к стандартному процессу загрузки."

msgid "The systemd init system"
msgstr "Система инициализации systemd"

#, fuzzy
#| msgid "<primary>booting</primary><secondary>the system</secondary>"
msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">systemd</emphasis></secondary>"
msgstr "<primary>загрузка</primary><secondary>системы</secondary>"

msgid "The “real init” is currently provided by <emphasis role=\"pkg\">systemd</emphasis> and this section documents this init system."
msgstr "«Настоящий init» сейчас предоставляется <emphasis role=\"pkg\">systemd</emphasis>, и в данном разделе описывается эта система инициализации."

msgid "<emphasis>CULTURE</emphasis> Before <command>systemd</command>"
msgstr "<emphasis>КУЛЬТУРА</emphasis> До <command>systemd</command>"

msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">sysv-rc</emphasis></secondary><seealso>System V init</seealso>"
msgstr ""

#, fuzzy
#| msgid "<primary>sticky bit</primary>"
msgid "<primary>System V init</primary>"
msgstr "<primary>sticky bit</primary>"

msgid "<command>systemd</command> is a relatively recent “init system”, and although it was already available, to a certain extent, in <emphasis role=\"distribution\">Wheezy</emphasis>, it has only become the default in Debian <emphasis role=\"distribution\">Jessie</emphasis>. Previous releases relied, by default, on the “System V init” (in the <emphasis role=\"pkg\">sysv-rc</emphasis> package), a much more traditional system. We describe the System V init later on."
msgstr "<command>systemd</command> является относительно новой «системой инициализации», но несмотря на это, она уже была доступна в <emphasis role=\"distribution\">Wheezy</emphasis>. По умолчанию, она стала применяться в Debian <emphasis role=\"distribution\">Jessie</emphasis>. До этого, по умолчанию использовалась «System V init» (пакет <emphasis role=\"pkg\">sysv-rc</emphasis>) — гораздо более традиционная система. System V init будет описана позднее."

msgid "<emphasis>ALTERNATIVE</emphasis> Other boot systems"
msgstr "<emphasis>АЛЬТЕРНАТИВА</emphasis> Другие системы загрузки"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>boot systems</primary><seealso><command>init</command></seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "This book describes the boot system used by default in Debian <emphasis role=\"distribution\">Jessie</emphasis> (as implemented by the <emphasis role=\"pkg\">systemd</emphasis> package), as well as the previous default, <emphasis role=\"pkg\">sysvinit</emphasis>, which is derived and inherited from <emphasis>System V</emphasis> Unix systems; there are others."
msgid "This book describes the boot system used by default in Debian since <emphasis role=\"distribution\">Buster</emphasis> (as implemented by the <emphasis role=\"pkg\">systemd</emphasis> package), as well as the previous default, <emphasis role=\"pkg\">sysvinit</emphasis>, which is derived and inherited from <emphasis>System V</emphasis> Unix systems; there are others."
msgstr "Эта книга дает описание загрузки системы: использующейся по умолчанию в Debian <emphasis role=\"distribution\">Jessie</emphasis> (пакет <emphasis role=\"pkg\">systemd</emphasis>), предыдущей — <emphasis role=\"pkg\">sysvinit</emphasis>, которая является продолжателем и наследником <emphasis>System V</emphasis> из Unix-систем, также есть и другие."

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">upstart</emphasis></secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

#, fuzzy
#| msgid "The <command>upstart</command> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <emphasis role=\"distribution\">Jessie</emphasis>, but is not the default; it comes, in fact, as a replacement for <emphasis role=\"pkg\">sysvinit</emphasis>, and one of the tasks launched by <command>upstart</command> is to launch the scripts written for traditional systems, especially those from the <emphasis role=\"pkg\">sysv-rc</emphasis> package."
msgid "The <command>upstart</command> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, was present in Debian <emphasis role=\"distribution\">Jessie</emphasis>, but was not the default; it came, in fact, as a replacement for <emphasis role=\"pkg\">sysvinit</emphasis>, and one of the tasks launched by <command>upstart</command> was to launch the scripts written for traditional systems, especially those from the <emphasis role=\"pkg\">sysv-rc</emphasis> package."
msgstr "Система <command>upstart</command> пока не так хорошо тестировалась в Debian. Она основана на событиях: init-сценарии запускаются не поочерёдно, а отвечают на события, например на завершение другого сценария, от которого данный зависит. Эта система появилась в Ubuntu и может быть выбрана в Debian <emphasis role=\"distribution\">Jessie</emphasis> как замена системы по умолчанию. Таковой она и разрабатывалась на место <emphasis role=\"pkg\">sysvinit</emphasis> и одной из задач <command>upstart</command> был запуск сценариев, написанных для традиционных систем, особенно для <emphasis role=\"pkg\">sysv-rc</emphasis>."

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary><command>init</command></primary><secondary><emphasis role=\"pkg\">openrc</emphasis></secondary>"
msgstr "<primary>вход</primary><secondary>удалённый вход</secondary>"

msgid "<command>openrc</command> is a dependency based service manager. It was originally written for the Gentoo project, but it aims at being platform agnostic. It maintains compatibility with the System V init system and provides support for booting, changing runlevels, starting and stopping services (in parallel), and shutting down."
msgstr ""

#, fuzzy
#| msgid "There are also other systems and other operating modes, such as <command>runit</command> or <command>minit</command>, but they are relatively specialized and not widespread."
msgid "There are also other systems and other operating modes, such as <command>file-rc</command>, <command>runit</command>, or <command>minit</command>, but some of them are relatively specialized and not widespread."
msgstr "Есть и другие системы и другие режимы работы, такие как <command>runit</command> или <command>minit</command>, они не распространены и достаточно специализированы."

msgid "Boot sequence of a computer running Linux with systemd"
msgstr "Порядок загрузки компьютера с Linux и systemd"

msgid "<emphasis>SPECIFIC CASE</emphasis> Booting from the network"
msgstr "<emphasis>ОСОБЫЙ СЛУЧАЙ</emphasis> Загрузка по сети"

#, fuzzy
#| msgid "In some configurations, the BIOS may be configured not to execute the MBR, but to seek its equivalent on the network, making it possible to build computers without a hard drive, or which are completely reinstalled on each boot. This option is not available on all hardware and it generally requires an appropriate combination of BIOS and network card."
msgid "In some configurations, the system may be configured not to execute code from the physical hardware, but to seek its equivalent on the network, making it possible to build computers without a hard drive, or which are completely reinstalled on each boot. This option is not available on all hardware and it generally requires an appropriate combination of firmware and network card."
msgstr "В некоторых конфигурациях BIOS может быть настроен не на загрузку MBR, а на поиск её эквивалента в сети, что делает возможным собирать компьютеры без жёсткого диска или полностью переустанавливаемые при каждой загрузке. Такая опция есть не у любого оборудования, и для неё обычно необходимо определённое сочетание BIOS и сетевой карты."

msgid "Booting from the network can be used to launch the <command>debian-installer</command> or FAI (see <xref linkend=\"sect.installation-methods\" />)."
msgstr "Загрузка по сети может использоваться для запуска <command>debian-installer</command> или FAI (см. <xref linkend=\"sect.installation-methods\" />)."

msgid "<emphasis>BACK TO BASICS</emphasis> The process, a program instance"
msgstr "<emphasis>К ОСНОВАМ</emphasis> Процесс — экземпляр программы"

msgid "<primary>process</primary>"
msgstr "<primary>процесс</primary>"

#, fuzzy
#| msgid "A process is the representation in memory of a running program. It includes all of the information necessary for the proper execution of the software (the code itself, but also the data that it has in memory, the list of files that it has opened, the network connections it has established, etc.). A single program may be instantiated into several processes, not necessarily running under different user IDs."
msgid "A process is the representation of a running program in memory. It includes all of the information necessary for the proper execution of the software (the code itself, but also the data that it has in memory, the list of files that it has opened, the network connections it has established, etc.). A single program may be instantiated into several processes, not necessarily running under different user IDs."
msgstr "Процесс является отображением запущенной программы в памяти. Он содержит всю информацию, необходимую для корректной работы программы (сам код, а также данные, хранимые ей в памяти, список открытых ей файлов, установленных ей сетевых соединений и т. п.). Одна программа может быть представлена несколькими процессами, необязательно запущенными от имени разных пользователей."

msgid "<emphasis>SECURITY</emphasis> Using a shell as <command>init</command> to gain root rights"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> Использование командной оболочки в качестве <command>init</command> для получения привилегий root"

msgid "By convention, the first process that is booted is the <command>init</command> program (which is a symbolic link to <filename>/lib/systemd/systemd</filename> by default). However, it is possible to pass an <literal>init</literal> option to the kernel indicating a different program."
msgstr "Принято, что первым процессом при загрузке является <command>init</command> (по умолчанию символьная ссылка на <filename>/lib/systemd/systemd</filename>). Возможно передать ядру другие параметры для <literal>init</literal>."

msgid "<primary><command>init</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "Any person who is able to access the computer can press the <keycap>Reset</keycap> button, and thus reboot it. Then, at the bootloader's prompt, it is possible to pass the <literal>init=/bin/sh</literal> option to the kernel to gain root access without knowing the administrator's password."
msgstr "Любой человек, способный получить доступ к компьютеру, может нажать кнопку <keycap>Reset</keycap> и перезагрузить его. Потом, в приглашении загрузчика, можно передать ядру опцию <literal>init=/bin/sh</literal>, чтобы получить доступ root, не зная пароля администратора."

msgid "To prevent this, you can protect the bootloader itself with a password. You might also think about protecting access to the BIOS (a password protection mechanism is almost always available), without which a malicious intruder could still boot the machine on a removable media containing its own Linux system, which they could then use to access data on the computer's hard drives."
msgstr "Чтобы предотвратить это, можно защитить паролем сам загрузчик. Следует также задуматься о защите доступа к BIOS (механизм защиты паролем почти всегда доступен), без которой злоумышленник всё равно сможет загрузить машину с переносного накопителя c собственной системой Linux, которую он сможет использовать для доступа к данным на жёстком диске компьютера."

#, fuzzy
#| msgid "Finally, be aware that most BIOS have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…"
msgid "Finally, be aware that most BIOS/EFI implementations have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…"
msgstr "Наконец, нужно знать, что в большинстве BIOS есть пароль, предназначенный для исправления неполадок и для тех, кто забыл установленный пароль. Сейчас, такие пароли находятся в свободном доступе в интернете (попробуйте найти для своего BIOS, набрав «generic BIOS passwords» в поисковике). Следует понимать, что не существует надёжного способа защитить компьютер от проникновения, если злоумышленник имеет к нему прямой способ. Например, он может просто забрать жёсткий диск, или целый компьютер, или стереть память BIOS для сброса пароля…"

#, fuzzy
#| msgid "Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> pairs grouped between <literal>[<replaceable>section</replaceable>]</literal> headers. Unit files are stored under <filename>/lib/systemd/system/</filename> and <filename>/etc/systemd/system/</filename>; they come in several flavours, but we will focus on “services” and “targets” here."
msgid "Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> pairs grouped between <literal>[<replaceable>section</replaceable>]</literal> headers. Unit files are stored under <filename>/lib/systemd/system/</filename> and <filename>/etc/systemd/system/</filename>; they come in several flavors, but we will focus on “services” and “targets” here."
msgstr "Systemd запускает несколько процессов для настройки клавиатуры, драйверов, файловых систем, сети, служб. Также соблюдаются требования для всех компонентов системы, каждый из которых описан в «файле элемента» — unit (иногда требуется более одного файла). Синтаксис заимствован из «*.ini файлов» с парами «ключ = значение» — <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal>, разделёнными заголовками <literal>[<replaceable>section</replaceable>]</literal>. Unit-файлы хранятся в каталогах <filename>/lib/systemd/system/</filename> и <filename>/etc/systemd/system/</filename>. Далее будут описаны типы unit «сервис» — service и «цель» — target."

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.service</filename> file</secondary>"
msgstr "<primary>менеджер</primary><secondary>дисплея</secondary>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/systemd/system/</filename></secondary><see><command>systemd</command></see>"
msgstr ""

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>service</primary><secondary><filename>ssh.service</filename></secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

#, fuzzy
#| msgid "A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:"
msgid "A systemd “<filename>.service</filename> file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:"
msgstr "Файл service описывает процесс systemd.  Он содержит ту же информацию, что и прежние init-сценарии, но она описана в декларативном (и сжатом) стиле. Systemd обслуживает повторяющиеся задачи (старт и остановка процесса, проверка его статуса, журнал, привилегии и т . п.) и файл service должен быть наполнен конкретикой, относящейся к процессу. Например для SSH, он выглядит так:"

#, fuzzy
#| msgid ""
#| "[Unit]\n"
#| "Description=OpenBSD Secure Shell server\n"
#| "After=network.target auditd.service\n"
#| "ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
#| "\n"
#| "[Service]\n"
#| "EnvironmentFile=-/etc/default/ssh\n"
#| "ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
#| "ExecReload=/bin/kill -HUP $MAINPID\n"
#| "KillMode=process\n"
#| "Restart=on-failure\n"
#| "\n"
#| "[Install]\n"
#| "WantedBy=multi-user.target\n"
#| "Alias=sshd.service"
msgid ""
"[Unit]\n"
"Description=OpenBSD Secure Shell server\n"
"Documentation=man:sshd(8) man:sshd_config(5)\n"
"After=network.target auditd.service\n"
"ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
"\n"
"[Service]\n"
"EnvironmentFile=-/etc/default/ssh\n"
"ExecStartPre=/usr/sbin/sshd -t\n"
"ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
"ExecReload=/usr/sbin/sshd -t\n"
"ExecReload=/bin/kill -HUP $MAINPID\n"
"KillMode=process\n"
"Restart=on-failure\n"
"RestartPreventExitStatus=255\n"
"Type=notify\n"
"RuntimeDirectory=sshd\n"
"RuntimeDirectoryMode=0755\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target\n"
"Alias=sshd.service"
msgstr ""
"[Unit]\n"
"Description=OpenBSD Secure Shell server\n"
"After=network.target auditd.service\n"
"ConditionPathExists=!/etc/ssh/sshd_not_to_be_run\n"
"\n"
"[Service]\n"
"EnvironmentFile=-/etc/default/ssh\n"
"ExecStart=/usr/sbin/sshd -D $SSHD_OPTS\n"
"ExecReload=/bin/kill -HUP $MAINPID\n"
"KillMode=process\n"
"Restart=on-failure\n"
"\n"
"[Install]\n"
"WantedBy=multi-user.target\n"
"Alias=sshd.service"

msgid "The <literal>[Unit]</literal> section contains generic information about the service, like its description and manual page resources, as well as relations (dependency and order) to other services. The <literal>[Service]</literal> part contains the declarations related to the service execution (starting, stopping, killing, restarting), directories and configuration file(s) used. The last section, <literal>[Install]</literal>, again carries generic information into which targets to install the service and, in this case, the alias that can be used instead of the service name. As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed. The syntax of these files is fully described in several manual pages (e.g. <citerefentry><refentrytitle>systemd.service</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>systemd.unit</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>systemd.exec</refentrytitle> <manvolnum>5</manvolnum></citerefentry>, etc.)."
msgstr ""

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.target</filename> file</secondary>"
msgstr "<primary>менеджер</primary><secondary>дисплея</secondary>"

#, fuzzy
#| msgid "A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <literal>local-fs.target</literal>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <literal>network-online.target</literal> and <literal>sound.target</literal>. The dependencies of a target can be listed either within the target file (in the <literal>Requires=</literal> line), or using a symbolic link to a service file in the <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> directory. For instance, <filename>/etc/systemd/system/printer.target.wants/</filename> contains a link to <filename>/lib/systemd/system/cups.service</filename>; systemd will therefore ensure CUPS is running in order to reach <literal>printer.target</literal>."
msgid "A systemd “<filename>.target</filename> file” describes a state of the system where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the pre-defined targets is <literal>local-fs.target</literal>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <literal>network-online.target</literal> and <literal>sound.target</literal> (for a full list of special targets see <citerefentry><refentrytitle>systemd.special</refentrytitle> <manvolnum>7</manvolnum></citerefentry>). The dependencies of a target can be listed either within the target file (in the <literal>Requires=</literal> line), or using a symbolic link to a service file in the <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> directory. For instance, <filename>/etc/systemd/system/printer.target.wants/</filename> contains a link to <filename>/lib/systemd/system/cups.service</filename>; systemd will therefore ensure CUPS is running in order to reach <literal>printer.target</literal>."
msgstr "Файл «цели» в systemd описывает состояние системы, когда функционирует некоторый набор сервисов. Его можно рассматривать как эквивалент уровня запуска. Одна из целей — <literal>local-fs.target</literal>; при её достижении остальная система может рассчитывать, что все локальные файловые системы смонтированы и доступны. В число других целей входят <literal>network-online.target</literal> и <literal>sound.target</literal>. Зависимости цели могут быть указаны как внутри файла target (в строке <literal>Requires=</literal>), так и с использованием символьной ссылки на файл service в каталоге <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal>. Например <filename>/etc/systemd/system/printer.target.wants/</filename> cодержит ссылку на <filename>/lib/systemd/system/cups.service</filename>, поэтому systemd запустит CUPS для достижения цели <literal>printer.target</literal>."

msgid "Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component."
msgstr "Так как файлы unit декларативны, в отличие от сценарием и программ, они не могут запускаться отдельно и интерпретируются только systemd, хотя несмотря на это, несколько вспомогательных программ позволяют администратору взаимодействовать с systemd, контролировать состояние системы и отдельных компонентов."

msgid "<primary><command>systemd</command></primary><secondary><command>systemctl</command></secondary><see><command>systemctl</command></see>"
msgstr ""

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>status</literal></secondary>"
msgstr "<primary>владелец</primary><secondary>пользователь</secondary>"

msgid "The first such utility is <command>systemctl</command>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <command>systemctl status</command> gives a better view of the services, as well as the related processes. If given the name of a service (as in <command>systemctl status ntp.service</command>), it returns even more details, as well as the last few log lines related to the service (more on that later)."
msgstr "Первая из них — <command>systemctl</command>. При запуске без параметров, выводится список всех unit-файлов, известных системе (за исключением отключенных) и их статус. <command>systemctl status</command> дает лучший обзор сервисов и связанных процессов. Выводится имя файла service (как в <command>systemctl status ntp.service</command>), также дополнительная информация и последние несколько строчек из журнала, касающиеся этого процесса (позднее про это будет сказано более подробно)."

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>start</literal></secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>stop</literal></secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

#, fuzzy
#| msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>reload</literal></secondary>"
msgstr "<primary>модули</primary><secondary>ядра</secondary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>restart</literal></secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

msgid "Starting a service by hand is a simple matter of running <command>systemctl start <replaceable>servicename</replaceable>.service</command>. As one can guess, stopping the service is done with <command>systemctl stop <replaceable>servicename</replaceable>.service</command>; other subcommands include <command>reload</command> and <command>restart</command>."
msgstr "Для запуска сервиса вручную, нужно просто набрать <command>systemctl start <replaceable>servicename</replaceable>.service</command>. Как можно догадаться, для остановки: <command>systemctl stop <replaceable>servicename</replaceable>.service</command>. Есть другие подкоманды: <command>reload</command> и <command>restart</command>."

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>enable</literal></secondary>"
msgstr "<primary>клиент</primary><secondary>клиент-серверная архитектура</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>disable</literal></secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><command>systemctl</command></primary><secondary><literal>is-enabled</literal></secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

msgid "To control whether a service is active (i.e. whether it will get started automatically on boot), use <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (or <command>disable</command>). <command>is-enabled</command> allows checking the status of the service."
msgstr "Для контроля за активность сервиса (запускается при загрузки системы или нет), нужно использовать <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (или <command>disable</command>). Для проверки запущен ли сервис — <command>is-enabled</command>."

msgid "<primary><command>systemd</command></primary><secondary><command>journald</command></secondary><see><command>journald</command></see>"
msgstr ""

msgid "<primary><command>systemd</command></primary><secondary><command>journalctl</command></secondary><see><command>journalctl</command></see>"
msgstr ""

#, fuzzy
#| msgid "<primary><command>atd</command></primary>"
msgid "<primary><command>journald</command></primary>"
msgstr "<primary><command>atd</command></primary>"

#, fuzzy
#| msgid "<primary><command>rsyslogd</command></primary>"
msgid "<primary><command>syslogd</command></primary>"
msgstr "<primary><command>rsyslogd</command></primary>"

#, fuzzy
#| msgid "<primary><command>at</command></primary>"
msgid "<primary><command>journalctl</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "An interesting feature of systemd is that it includes a logging component named <command>journald</command>. It comes as a complement to more traditional logging systems such as <command>syslogd</command>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <command>journalctl</command> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:"
msgid "An interesting feature of systemd is that it includes a logging component named <command>journald</command>. It comes as a complement to more traditional logging systems such as <command>syslogd</command>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialization sequence. The messages can be displayed later on, with a little help from the <command>journalctl</command> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:"
msgstr "Интересная особенность systemd состоит в журнале <command>journald</command>. Он идет как дополнение к традиционному <command>syslogd</command>, но содержит особенности, как например формальная ссылка между сервисом и сообщением, им создаваемом при процедуре инициализации. Сообщения можно посмотреть с помощью <command>journalctl</command>. Без аргументов, выводится журнал сообщений, создаваемый при загрузке системы, однако в большинстве случаев команда используется с идентификатором сервиса:"

msgid ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2\n"
"Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"</computeroutput>"

msgid "Another useful command-line flag is <command>-f</command>, which instructs <command>journalctl</command> to keep displaying new messages as they are emitted (much in the manner of <command>tail -f <replaceable>file</replaceable></command>)."
msgstr "Другой полезный флаг <command>-f</command> используется с <command>journalctl</command> для просмотра появления новых сообщений (похоже на <command>tail -f <replaceable>file</replaceable></command>)."

msgid "If a service doesn't seem to be working as expected, the first step to solve the problem is to check that the service is actually running with <command>systemctl status</command>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:"
msgstr "Если сервис не работает как ожидалось, то первым делом нужно проверить его статус с <command>systemctl status</command>, если проблема не решена, то проверьте его журнал. Допустим сервер SSH не работает:"

msgid ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
"  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)\n"
" Main PID: 1188 (code=exited, status=255)\n"
"\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>journalctl -u ssh.service\n"
"</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.\n"
"Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2\n"
"Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)\n"
"Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option \"yess\".\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.\n"
"Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.\n"
"# </computeroutput><userinput>vi /etc/ssh/sshd_config\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service\n"
"</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service\n"
"</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server\n"
"   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)\n"
"   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago\n"
"  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)\n"
" Main PID: 1222 (sshd)\n"
"   CGroup: /system.slice/ssh.service\n"
"           └─1222 /usr/sbin/sshd -D\n"
"# </computeroutput>"

msgid "After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running."
msgstr "После проверки статуса (ошибка), был проверен журнал, была обнаружена ошибка в конфигурационном файле. После его редактирования и исправления ошибки, сервис запускается заново, далее проверяется его статус."

msgid "<emphasis>GOING FURTHER</emphasis> Other types of unit files"
msgstr "<emphasis>УГЛУБЛЯЕМСЯ</emphasis> Другие типы unit файла"

msgid "We have only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we will only list a few here:"
msgstr "Мы описали только базовые возможности systemd, но эта система предлагает много других интересных возможностей. Обозначим некоторые из них:"

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.socket</filename> file</secondary>"
msgstr "<primary>менеджер</primary><secondary>дисплея</secondary>"

#, fuzzy
#| msgid "socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <command>inetd</command>. See <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgid "socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <command>inetd</command>. See <citerefentry><refentrytitle>systemd.socket</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."
msgstr "активация сокета: «socket» unit файл используется для описания сети или Unix сокета. Это означает, что сокет создаётся systemd и текущий сервис может запускаться по запросу, если будет попытка  соединения. Тут копируется набор возможностей <command>inetd</command>. Читайте <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>."

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.timer</filename> file</secondary>"
msgstr "<primary>менеджер</primary><secondary>дисплея</secondary>"

#, fuzzy
#| msgid "timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <command>cron</command> features. See <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>."
msgid "timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <command>cron</command> features. See <citerefentry><refentrytitle>systemd.timer</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."
msgstr "таймеры: «timer» unit файл описывает события, возникающие с установленной частотой или в определённый момент времени. Если сервис ссылается на таймер, процесс будет запущен в установленное время. Тут копируется часть возможностей <command>cron</command>. Читайте <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>."

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>systemd</command></primary><secondary><filename>.network</filename> file</secondary>"
msgstr "<primary>менеджер</primary><secondary>дисплея</secondary>"

#, fuzzy
#| msgid "network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up."
msgid "network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up. See <citerefentry><refentrytitle>systemd.network</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."
msgstr "сеть: «network» unit файл описывает сетевой интерфейс и позволяет его настраивать, а также отражать зависимость сервиса от какого-либо интерфейса."

msgid "The System V init system"
msgstr "Система инициализации System V"

#, fuzzy
#| msgid "The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <filename>/etc/inittab</filename> file. The first program that is executed (which corresponds to the <emphasis>sysinit</emphasis> step) is <command>/etc/init.d/rcS</command>, a script that executes all of the programs in the <filename>/etc/rcS.d/</filename> directory. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>"
msgid "The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <filename>/etc/inittab</filename> file. The first program that is executed (which corresponds to the <emphasis>sysinit</emphasis> step) is <command>/etc/init.d/rcS</command>, a script that executes all of the programs in the <filename>/etc/rcS.d/</filename> directory."
msgstr "Система инициализации System V (которую называют init для краткости), используя инструкции из файла <filename>/etc/inittab</filename>, запускает несколько процессов. Первая команда (относящаяся к шагу <emphasis>sysvinit</emphasis>) — это сценарий <command>/etc/init.d/rcS</command>, который запускает все программы в каталоге <filename>/etc/rcS.d/</filename>. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/init.d/rcS</filename></secondary><seealso><emphasis role=\"pkg\">sysv-rc</emphasis></seealso>"
msgstr ""

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rcS.d/</filename></secondary><seealso><emphasis role=\"pkg\">sysv-rc</emphasis></seealso>"
msgstr ""

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>rcS</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>rcS.d</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

msgid "Among these, you will find successively programs in charge of:"
msgstr "Среди них можно найти последовательность программ, отвечающих за:"

msgid "configuring the console's keyboard;"
msgstr "настройку клавиатуры в консоли;"

msgid "loading drivers: most of the kernel modules are loaded by the kernel itself as the hardware is detected; extra drivers are then loaded automatically when the corresponding modules are listed in <filename>/etc/modules</filename>;"
msgstr "загрузку драйверов: большая часть модулей ядра загружается самим ядром при обнаружении оборудования; дополнительные драйверы затем загружаются автоматически, если соответствующие модули указаны в <filename>/etc/modules</filename>;"

#, fuzzy
#| msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modules</filename></secondary>"
msgstr "<primary>модули</primary><secondary>ядра</secondary>"

msgid "checking the integrity of filesystems;"
msgstr "проверку целостности файловых систем;"

msgid "mounting local partitions;"
msgstr "монтирование локальных разделов;"

msgid "configuring the network;"
msgstr "настройку сети;"

msgid "mounting network filesystems (NFS)."
msgstr "монтирование сетевых файловых систем (NFS)."

msgid "<emphasis>BACK TO BASICS</emphasis> Kernel modules and options"
msgstr "<emphasis>К ОСНОВАМ</emphasis> Опции модулей ядра"

msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgstr "<primary>модули</primary><secondary>ядра</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>kernel</primary><secondary>modules</secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "<primary>kernel</primary><secondary>modules</secondary><tertiary>load</tertiary><seealso><command>modprobe</command></seealso>"
msgstr ""

msgid "<primary>kernel</primary><secondary>modules</secondary><tertiary>options</tertiary><seealso><command>modinfo</command></seealso>"
msgstr ""

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modprobe.d</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

#, fuzzy
#| msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/modules-load.d/</filename></secondary>"
msgstr "<primary>модули</primary><secondary>ядра</secondary>"

#, fuzzy
#| msgid "Kernel modules also have options that can be configured by putting some files in <filename>/etc/modprobe.d/</filename>. These options are defined with directives like this: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. Several options can be specified with a single directive if necessary."
msgid "You have already learned that kernel modules can be loaded during the start of the system by adding them to <filename>/etc/modules</filename> or a file below <filename>/etc/modules-load.d/</filename>. But modules can also have options that can be configured by putting some files in <filename>/etc/modprobe.d/</filename>. These options are defined with directives like this: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. Several options can be specified with a single directive if necessary."
msgstr "У модулей ядра тоже есть опции, которые можно настроить, поместив некоторые файлы в <filename>/etc/modprobe.d/</filename>. Эти опции определяются с помощью таких директив: <literal>options <replaceable>имя-модуля</replaceable> <replaceable>имя-опции</replaceable>=<replaceable>значение-опции</replaceable></literal>. При необходимости в одной директиве можно указывать несколько опций."

#, fuzzy
#| msgid "These configuration files are intended for <command>modprobe</command> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). This program is provided by the <emphasis role=\"pkg\">kmod</emphasis> package."
msgid "These configuration files are intended for <command>modprobe</command> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). To list all options of a module use the <command>modinfo -p <replaceable>module</replaceable></command> command. Both programs are provided by the <emphasis role=\"pkg\">kmod</emphasis> package together with other tools to handle modules."
msgstr "Эти конфигурационные файлы предназначены для <command>modprobe</command> — программы, которая загружает модуль ядра вместе с его зависимостями (модули могут на самом деле вызывать другие модули). Эта программа предоставляется пакетом <emphasis role=\"pkg\">kmod</emphasis>."

msgid "<primary><command>modprobe</command></primary>"
msgstr "<primary><command>modprobe</command></primary>"

#, fuzzy
#| msgid "<primary><command>diff</command></primary>"
msgid "<primary><command>modinfo</command></primary>"
msgstr "<primary><command>diff</command></primary>"

msgid "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">kmod</emphasis></primary>"

msgid "Having learned about systemd, services and targets can use the <filename>modprobe@<replaceable>module</replaceable>.service</filename> to load kernel modules they depend on."
msgstr ""

#, fuzzy
#| msgid "<primary>server</primary><secondary>client/server architecture</secondary>"
msgid "<primary>service</primary><secondary><filename>modprobe@<replaceable>module</replaceable>.service</filename></secondary>"
msgstr "<primary>сервер</primary><secondary>клиент-серверная архитектура</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/init.d/rc</filename></secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rcX.d/</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

#, fuzzy
#| msgid "<primary><command>inetd</command></primary>"
msgid "<primary><command>insserv</command></primary>"
msgstr "<primary><command>inetd</command></primary>"

msgid "After this stage, <command>init</command> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <command>/etc/init.d/rc 2</command>, a script that starts all services which are listed in <filename>/etc/rc2.d/</filename> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <command>insserv</command>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <command>init</command> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <command>rsyslog</command>, or port assignment with <command>portmap</command>) are started first, followed by standard services and the graphical interface (<command>gdm3</command>)."
msgstr "Следом, <command>init</command> запускает программы уровня запуска по умолчанию (обычно runlevel 2). Запускается сценарий <command>/etc/init.d/rc 2</command>, который, в свою очередь, запускает сервисы, перечисленные в <filename>/etc/rc2.d/</filename>. Названия файлов в каталоге начинаются с буквы «S», за которой идут две цифры, что определяет очерёдность запуска. В настоящее время, загрузочная система по умолчанию использует программу <command>insserv</command>, которая автоматически всё организовывает, основываясь на зависимостях сценариев. Каждый сценарий объявляет условия, необходимые для его запуска и остановки (например, очерёдность по отношению к другим сценариям), <command>init</command> запускает сценарии в соответствующей последовательности для удовлетворения зависимостей. Поэтому наименование сценариев больше не учитывается (хотя они всё еще должны начинаться с «S» и далее продолжаться двумя цифрами и названием сервиса, которое и используется для организации зависимостей). В общем, основные сервисы (как журналирование с <command>rsyslog</command> или назначение портов с <command>portmap</command>) запускаются в первую очередь, затем следуют стандартные сервисы и графический интерфейс (<command>gdm3</command>)."

msgid "This dependency-based boot system makes it possible to automate re-numbering, which could be rather tedious if it had to be done manually, and it limits the risks of human error, since scheduling is conducted according to the parameters that are indicated. Another benefit is that services can be started in parallel when they are independent from one another, which can accelerate the boot process."
msgstr "Такая основанная на зависимостях система загрузки делает возможной автоматизацию смены нумерации, которая была бы весьма утомительной, если бы её приходилось выполнять вручную, и снижает риск человеческой ошибки, поскольку планирование выполняется в соответствии с формальными параметрами. Другим преимуществом является возможность параллельного запуска сервисов, независимых друг от друга, что может ускорить процесс загрузки."

msgid "<primary>runlevel</primary>"
msgstr "<primary>уровень запуска</primary>"

msgid "<primary>level, runlevel</primary>"
msgstr "<primary>запуск, уровень запуска</primary>"

#, fuzzy
#| msgid "<primary><command>telnet</command></primary>"
msgid "<primary><command>telinit</command></primary>"
msgstr "<primary><command>telnet</command></primary>"

msgid "<command>init</command> distinguishes several runlevels, so it can switch from one to another with the <command>telinit <replaceable>new-level</replaceable></command> command. Immediately, <command>init</command> executes <command>/etc/init.d/rc</command> again with the new runlevel. This script will then start the missing services and stop those that are no longer desired. To do this, it refers to the content of the <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (where <replaceable>X</replaceable> represents the new runlevel). Scripts starting with “S” (as in “Start”) are services to be started; those starting with “K” (as in “Kill”) are the services to be stopped. The script does not start any service that was already active in the previous runlevel."
msgstr "<command>init</command> различает несколько уровней запуска, так что она может переключаться с одного на другой при посредстве команды <command>telinit <replaceable>новый-уровень</replaceable></command>. <command>init</command> сразу же запускает <command>/etc/init.d/rc</command> заново с новым уровнем запуска. Этот сценарий после этого запускает недостающие сервисы и останавливает те, которые более не нужны. Для этого он руководствуется содержимым <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (где <replaceable>X</replaceable> означает новый уровень запуска). Сценарии, начинающиеся с «S» (как в слове «Start») — это сервисы, которые должны быть запущены; те, что начинаются с  «K» (как в слове «Kill») — сервисы, которые должны быть остановлены. Сценарий не запускает никаких сервисов, которые уже были активированы на прежнем уровне запуска."

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>System V init</primary><secondary>runlevels</secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

msgid "By default, System V init in Debian uses four different runlevels:"
msgstr "По умолчанию, System V init Debian использует четыре разных уровня запуска:"

msgid "Level 0 is only used temporarily, while the computer is powering down. As such, it only contains many “K” scripts."
msgstr "Уровень 0 используется только временно, при выключении питания компьютера. Поэтому он содержит только «K»-сценарии."

msgid "Level 1, also known as single-user mode, corresponds to the system in degraded mode; it includes only basic services, and is intended for maintenance operations where interactions with ordinary users are not desired."
msgstr "Уровень 1, также известный как однопользовательский режим, соответствует системе с урезанной функциональностью; он включает только основные сервисы и предназначается для операций по обслуживанию, когда взаимодействие с обычными пользователями нежелательно."

msgid "Level 2 is the level for normal operation, which includes networking services, a graphical interface, user logins, etc."
msgstr "Уровень 2 — уровень для нормальной работы, включающий сетевые сервисы, графический интерфейс, вход пользователей и т. п."

msgid "Level 6 is similar to level 0, except that it is used during the shutdown phase that precedes a reboot."
msgstr "Уровень 6 похож на уровень 0 с той разницей, что он используется во время остановки системы перед перезагрузкой."

msgid "Other levels exist, especially 3 to 5. By default they are configured to operate the same way as level 2, but the administrator can modify them (by adding or deleting scripts in the corresponding <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories) to adapt them to particular needs."
msgstr "Есть и другие уровни, в частности с 3 по 5. По умолчанию они настроены, чтобы работать точно так же, как уровень 2, но администратор может изменить их (путём добавления или удаления сценариев в соответствующие каталоги <filename>/etc/rc<replaceable>X</replaceable>.d</filename>), чтобы приспособить их под свои специфические нужды."

msgid "Boot sequence of a computer running Linux with System V init"
msgstr "Последовательность загрузки компьютера с Linux и System V init"

msgid "<primary>initialization script</primary>"
msgstr "<primary>инициализационный сценарий</primary>"

msgid "<primary><command>update-rc.d</command></primary>"
msgstr "<primary><command>update-rc.d</command></primary>"

#, fuzzy
#| msgid "<primary><command>cron</command></primary>"
msgid "<primary><command>rcconf</command></primary>"
msgstr "<primary><command>cron</command></primary>"

#, fuzzy
#| msgid "All the scripts contained in the various <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories are really only symbolic links — created upon package installation by the <command>update-rc.d</command> program — pointing to the actual scripts which are stored in <filename>/etc/init.d/</filename>. The administrator can fine tune the services available in each runlevel by re-running <command>update-rc.d</command> with adjusted parameters. The <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <literal>remove</literal> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <command>update-rc.d</command> has a somewhat convoluted interface, you may prefer using <command>rcconf</command> (from the <emphasis role=\"pkg\">rcconf</emphasis> package) which provides a more user-friendly interface."
msgid "All the scripts contained in the various <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories are really only symbolic links — created upon package installation by the <command>update-rc.d</command> program — pointing to the actual scripts which are stored in <filename>/etc/init.d/</filename>. The administrator can fine tune the services available in each runlevel by re-running <command>update-rc.d</command> with adjusted parameters. The <citerefentry><refentrytitle>update-rc.d</refentrytitle> <manvolnum>1</manvolnum></citerefentry> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <literal>remove</literal> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <command>update-rc.d</command> has a somewhat convoluted interface, you may prefer using <command>rcconf</command> (from the <emphasis role=\"pkg\">rcconf</emphasis> package) which provides a more user-friendly interface."
msgstr "Все сценарии, содержащиеся в различных каталогах <filename>/etc/rc<replaceable>X</replaceable>.d</filename> на самом деле являются лишь символьными ссылками — созданными при установке пакета программой <command>update-rc.d</command> — указывающими на сами сценарии, хранящиеся в <filename>/etc/init.d/</filename>. Администратор может настроить доступность сервисов на каждом уровне запуска путём повторного запуска <command>update-rc.d</command> с изменёнными параметрами. На странице руководства <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>8</manvolnum></citerefentry> подробно описан синтаксис. Обратите внимание, что удаление всех символьных ссылок (с помощью параметра <literal>remove</literal>) — не лучший метод отключения сервиса. Вместо этого следует просто настроить, чтобы он не запускался на нужном уровне запуска (сохранив соответствующие вызовы для остановки его в случае, если сервис работал на предыдущем уровне запуска). Поскольку интерфейс <command>update-rc.d</command> несколько запутанный, может оказаться более удобным использовать <command>rcconf</command> (из пакета <emphasis role=\"pkg\">rcconf</emphasis>), интерфейс которой более дружествен к пользователю."

msgid "<emphasis>DEBIAN POLICY</emphasis> Restarting services"
msgstr "<emphasis>ПОЛИТИКА DEBIAN</emphasis> Перезапуск сервисов"

msgid "<primary><command>invoke-rc.d</command></primary>"
msgstr "<primary><command>invoke-rc.d</command></primary>"

msgid "<primary>service</primary><secondary>restart</secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

msgid "<primary>restarting services</primary>"
msgstr "<primary>перезапуск сервисов</primary>"

msgid "The maintainer scripts for Debian packages will sometimes restart certain services to ensure their availability or get them to take certain options into account. The command that controls a service — <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> — doesn't take runlevel into consideration, assumes (wrongly) that the service is currently being used, and may thus initiate incorrect operations (starting a service that was deliberately stopped, or stopping a service that is already stopped, etc.). Debian therefore introduced the <command>invoke-rc.d</command> program: this program must be used by maintainer scripts to run services initialization scripts and it will only execute the necessary commands. Note that, contrary to common usage, the <filename>.d</filename> suffix is used here in a program name, and not in a directory."
msgstr "Сценарии сопровождающего пакет Debian иногда перезапускают сервисы для того, чтобы убедиться в их доступности или для применения изменений. Команда для контроля за сервисами <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> не учитывает уровень запуска, подразумевает (ошибочно) что сервис уже используется и может выполнить неправильные операции (запуск сервиса, намеренно остановленного или остановку сервиса, который уже остановлен и т. п.). Поэтому Debian представляет программу <command>invoke-rc.d</command>, которая должна использоваться сопровождающим для запуска сценариев, в свою очередь, предназначенных для запуска сервисов. Она будет запускать только необходимые команды. Заметьте что здесь, по сравнению с традиционным использованием суффикса <filename>.d</filename>, он используется как часть названия программы, а не каталога."

msgid "Finally, <command>init</command> starts control programs for various virtual consoles (<command>getty</command>). It displays a prompt, waiting for a username, then executes <command>login <replaceable>user</replaceable></command> to initiate a session."
msgstr "Наконец, <command>init</command> запускает программу управления виртуальными консолями (<command>getty</command>). Она выводит приглашение, ожидает ввода имени пользователя, а затем выполняет <command>login <replaceable>пользователь</replaceable></command>, чтобы начать сессию."

msgid "<primary><command>getty</command></primary>"
msgstr "<primary><command>getty</command></primary>"

#, fuzzy
#| msgid "<primary>server</primary><secondary>client/server architecture</secondary>"
msgid "<primary>service</primary><secondary><filename>getty@.service</filename></secondary>"
msgstr "<primary>сервер</primary><secondary>клиент-серверная архитектура</secondary>"

msgid "<emphasis>VOCABULARY</emphasis> Console and terminal"
msgstr "<emphasis>СЛОВАРЬ</emphasis> Консоль и терминал"

#, fuzzy
#| msgid "<primary>inode</primary>"
msgid "<primary>console</primary>"
msgstr "<primary>inode</primary>"

#, fuzzy
#| msgid "<primary>permissions</primary>"
msgid "<primary>terminal</primary>"
msgstr "<primary>разрешения</primary>"

msgid "The first computers were usually separated into several, very large parts: the storage enclosure and the central processing unit were separate from the peripheral devices used by the operators to control them. These were part of a separate furniture, the “console”. This term was retained, but its meaning has changed. It has become more or less synonymous with “terminal”, being a keyboard and a screen."
msgstr "Первые компьютеры обычно состояли из нескольких очень больших частей: устройство хранения данных и вычислительный модуль размещались отдельно от периферийных устройств, используемых операторами для управления. Часть этой оснастки называлась «консоль». Этот термин остался, но смысл его изменился. Он стал синонимом «терминала» — клавиатуры и дисплея."

msgid "With the development of computers, operating systems have offered several virtual consoles to allow for several independent sessions at the same time, even if there is only one keyboard and screen. Most GNU/Linux systems offer six virtual consoles (in text mode), accessible by typing the key combinations <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> through <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>."
msgstr "С развитием компьютеров операционные системы стали предлагать несколько виртуальных консолей, чтобы сделать возможной одновременную работу нескольких сессий даже при наличии только одной клавиатуры и дисплея. В большинстве систем GNU/Linux шесть виртуальных консолей (в текстовом режиме), доступных путём нажатия сочетаний клавиш с <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> по <keycombo action=\"simul\"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>."

#, fuzzy
#| msgid "By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical X11 session (such as <command>xterm</command>, <command>gnome-terminal</command> or <command>konsole</command>)."
msgid "By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical session (such as <command>xterm</command>, <command>gnome-terminal</command> or <command>konsole</command>)."
msgstr "Также термины «консоль» и «терминал» могут означать эмулятор терминала в графической сессии X11 (например <command>xterm</command>, <command>gnome-terminal</command> или <command>konsole</command>)."

msgid "Remote Login"
msgstr "Удалённый вход"

msgid "It is essential for an administrator to be able to connect to a computer remotely. Servers, confined in their own room, are rarely equipped with permanent keyboards and monitors — but they are connected to the network."
msgstr "Для администратора крайне важно иметь возможность подключиться к компьютеру удалённо. Серверы, заключённые в своей собственной комнате, редко оснащаются постоянными клавиатурами и мониторами — но они подключены к сети."

msgid "<emphasis>BACK TO BASICS</emphasis> Client, server"
msgstr "<emphasis>К ОСНОВАМ</emphasis> Клиент, сервер"

msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>клиент</primary><secondary>клиент-серверная архитектура</secondary>"

msgid "<primary>server</primary><secondary>client/server architecture</secondary>"
msgstr "<primary>сервер</primary><secondary>клиент-серверная архитектура</secondary>"

msgid "A system where several processes communicate with each other is often described with the “client/server” metaphor. The server is the program that takes requests coming from a client and executes them. It is the client that controls operations, the server doesn't take any initiative of its own."
msgstr "Система, в которой несколько процессов взаимодействуют друг с другом, часто описывается с помощью терминов «клиент» и «сервер». Сервер — это программа, принимающая запрос от клиента и выполняющая его. Все действия контролируются клиентом, сервер сам по себе не проявляет никакой инициативы."

msgid "<primary>login</primary><secondary>remote login</secondary>"
msgstr "<primary>вход</primary><secondary>удалённый вход</secondary>"

msgid "<primary>remote login</primary>"
msgstr "<primary>удалённый вход</primary>"

msgid "Secure Remote Login: SSH"
msgstr "Защищённый удалённый вход: SSH"

msgid "<primary>SSH</primary>"
msgstr "<primary>SSH</primary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>server</primary><secondary>SSH</secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

#, fuzzy
#| msgid "<primary><command>rsh</command></primary>"
msgid "<primary><command>ssh</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>Secure Shell</primary><seealso>SSH</seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

msgid "The <emphasis>SSH</emphasis> (Secure SHell) protocol was designed with security and reliability in mind. Connections using SSH are secure: the partner is authenticated and all data exchanges are encrypted."
msgstr "Протокол <emphasis>SSH</emphasis> (\"Secure SHell\" — защищённая командная оболочка) был разработан из соображений безопасности и надёжности. Соединения, использующие SSH, защищены: другая сторона аутентифицируется, а весь обмен данными зашифрован."

msgid "<emphasis>CULTURE</emphasis> Telnet and RSH are obsolete"
msgstr "<emphasis>КУЛЬТУРА</emphasis> Telnet и RSH устарели"

msgid "<primary><command>telnet</command></primary>"
msgstr "<primary><command>telnet</command></primary>"

msgid "<primary><command>rsh</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

msgid "Before SSH, <emphasis>Telnet</emphasis> and <emphasis>RSH</emphasis> were the main tools used to login remotely. They are now largely obsolete and should no longer be used even if Debian still provides them."
msgstr "До SSH основными средствами удалённого доступа были <emphasis>Telnet</emphasis> и <emphasis>RSH</emphasis>. Сейчас они сильно устарели, и их не следует использовать, хотя они всё ещё есть в Debian."

msgid "<emphasis>VOCABULARY</emphasis> Authentication, encryption"
msgstr "<emphasis>СЛОВАРЬ</emphasis> Аутентификация, шифрование"

#, fuzzy
#| msgid "When you need to give a client the ability to conduct or trigger actions on a server, security is important. You must ensure the identity of the client; this is authentication. This identity usually consists of a password that must be kept secret, or any other client could get the password. This is the purpose of encryption, which is a form of encoding that allows two systems to communicate confidential information on a public channel while protecting it from being readable to others."
msgid "When you need to give a client the ability to conduct or trigger actions on a server, security is important. You must ensure the identity of the client; this is <emphasis>authentication</emphasis>. This identity usually consists of a password or passphrase that must be kept secret, or any other client could it. This is the purpose of <emphasis>encryption</emphasis>, which is a form of encoding that allows two systems to communicate confidential information on a public channel while protecting it from being readable to others."
msgstr "Безопасность важна, когда необходимо дать клиенту возможность управления или выполнения действий на сервере. Необходимо надёжно идентифицировать клиента; это называется аутентификацией. Для идентификации обычно используется пароль, который должен храниться в секрете, иначе другой клиент мог бы воспользоваться им. Для этого служит шифрование — форма кодирования, позволяющая двум системам обмениваться конфиденциальной информацией по публичному каналу, защищая её от чтения другими."

msgid "Authentication and encryption are often mentioned together, both because they are frequently used together, and because they are usually implemented with similar mathematical concepts."
msgstr "Аутентификация и шифрование часто упоминаются вместе, потому что они часто используются совместно, и потому что они обычно основываются на сходных математических принципах."

msgid "<primary><command>scp</command></primary>"
msgstr "<primary><command>scp</command></primary>"

msgid "SSH also offers two file transfer services. <command>scp</command> is a command line tool that can be used like <command>cp</command>, except that any path to another machine is prefixed with the machine's name, followed by a colon."
msgstr "В состав SSH также входят две транспортных службы. <command>scp</command> — это инструмент командной строки, который можно использовать наподобие <command>cp</command> с той разницей, что любой путь к другой машине начинается с указания её имени, за которым следует двоеточие."

msgid "<computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput>"
msgstr "<computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput>"

msgid "<primary><command>sftp</command></primary>"
msgstr "<primary><command>sftp</command></primary>"

msgid "<command>sftp</command> is an interactive command, similar to <command>ftp</command>. In a single session, <command>sftp</command> can transfer several files, and it is possible to manipulate remote files with it (delete, rename, change permissions, etc.)."
msgstr "<command>sftp</command> — это интерактивная команда, похожая на <command>ftp</command>. В рамках одной сессии <command>sftp</command> может передать несколько файлов, а также с её помощью можно манипулировать удалёнными файлами (удалять, переименовывать, менять права доступа и т. д.)."

#, fuzzy
#| msgid "<primary>tunnel (SSH)</primary><seealso>VPN</seealso>"
msgid "<primary>OpenSSH</primary><seealso>SSH</seealso>"
msgstr "<primary>туннель (SSH)</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><secondary>VNC</secondary>"
msgid "<primary>SSH</primary><secondary>OpenSSH</secondary>"
msgstr "<primary>SSH-туннель</primary><secondary>VNC</secondary>"

msgid "Debian uses OpenSSH, a free version of SSH maintained by the <command>OpenBSD</command> project (a free operating system based on the BSD kernel, focused on security) and fork of the original SSH software developed by the SSH Communications Security Corp company, of Finland. This company initially developed SSH as free software, but eventually decided to continue its development under a proprietary license. The OpenBSD project then created OpenSSH to maintain a free version of SSH."
msgstr "В Debian используется OpenSSH — свободная реализация SSH, развиваемая в рамках проекта <command>OpenBSD</command> (свободной операционной системы, основанной на ядре BSD и делающей акцент на безопасности), и являющаяся ответвлением оригинальной программы SSH, разработанной финской компанией SSH Communications Security Corp. Эта компания изначально разрабатывала SSH как свободное ПО, но впоследствии решила продолжить разработку под собственнической лицензией. Тогда проект OpenBSD создал OpenSSH, чтобы развивать свободную версию SSH."

msgid "<emphasis>BACK TO BASICS</emphasis> <foreignphrase>Fork</foreignphrase>"
msgstr "<emphasis>К ОСНОВАМ</emphasis> Ответвление (<foreignphrase>fork</foreignphrase>)"

msgid "<primary>fork</primary>"
msgstr "<primary>форк</primary>"

msgid "A “fork”, in the software field, means a new project that starts as a clone of an existing project, and that will compete with it. From there on, both software will usually quickly diverge in terms of new developments. A fork is often the result of disagreements within the development team."
msgstr "В области программного обеспечения «ответвление» или «форк» означает новый проект, начатый как клон существующего проекта и конкурирующий с ним. В дальнейшем оба программных продукта как правило быстро расходятся в плане новых доработок. Форк часто является результатом конфликтов внутри команды разработчиков."

msgid "The option to fork a project is a direct result of the very nature of free software; a fork is a healthy event when it enables the continuation of a project as free software (for example in case of license changes). A fork arising from technical or personal disagreements is often a waste of human resources; another resolution would be preferable. Mergers of two projects that previously went through a prior fork are not unheard of."
msgstr "Возможность создать ответвление прямо следует из самой природы свободного ПО; форк — это здоровое явление, если оно позволяет продолжить развитие проекта как свободного ПО (например в случае изменения лицензии). Форк, возникающий из-за технических или личных разногласий зачастую является транжирством человеческого ресурса; другое решение было бы более предпочтительным. Случаются и слияния двух проектов, ранее разошедшихся вследствие форка."

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">openssh-client</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">openssh-server</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

#, fuzzy
#| msgid "OpenSSH is split into two packages: the client part is in the <emphasis role=\"pkg\">openssh-client</emphasis> package, and the server is in the <emphasis role=\"pkg\">openssh-server</emphasis> package. The <emphasis role=\"pkg\">ssh</emphasis> meta-package depends on both parts and facilitates installation of both (<command>apt install ssh</command>)."
msgid "OpenSSH is split into two packages: the client part is in the <emphasis role=\"pkg\">openssh-client</emphasis> package, and the server is in the <emphasis role=\"pkg\">openssh-server</emphasis> package. The <emphasis role=\"pkg\">ssh</emphasis> meta-package depends on both parts and facilitates installation of both (<command>apt install ssh</command>), while the <emphasis role=\"pkg\">task-ssh-server</emphasis>, often chosen during the initial installation, depends on the server package only."
msgstr "OpenSSH разделён на два пакета: клиент <emphasis role=\"pkg\">openssh-client</emphasis> и сервер <emphasis role=\"pkg\">openssh-server</emphasis>. Мета-пакет <emphasis role=\"pkg\">ssh</emphasis> устанавливает оба (<command>apt install ssh</command>)."

msgid "Key-Based Authentication"
msgstr "Аутентификация по ключу"

#, fuzzy
#| msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgid "<primary>SSH</primary><secondary>key creation</secondary>"
msgstr "<primary>журнал</primary><secondary>пересылка</secondary>"

msgid "Each time someone logs in over SSH, the remote server asks for a password to authenticate the user. This can be problematic if you want to automate a connection, or if you use a tool that requires frequent connections over SSH. This is why SSH offers a key-based authentication system."
msgstr "При каждом входе по SSH удалённый сервер запрашивает пароль, чтобы аутентифицировать пользователя. Это может создать проблему, если хочется автоматизировать соединение, или если используется некий инструмент, которому нужно часто устанавливать соединения через SSH. По этой причине в SSH предусмотрен механизм аутентификации по ключу."

#, fuzzy
#| msgid "<primary><command>rsync</command></primary>"
msgid "<primary><command>ssh-keygen</command></primary>"
msgstr "<primary><command>rsync</command></primary>"

#, fuzzy
#| msgid "<primary><command>acpid</command></primary>"
msgid "<primary><command>ssh-copy-id</command></primary>"
msgstr "<primary><command>acpid</command></primary>"

msgid "The user generates a key pair on the client machine with <command>ssh-keygen -t rsa</command>; the so generated public key is stored in <filename>~/.ssh/id_rsa.pub</filename>, while the corresponding private key is stored in <filename>~/.ssh/id_rsa</filename>. The user can then use <command>ssh-copy-id <replaceable>server</replaceable></command> to add their public key to the <filename>~/.ssh/authorized_keys</filename> file on the server, or, if SSH access hasn't been enabled yet, they have to ask the administrator to add their key manually."
msgstr ""

#, fuzzy
#| msgid "<primary>logs</primary><secondary>dispatching</secondary>"
msgid "<primary>SSH</primary><secondary>passphrase cache</secondary>"
msgstr "<primary>журналы</primary><secondary>управление</secondary>"

#, fuzzy
#| msgid "<primary>link</primary><secondary>hard link</secondary>"
msgid "<primary>SSH</primary><secondary>passwordless</secondary>"
msgstr "<primary>ссылка</primary><secondary>жёсткая ссылка</secondary>"

#, fuzzy
#| msgid "<primary>logs</primary><secondary>dispatching</secondary>"
msgid "<primary>SSH</primary><secondary>authentication agent</secondary>"
msgstr "<primary>журналы</primary><secondary>управление</secondary>"

#, fuzzy
#| msgid "<primary><command>at</command></primary>"
msgid "<primary><command>ssh-agent</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "<primary>booting</primary><secondary>the system</secondary>"
msgid "<primary>X.org</primary><secondary><filename>/etc/X11/Xsession.options</filename></secondary>"
msgstr "<primary>загрузка</primary><secondary>системы</secondary>"

#, fuzzy
#| msgid "The user generates a key pair on the client machine with <command>ssh-keygen -t rsa</command>; the public key is stored in <filename>~/.ssh/id_rsa.pub</filename>, while the corresponding private key is stored in <filename>~/.ssh/id_rsa</filename>. The user then uses <command>ssh-copy-id <replaceable>server</replaceable></command> to add their public key to the <filename>~/.ssh/authorized_keys</filename> file on the server. If the private key was not protected with a “passphrase” at the time of its creation, all subsequent logins on the server will work without a password. Otherwise, the private key must be decrypted each time by entering the passphrase. Fortunately, <command>ssh-agent</command> allows us to keep private keys in memory to not have to regularly re-enter the password. For this, you simply use <command>ssh-add</command> (once per work session) provided that the session is already associated with a functional instance of <command>ssh-agent</command>. Debian activates it by default in graphical sessions, but this can be deactivated by changing <filename>/etc/X11/Xsession.options</filename>. For a console session, you can manually start it with <command>eval $(ssh-agent)</command>."
msgid "If the private key was not protected with a “passphrase” at the time of its creation, all subsequent logins on the server will work without a password. Otherwise, the private key must be decrypted each time by entering the passphrase. Fortunately, <command>ssh-agent</command> allows us to keep private keys in memory to not have to regularly re-enter the password. For this, you simply use <command>ssh-add</command> (once per work session) provided that the session is already associated with a functional instance of <command>ssh-agent</command>. Debian activates it by default in graphical sessions, but this can be deactivated by changing <filename>/etc/X11/Xsession.options</filename> and commenting out <literal>use-ssh-agent</literal>. For a console session, you can manually start the agent with <command>eval $(ssh-agent)</command>."
msgstr "Пользователь создаёт на клиентской машине пару ключей с помощью <command>ssh-keygen -t rsa</command>; публичный ключ сохраняется в <filename>~/.ssh/id_rsa.pub</filename>, а соответствующий ему секретный ключ — в <filename>~/.ssh/id_rsa</filename>. Затем пользователь с помощью команды <command>ssh-copy-id <replaceable>сервер</replaceable></command> добавляет публичный ключ в файл <filename>~/.ssh/authorized_keys</filename> на сервере. Если секретный ключ не был при создании защищён «парольной фразой», все последующие входы на сервер будут работать без пароля. В противном случае потребуется расшифровывать секретный ключ  каждый раз, вводя парольную фразу. К счастью, <command>ssh-agent</command> позволяет хранить секретные ключи в памяти, чтобы не приходилось то и дело вводить пароль. Для этого ипользуется <command>ssh-add</command> (однократно за рабочую сессию) при условии, что сессия уже ассощиирована с работающим экземпляром <command>ssh-agent</command>. Debian активирует его по умолчанию в графических сессиях, но это можно отключить, изменив <filename>/etc/X11/Xsession.options</filename>. Для консольной сессии можно запустить его вручную с помощью <command>eval $(ssh-agent)</command>."

msgid "<emphasis>SECURITY</emphasis> Protection of the private key"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> Защита секретного ключа"

#, fuzzy
#| msgid "<primary>mask</primary><secondary>rights mask</secondary>"
msgid "<primary>SSH</primary><secondary>private key</secondary>"
msgstr "<primary>маска</primary><secondary>маска прав</secondary>"

msgid "Whoever has the private key can login on the account thus configured. This is why access to the private key is protected by a “passphrase”. Someone who acquires a copy of a private key file (for example, <filename>~/.ssh/id_rsa</filename>) still has to know this phrase in order to be able to use it. This additional protection is not, however, impregnable, and if you think that this file has been compromised, it is best to disable that key on the computers in which it has been installed (by removing it from the <filename>authorized_keys</filename> files) and replacing it with a newly generated key."
msgstr "Кто угодно, имеющий секретный ключ, может войти в настроенную таким образом учётную запись. Поэтому доступ к секретному ключу защищается «парольной фразой». Некто, получивший копию секретного ключа (например <filename>~/.ssh/id_rsa</filename>) всё равно должен знать эту фразу, чтобы иметь возможность воспользоваться им. Эта дополнительная защита не является, однако, неприступной, и если есть основания полагать, что данный файл был скомпроментирован, лучше отключить этот ключ на компьютерах, на которые он был установлен, (путём удаления его из файлов <filename>authorized_keys</filename>) и заменить его вновь созданным ключом."

msgid "<emphasis>CULTURE</emphasis> OpenSSL flaw in Debian <emphasis role=\"distribution\">Etch</emphasis>"
msgstr "<emphasis>КУЛЬТУРА</emphasis> Уязвимость OpenSSL в Debian <emphasis role=\"distribution\">Etch</emphasis>"

#, fuzzy
#| msgid "The OpenSSL library, as initially provided in Debian <emphasis role=\"distribution\">Etch</emphasis>, had a serious problem in its random number generator (RNG). Indeed, the Debian maintainer had made a change so that applications using it would no longer generate warnings when analyzed by memory testing tools like <command>valgrind</command>. Unfortunately, this change also meant that the RNG was employing only one source of entropy corresponding to the process number (PID) whose 32,000 possible values do not offer enough randomness. <ulink type=\"block\" url=\"http://www.debian.org/security/2008/dsa-1571\" />"
msgid "The OpenSSL library, as initially provided in Debian <emphasis role=\"distribution\">Etch</emphasis>, had a serious problem in its random number generator (RNG). Indeed, the Debian maintainer had made a change so that applications using it would no longer generate warnings when analyzed by memory testing tools like <command>valgrind</command>. Unfortunately, this change also meant that the RNG was employing only one source of entropy corresponding to the process number (PID) whose 32,000 possible values do not offer enough randomness. <ulink type=\"block\" url=\"https://www.debian.org/security/2008/dsa-1571\" />"
msgstr "У библиотеки OpenSSL в том виде, в каком она поставлялась в Debian <emphasis role=\"distribution\">Etch</emphasis>, была серьёзная проблема с генератором случайных чисел (ГСЧ). На самом деле сопровождающий Debian внёс изменение, чтобы приложения, используемые библиотекой, перестали выводить предупреждения при анализе их инструментами тестирования памяти вроде <command>valgrind</command>. К сожалению, это изменение также привело к тому, что ГСЧ стал использовать только один источник энтропии, соответствующий идентификатору процесса (PID), 32.000 возможных значений которого не обеспечивают должного уровня случайности. <ulink type=\"block\" url=\"http://www.debian.org/security/2008/dsa-1571\" />"

#, fuzzy
#| msgid "<primary><command>rsh</command></primary>"
msgid "<primary><command>ssh-vulnkey</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">openssh-blacklist</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">tsclient</emphasis></primary>"

msgid "Specifically, whenever OpenSSL was used to generate a key, it always produced a key within a known set of hundreds of thousands of keys (32,000 multiplied by a small number of key lengths). This affected SSH keys, SSL keys, and X.509 certificates used by numerous applications, such as OpenVPN. A cracker had only to try all of the keys to gain unauthorized access. To reduce the impact of the problem, the SSH daemon was modified to refuse problematic keys that are listed in the <emphasis role=\"pkg\">openssh-blacklist</emphasis> and <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis> packages. Additionally, the <command>ssh-vulnkey</command> command allows identification of possibly compromised keys in the system."
msgstr "В частности, когда OpenSSL использовалась для генерации ключа, она всегда создавала ключ из известного набора нескольких сотен тысяч ключей (32.000, помноженные на небольшое число длин ключей). Это затронуло ключи SSH и SSL, а также сертификаты X.509, используемые многочисленными приложениями, такими как OpenVPN. Взломщику оставалось только перепробовать все ключи, чтобы получить неавторизованный доступ. Чтобы уменьшить последствия этой проблемы, демон SSH был модифицирован таким образом, чтобы отклонять проблемные ключи, перечисленные в пакетах <emphasis role=\"pkg\">openssh-blacklist</emphasis> и <emphasis role=\"pkg\">openssh-blacklist-extra</emphasis>. Кроме того, команда <command>ssh-vulnkey</command> позволяет обнаружить возможно скомпроментированные ключи в системе."

msgid "A more thorough analysis of this incident brings to light that it is the result of multiple (small) problems, both within the OpenSSL project and with the Debian package maintainer. A widely used library like OpenSSL should — without modifications — not generate warnings when tested by <command>valgrind</command>. Furthermore, the code (especially the parts as sensitive as the RNG) should be better commented to prevent such errors. On Debian's side, the maintainer wanted to validate the modifications with the OpenSSL developers, but simply explained the modifications without providing the corresponding patch to review and failed to mention his role within Debian. Finally, the maintenance choices were sub-optimal: the changes made to the original code were not clearly documented; all the modifications were effectively stored in a Subversion repository, but they ended up all lumped into one single patch during creation of the source package."
msgstr "Более детальный анализ выявил, что это результат нескольких (небольших) проблем и в проекте OpenSSL и у сопровождающего пакет Debian. Такие широко используемые библиотеки как OpenSSL должны без изменений проходить тест <command>valgrind</command> без предупреждений. Более того, код (особенно чувствительные части, как RNG) должен быть лучше сопровождён комментариями для предотвращения таких ошибок. Сопровождающий пакета Debian хотел согласовать изменения вместе с разработчиками OpenSSL, но просто объяснил их, не предоставив соответствующий патч для проверки и не уведомил о своей роли в Debian. Наконец, его выбор не был оптимальным: изменения в исходном коде не были отчётливо сопровождены комментариями. Они были сохранены в репозитории Subversion, затем свалены в один патч во время создания пакета с исходным кодом."

#, fuzzy
#| msgid "It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type=\"block\" url=\"http://sources.debian.net\" />"
msgid "It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type=\"block\" url=\"https://sources.debian.org\" />"
msgstr ""
"При таких условиях трудно найти средства для предотвращения подобных инцидентов в будущем. Урок, который можно вынести из этого — каждое изменение, внесённое Debian в апстрим программное обеспечение, должно быть подтверждено, документировано, внесено в проект и широко оглашено. В соответствии с этим разработан новый формат для исходников («3.0 (quilt)») и веб-сервис.\n"
"<ulink type=\"block\" url=\"http://sources.debian.net\" />"

#, fuzzy
#| msgid "Key-Based Authentication"
msgid "Cert-Based Authentication"
msgstr "Аутентификация по ключу"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>SSH</primary><secondary>signed key</secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

#, fuzzy
#| msgid "<primary>booting</primary><secondary>the system</secondary>"
msgid "<primary>SSH</primary><secondary><literal>TrustedUserCAKeys</literal></secondary>"
msgstr "<primary>загрузка</primary><secondary>системы</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>SSH</primary><secondary><literal>HostCertificate</literal></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/ssh/sshd_config</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/ssh/known_hosts</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "SSH keys cannot just be protected by a password (or not). An often unknown feature is that they can also be signed via certificate, both the host as well as the client keys. This approach comes with several advantages. Instead of maintaining an <filename>authorized_keys</filename> file per user as described in the previous section, the SSH server can be configured to trust all client keys signed by the same certificate (see also <xref linkend=\"sect.easy-rsa\" />) by using the <literal>TrustedUserCAKeys</literal> and <literal>HostCertificate</literal> directives in <filename>/etc/ssh/sshd_config</filename>."
msgstr ""

msgid ""
"\n"
"TrustedUserCAKeys /etc/ssh/ssh_users_ca.pub\n"
"\n"
"HostKey /etc/ssh/ssh_host_ecdsa_key\n"
"HostCertificate /etc/ssh/ssh_host_ecdsa_key-cert.pub"
msgstr ""

msgid "Vice-versa the clients can also be configured to trust the host key signed by the same authority, making it easier to maintain the <filename>known_hosts</filename> file (even system wide via <filename>/etc/ssh/known_hosts</filename>)."
msgstr ""

msgid "@cert-authority *.falcot.com ssh-rsa AAAA[..]"
msgstr ""

msgid "Both, public key and certificate authentication, can be used alongside each other."
msgstr ""

msgid "Using Remote X11 Applications"
msgstr "Использование удалённых приложений X11"

#, fuzzy
#| msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgid "<primary>SSH</primary><secondary><literal>X11Forwarding</literal></secondary>"
msgstr "<primary>журнал</primary><secondary>пересылка</secondary>"

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary>SSH</primary><secondary><literal>remote graphical applications</literal></secondary>"
msgstr "<primary>вход</primary><secondary>удалённый вход</secondary>"

#, fuzzy
#| msgid "<primary>remote graphical desktop</primary>"
msgid "<primary>remote graphical application</primary>"
msgstr "<primary>удалённый графический рабочий стол</primary>"

#, fuzzy
#| msgid "<primary>desktop, remote graphical desktop</primary>"
msgid "<primary>application, remote graphical application</primary>"
msgstr "<primary>рабочий стол, удалённый графический</primary>"

msgid "The SSH protocol allows forwarding of graphical data (“X11” session, from the name of the most widespread graphical system in Unix); the server then keeps a dedicated channel for those data. Specifically, a graphical program executed remotely can be displayed on the X.org server of the local screen, and the whole session (input and display) will be secure. Since this feature allows remote applications to interfere with the local system, it is disabled by default. You can enable it by specifying <literal>X11Forwarding yes</literal> in the server configuration file (<filename>/etc/ssh/sshd_config</filename>). Finally, the user must also request it by adding the <literal>-X</literal> option to the <command>ssh</command> command-line."
msgstr "Протокол SSH позволяет пересылать графические данные (сессию «X11», по названию наиболее широко распространённой в Unix графической системы); в таком случае сервер сохраняет выделенный канал для этих данных. Так, графическая программа, запущенная удалённо, может быть отображена сервером X.org на локальном экране, и вся сессия (ввод и отображение) будет защищена. Поскольку эта возможность позволяет удалённым приложениям перекрываться с локальной системой, она отключена по умолчанию. Её можно включить, указав <literal>X11Forwarding yes</literal> в конфигурационном файле сервера (<filename>/etc/ssh/sshd_config</filename>). Пользователь также должен явно запросить её, добавив опцию <literal>-X</literal> к командной строке <command>ssh</command>."

#, fuzzy
#| msgid "<emphasis>GOING FURTHER</emphasis> Defining quotas with a script"
msgid "<emphasis>GOING FURTHER</emphasis> Magic cookies in .Xauthority"
msgstr "<emphasis>УГЛУБЛЯЕМСЯ</emphasis> Определение квот с помощью сценария"

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>.Xauthority</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

#, fuzzy
#| msgid "<primary><command>at</command></primary>"
msgid "<primary><command>xauth</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "<primary>inode</primary>"
msgid "<primary>magic cookie</primary>"
msgstr "<primary>inode</primary>"

msgid "When a user connects via SSH and starts a remote X11 session, a so-called <emphasis>magic cookie</emphasis> is created and stored in the <filename>.Xauthority</filename> file in the user's home directory that initiated the connection. This cookie is used by <command>xauth</command> to authenticate the user during the X session. If the user impersonates another user on the system, e.g. using <command>su</command> or <command>sudo</command>, then the cookie is not copied automatically to the target user and the X server will refuse to start graphical applications under the target user's context. You will have to copy the magic cookie into the target user's home directory (by exporting and re-importing the cookie via <command>xauth</command>) to allow another user to start graphical programs as well during the X session."
msgstr ""

msgid "Creating Encrypted Tunnels with Port Forwarding"
msgstr "Создание шифрованных туннелей"

msgid "<primary>port forwarding</primary>"
msgstr "<primary>port forwarding</primary>"

#, fuzzy
#| msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgid "<primary>SSH</primary><secondary>port forwarding</secondary>"
msgstr "<primary>журнал</primary><secondary>пересылка</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>SSH</primary><secondary>tunnel</secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "Its <literal>-R</literal> and <literal>-L</literal> options allow <command>ssh</command> to create “encrypted tunnels” between two machines, securely forwarding a local TCP port (see sidebar <xref linkend=\"sidebar.tcp-udp\" />) to a remote machine or vice versa."
msgstr "Опции <literal>-R</literal> и <literal>-L</literal> указывают <command>ssh</command>, что нужно создать «шифрованный туннель» между двумя машинами, безопасно перенаправив локальный порт TCP (см. врезку <xref linkend=\"sidebar.tcp-udp\" />) на удалённую машину или наоборот."

msgid "<emphasis>VOCABULARY</emphasis> Tunnel"
msgstr "<emphasis>СЛОВАРЬ</emphasis> Туннель"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>tunnel</primary><secondary>SSH</secondary><seealso>VPN</seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>SSH</primary><secondary>tunnel</secondary><seealso>VPN</seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

msgid "The Internet, and most LANs that are connected to it, operate in packet mode and not in connected mode, meaning that a packet issued from one computer to another is going to be stopped at several intermediary routers to find its way to its destination. You can still simulate a connected operation where the stream is encapsulated in normal IP packets. These packets follow their usual route, but the stream is reconstructed unchanged at the destination. We call this a “tunnel”, analogous to a road tunnel in which vehicles drive directly from the entrance (input) to the exit (output) without encountering any intersections, as opposed to a path on the surface that would involve intersections and changing direction."
msgstr "Интернет, как и большинство подключённых к нему локальных сетей, работает в пакетном режиме, а не в подключённом. Это означает, что пакет, отправленный одним компьютером другому, будет останавливаться на нескольких промежуточных маршрутизаторах для выяснения пути к его месту назначения. Но всё же можно симулировать подключённую работу, энкапсулируя поток в обычные пакеты IP. Эти пакеты следуют своим обычным путём, а поток восстанавливается в неизменном виде в месте назначения. Это называется «туннелем» по аналогии с дорожным туннелем, по которому автомобили следуют напрямую от въезда (ввод) к выезду (вывод) без каких бы то ни было перекрёстков, в противоположность движению по поверхности, где встречались бы перекрёстки и менялось направление движения."

msgid "You can use this opportunity to add encryption to the tunnel: the stream that flows through it is then unrecognizable from the outside, but it is returned in decrypted form at the exit of the tunnel."
msgstr "Эту возможность можно использовать, чтобы добавить шифрование в туннель: поток, идущий через него, не распознаваем извне, но возвращается к расшифрованному виду на выходе из туннеля."

msgid "<command>ssh -L 8000:server:25 intermediary</command> establishes an SSH session with the <replaceable>intermediary</replaceable> host and listens to local port 8000 (see <xref linkend=\"figure.ssh-L\" />). For any connection established on this port, <command>ssh</command> will initiate a connection from the <replaceable>intermediary</replaceable> computer to port 25 on the <replaceable>server</replaceable>, and will bind both connections together."
msgstr "<command>ssh -L 8000:server:25 intermediary</command> устанавливает сессию SSH с узлом <replaceable>intermediary</replaceable> и слушает локальный порт 8000 (см. <xref linkend=\"figure.ssh-L\" />). Для любого соединения, установленного на этом порту, <command>ssh</command> инициирует соединение с машины<replaceable>intermediary</replaceable> на порт 25 машины <replaceable>server</replaceable> и свяжет оба соединения друг с другом."

msgid "<command>ssh -R 8000:server:25 intermediary</command> also establishes an SSH session to the <replaceable>intermediary</replaceable> computer, but it is on this machine that <command>ssh</command> listens to port 8000 (see <xref linkend=\"figure.ssh-R\" />). Any connection established on this port will cause <command>ssh</command> to open a connection from the local machine on to port 25 of the <replaceable>server</replaceable>, and to bind both connections together."
msgstr "<command>ssh -R 8000:server:25 intermediary</command> также устанавливают сессию SSH с <replaceable>intermediary</replaceable> компьютером, но на этой машине находится <command>ssh</command> и уже слушает порт 8000 (см. <xref linkend=\"figure.ssh-R\" />). Любое соединение с этим портом заставит <command>ssh</command> открыть соединение с локальной машины на порт 25 машины <replaceable>server</replaceable> и связать между собой два соединения."

msgid "In both cases, connections are made to port 25 on the <replaceable>server</replaceable> host, which pass through the SSH tunnel established between the local machine and the <replaceable>intermediary</replaceable> machine. In the first case, the entrance to the tunnel is local port 8000, and the data move towards the <replaceable>intermediary</replaceable> machine before being directed to the <replaceable>server</replaceable> on the “public” network. In the second case, the input and output in the tunnel are reversed; the entrance is port 8000 on the <replaceable>intermediary</replaceable> machine, the output is on the local host, and the data are then directed to the <replaceable>server</replaceable>. In practice, the server is usually either the local machine or the intermediary. That way SSH secures the connection from one end to the other."
msgstr "В обоих случаях соединения устанавливаются с портом 25 узла <replaceable>server</replaceable>, проходя через туннель SSH между локальной машиной и машиной <replaceable>intermediary</replaceable>. В первом случае входом в туннель является локальный порт 8000, и данные идут на машину <replaceable>intermediary</replaceable> перед тем, как направиться на <replaceable>server</replaceable> в «публичной» сети. Во втором случае вход и выход из туннеля меняются местами; входом является порт 8000 на машине <replaceable>intermediary</replaceable>, а выход расположен на локальном узле, и данные затем направляются на <replaceable>server</replaceable>. На практике сервером обычно является либо локальная машина, либо промежуточная. В таком случае SSH защищает соединение от одного конца до другого."

msgid "Forwarding a local port with SSH"
msgstr "Перенаправление локального порта с помощью SSH"

msgid "Forwarding a remote port with SSH"
msgstr "Перенаправление удалённого порта с помощью SSH"

msgid "Using Remote Graphical Desktops"
msgstr "Использование удалённых графических рабочих столов"

msgid "VNC (Virtual Network Computing) allows remote access to graphical desktops."
msgstr "VNC (Virtual Network Computing - Виртуальный Сетевой Компьютер) позволяет удалённо получить доступ к графическим столам пользователей."

msgid "<primary>VNC</primary>"
msgstr "<primary>VNC</primary>"

#, fuzzy
#| msgid "<primary>Virtual Network Computing</primary>"
msgid "<primary>Virtual Network Computing</primary><seealso>VNC</seealso>"
msgstr "<primary>Virtual Network Computing</primary>"

msgid "<primary>graphical desktop</primary><secondary>remote</secondary>"
msgstr "<primary>графический рабочий стол</primary><secondary>удалённый</secondary>"

msgid "<primary>remote graphical desktop</primary>"
msgstr "<primary>удалённый графический рабочий стол</primary>"

msgid "<primary>desktop, remote graphical desktop</primary>"
msgstr "<primary>рабочий стол, удалённый графический</primary>"

msgid "This tool is mostly used for technical assistance; the administrator can see the errors that the user is facing, and show them the correct course of action without having to stand by them."
msgstr "Этот инструмент используется в основном для технической помощи; администратор может видеть ошибки, с которыми сталкивается пользователь, и показывать ему правильный путь их решения без необходимости стоять у него за спиной."

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary>VNC</primary><secondary>server</secondary>"
msgstr "<primary>владелец</primary><secondary>пользователь</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>server</primary><secondary>VNC</secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">vino</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">krfb</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">krfb</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">krfb</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">x11vnc</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">tightvncserver</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">tigervnc-standalone-server</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

#, fuzzy
#| msgid "First, the user must authorize sharing their session. The GNOME graphical desktop environment in <emphasis role=\"distribution\">Jessie</emphasis> includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). KDE still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon."
msgid "First, the user must authorize sharing their session. The GNOME graphical desktop environment includes that option via <menuchoice> <guimenu>Settings</guimenu> <guimenuitem>Sharing</guimenuitem> </menuchoice> (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). For this to work <emphasis role=\"pkg\">network-manager</emphasis> must be managing the network used (e.g. enable the <literal>managed</literal> mode for devices handled by <emphasis role=\"pkg\">ifupdown</emphasis> in <filename>/etc/NetworkManager/NetworkManager.conf</filename>). KDE Plasma still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> or <command>tightvncserver</command> commands (from the Debian packages of the same name) or <command>tigervncserver</command> (<emphasis role=\"pkg\">tigervnc-standalone-server</emphasis>) serve the same purpose and provide the <emphasis role=\"pkg\">vnc-server</emphasis> virtual package; you can make either of them available to the user with an explicit menu or desktop entry."
msgstr "Для начала, пользователь должен разрешить доступ к сессии. Графическая среда GNOME в <emphasis role=\"distribution\">Jessie</emphasis> включает эту возможность (на конфигурационной панели, хотя в предыдущих выпусках Debian пользователь должен был устанавливать и запускать <command>vino</command>). В KDE нужно использовать <command>krfb</command> для предоставления доступа к существующей сессии через VNC. Для остальных сред следует использовать команду (пакет имеет аналогичное название) <command>x11vnc</command>; для пользователя, вы можете создать значок для запуска."

#, fuzzy
#| msgid "<primary>link</primary><secondary>hard link</secondary>"
msgid "<primary>VNC</primary><secondary>client</secondary>"
msgstr "<primary>ссылка</primary><secondary>жёсткая ссылка</secondary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vinagre</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">krdc</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">xtightvncviewer</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">tigervnc-viewer</emphasis></primary><seealso>VNC</seealso>"
msgstr "<primary><emphasis role=\"pkg\">xvnc4viewer</emphasis></primary>"

#, fuzzy
#| msgid "When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while KDE includes <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xvnc4viewer</command> in the Debian package of the same name. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed."
msgid "When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while the KDE project provides <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xtightvncviewer</command> from the homonym package or <command>xtigervncviewer</command> from the <emphasis role=\"pkg\">tigervnc-viewer</emphasis> Debian package. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed."
msgstr "Когда всё готово для VNC, администратор должен использовать VNC-клиент для соединения. GNOME использует <command>vinagre</command> и <command>remmina</command>, KDE использует <command>krdc</command> (в меню <menuchoice> <guimenu>K</guimenu> <guisubmenu>Интернет</guisubmenu> <guimenuitem>Клиент удалённого рабочего стола</guimenuitem></menuchoice>). Существуют другие VNC-клиенты, использующие консоль, например <command>xvnc4viewer</command> — пакет Debian имеет такое же название. После подключения, администратор может видеть что происходит, работать на машине удалённо и показать пользователю как действовать."

msgid "<emphasis>SECURITY</emphasis> VNC over SSH"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> VNC через SSH"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><secondary>VNC</secondary>"
msgid "<primary>tunnel</primary><secondary>VNC</secondary>"
msgstr "<primary>SSH-туннель</primary><secondary>VNC</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>SSH</primary><secondary>tunnel</secondary><tertiary>VNC</tertiary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

#, fuzzy
#| msgid "<primary><command>init</command></primary>"
msgid "<primary><command>vncviewer</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "If you want to connect by VNC, and you don't want your data sent in clear text on the network, it is possible to encapsulate the data in an SSH tunnel (see <xref linkend=\"sect.ssh-port-forwarding\" />). You simply have to know that VNC uses port 5900 by default for the first screen (called “localhost:0”), 5901 for the second (called “localhost:1”), etc."
msgstr "Если хочется подключиться по VNC, но так, чтобы данные не передавались по сети в открытом виде, можно энкапсулировать их в SSH-туннель (см. <xref linkend=\"sect.ssh-port-forwarding\" />). Для этого нужно только знать, что по умолчанию VNC использует порт 5900 для первого экрана (называемого «localhost:0»), 5901 — для второго (называемого «localhost:1») и т. д."

msgid "The <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> command creates a tunnel between local port 5901 in the localhost interface and port 5900 of the <replaceable>machine</replaceable> host. The first “localhost” restricts SSH to listening to only that interface on the local machine. The second “localhost” indicates the interface on the remote machine which will receive the network traffic entering in “localhost:5901”. Thus <command>vncviewer localhost:1</command> will connect the VNC client to the remote screen, even though you indicate the name of the local machine."
msgstr "Команда <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> создаёт туннель между портом 5901 локального интерфейса и портом 5900 узла <replaceable>machine</replaceable>. Первое слово «localhost» указывает SSH, что надо слушать только этот интерфейс на локальной машине. Второе вхождение «localhost» указывает интерфейс на удалённой машине, который будет получать трафик, входящий в «localhost:5901». В таком случае команда <command>vncviewer localhost:1</command> установит подключение клиента VNC к удалённому экрану, хотя ей и указано имя локальной машины."

msgid "When the VNC session is closed, remember to close the tunnel by also quitting the corresponding SSH session."
msgstr "После закрытия сессии VNC не забудьте также закрыть туннель путём выхода из соответствующей сессии SSH."

msgid "<emphasis>BACK TO BASICS</emphasis> Display manager"
msgstr "<emphasis>К ОСНОВАМ</emphasis> Менеджер дисплея"

msgid "<primary><command>gdm3</command></primary>"
msgstr "<primary><command>gdm3</command></primary>"

msgid "<primary><command>kdm</command></primary>"
msgstr "<primary><command>kdm</command></primary>"

msgid "<primary><command>xdm</command></primary>"
msgstr "<primary><command>xdm</command></primary>"

msgid "<primary><command>lightdm</command></primary>"
msgstr "<primary><command>lightdm</command></primary>"

msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgstr "<primary>менеджер</primary><secondary>дисплея</secondary>"

msgid "<primary>display manager</primary>"
msgstr "<primary>дисплейный менеджер</primary>"

#, fuzzy
#| msgid "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, and <command>xdm</command> are Display Managers. They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session."
msgid "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, and <command>xdm</command> are Display Managers (they all provide the <emphasis role=\"pkg\">x-display-manager</emphasis> meta package). They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session."
msgstr "<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, и <command>xdm</command> — менеджеры рабочего стола. Они используются для регистрации пользователей, запускаются после загрузки системы и используют графический интерфейс. После регистрации пользователя, они запускают программы, необходимые для запуска рабочей графической сессии."

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/gdm3/daemon.conf</filename></secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/inetd.conf</filename></secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

msgid "Managing Rights"
msgstr "Управление правами"

msgid "<primary>permissions</primary>"
msgstr "<primary>разрешения</primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>rights</primary><seealso>permissions</seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>device</primary><secondary>files</secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "Linux is definitely a multi-user system, so it is necessary to provide a permission system to control the set of authorized operations on files and directories, which includes all the system resources and devices (on a Unix system, any device is represented by a file or directory). This principle is common to all Unix systems, but a reminder is always useful, especially as there are some interesting and relatively unknown advanced uses."
msgstr "Linux — многопользовательская система, поэтому она должна предоставлять систему разрешений, чтобы контролировать авторизованные операции с файлами и каталогами, к которым относятся все системные ресурсы и устройства (в Unix-системах любое устройство представляется в виде файла или каталога). Этот принцип является общим для всех Unix-систем, но напомнить об этом ещё раз будет не лишним, тем более что существуют некоторые интересные и сравнительно малоизвестные способы применения."

#, fuzzy
#| msgid "Permissions"
msgid "Owners and Permissions"
msgstr "Привилегии"

msgid "<primary>user</primary><secondary>owner</secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "<primary>group</primary><secondary>owner</secondary>"
msgstr "<primary>группа</primary><secondary>владелец</secondary>"

msgid "<primary>owner</primary><secondary>user</secondary>"
msgstr "<primary>владелец</primary><secondary>пользователь</secondary>"

msgid "<primary>owner</primary><secondary>group</secondary>"
msgstr "<primary>владелец</primary><secondary>группа</secondary>"

msgid "Each file or directory has specific permissions for three categories of users:"
msgstr "У каждого файла и каталога имеются специальные разрешения для трёх категорий пользователей:"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary>permissions</primary><secondary><literal>u</literal></secondary>"
msgstr "<primary>владелец</primary><secondary>пользователь</secondary>"

msgid "its owner (symbolized by <literal>u</literal> as in “user”);"
msgstr "его владельца (обозначается <literal>u</literal>, от «user»);"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>permissions</primary><secondary><literal>g</literal></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "its owner group (symbolized by <literal>g</literal> as in “group”), representing all the members of the group;"
msgstr "его группы-владельца (обозначается <literal>g</literal>, от «group»), представленная всеми членами группы;"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>permissions</primary><secondary><literal>o</literal></secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "the others (symbolized by <literal>o</literal> as in “other”)."
msgstr "остальных (обозначается <literal>o</literal>, от «other»)."

#, fuzzy
#| msgid "Three types of rights can be combined:"
msgid "Three basic types of rights can be combined:"
msgstr "Три типа прав могут использоваться совместно:"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>permissions</primary><secondary><literal>r</literal></secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

msgid "reading (symbolized by <literal>r</literal> as in “read”);"
msgstr "чтение (обозначается <literal>r</literal>, от «read»);"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>permissions</primary><secondary><literal>w</literal></secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "writing (or modifying, symbolized by <literal>w</literal> as in “write”);"
msgstr "запись (или изменение, обозначается <literal>w</literal>, от «write»);"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>permissions</primary><secondary><literal>x</literal></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "executing (symbolized by <literal>x</literal> as in “eXecute”)."
msgstr "исполнение (обозначается <literal>x</literal>, от «eXecute»)."

msgid "<primary>read, right</primary>"
msgstr "<primary>чтение, право</primary>"

msgid "<primary>write, right</primary>"
msgstr "<primary>запись, право</primary>"

msgid "<primary>modification, right</primary>"
msgstr "<primary>изменение, право</primary>"

msgid "<primary>execution, right</primary>"
msgstr "<primary>исполнение, право</primary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>permissions</primary><secondary>read</secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>permissions</primary><secondary>write</secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary>permissions</primary><secondary>execute</secondary>"
msgstr "<primary>владелец</primary><secondary>пользователь</secondary>"

msgid "In the case of a file, these rights are easily understood: read access allows reading the content (including copying), write access allows changing it, and execute access allows you to run it (which will only work if it is a program)."
msgstr "По отношению к файлу, такие права хорошо понятны: доступ для чтения позволяет читать содержимое (включая копирование), доступ для записи позволяет менять содержимое, доступ для исполнения позволяет запускать (работает для программ)."

msgid "<emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> исполняемые файлы с <literal>setuid</literal> и <literal>setgid</literal>"

#, fuzzy
#| msgid "<emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables"
msgid "<primary>permissions</primary><secondary><literal>setuid</literal></secondary><seealso><literal>setuid</literal></seealso>"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> исполняемые файлы с <literal>setuid</literal> и <literal>setgid</literal>"

#, fuzzy
#| msgid "<emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables"
msgid "<primary>permissions</primary><secondary><literal>setgid</literal></secondary><seealso><literal>setgid</literal></seealso>"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> исполняемые файлы с <literal>setuid</literal> и <literal>setgid</literal>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>permissions</primary><secondary><literal>s</literal></secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

#, fuzzy
#| msgid "Two particular rights are relevant to executable files: <literal>setuid</literal> and <literal>setgid</literal> (symbolized with the letter “s”). Note that we frequently speak of “bit”, since each of these boolean values can be represented by a 0 or a 1. These two rights allow any user to execute the program with the rights of the owner or the group, respectively. This mechanism grants access to features requiring higher level permissions than those you would usually have."
msgid "Two particular rights are relevant to executable files: <literal>setuid</literal> and <literal>setgid</literal> (symbolized with the letter “s”). Note that we frequently speak of “bit”, since each of these Boolean values can be represented by a 0 or a 1. These two rights allow any user to execute the program with the rights of its owner or its group, respectively. This mechanism grants access to features requiring higher level permissions than those you would usually have."
msgstr "Два своеобразных права имеют смысл для исполняемых файлов: <literal>setuid</literal> и <literal>setgid</literal> (обозначаются буквой «s»). Обратите внимание, что они часто называются «битами», поскольку каждое из этих логических значений может быть представлено как 0 или 1. Эти два права позволяют любому пользователю выполнять программу на правах её владельца или группы соответственно. Данный механизм предоставляет доступ к функциям, требующим разрешений более высокого уровня, чем обычно есть у пользователя."

msgid "<primary><literal>setuid</literal>, right</primary>"
msgstr "<primary><literal>setuid</literal>, право</primary>"

msgid "<primary><literal>setgid</literal>, right</primary>"
msgstr "<primary><literal>setgid</literal>, право</primary>"

msgid "Since a <literal>setuid</literal> root program is systematically run under the super-user identity, it is very important to ensure it is secure and reliable. Indeed, a user who would manage to subvert it to call a command of their choice could then impersonate the root user and have all rights on the system."
msgstr "Поскольку <literal>setuid</literal>-программа, принадлежащая root, систематически запускается с правами суперпользователя, крайне важно убедиться в её безопасности и надёжности. Действительно, пользователь, которому удастся заставить её вызвать другую произвольную программу, сможет представиться как root и получить все права в системе."

#, fuzzy
#| msgid "<primary><command>scp</command></primary>"
msgid "<primary><command>su</command></primary>"
msgstr "<primary><command>scp</command></primary>"

#, fuzzy
#| msgid "<primary><command>scp</command></primary>"
msgid "<primary><command>sudo</command></primary>"
msgstr "<primary><command>scp</command></primary>"

#, fuzzy
#| msgid "<primary><command>rsh</command></primary>"
msgid "<primary><command>runuser</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

msgid "If you require running a program under a different user or if a program requires higher permissions, the <command>sudo</command>, <command>su</command>, or <command>runuser</command> commands are usually better choices than using these bits (see <xref linkend=\"sect.sharing-admin-rights\" />)."
msgstr ""

msgid "A directory is handled differently. Read access gives the right to consult the list of its entries (files and directories), write access allows creating or deleting files, and execute access allows crossing through it (especially to go there with the <command>cd</command> command). Being able to cross through a directory without being able to read it gives permission to access the entries therein that are known by name, but not to find them if you do not know their existence or their exact name."
msgstr "Каталоги обрабатываются иначе. Доступ на чтение даёт право получить список его содержимого (файлов и каталогов), доступ на запись позволяет создавать и удалять файлы, а доступ на исполнение позволяет проходить через него (в частности переходить в него с помощью команды <command>cd</command>). Возможность проходить через каталог, не имея возможности прочесть его, позволяет получить доступ к файлам внутри него, если они известны по имени, но не находить их, если о их существовании или их точных именах не известно."

msgid "<emphasis>SECURITY</emphasis> <literal>setgid</literal> directory and <emphasis>sticky bit</emphasis>"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> Каталог с <literal>setgid</literal> и <emphasis>sticky bit</emphasis>"

msgid "<primary><literal>setgid</literal> directory</primary>"
msgstr "<primary><literal>setgid</literal>-каталог</primary>"

msgid "The <literal>setgid</literal> bit also applies to directories. Any newly-created item in such directories is automatically assigned the owner group of the parent directory, instead of inheriting the creator's main group as usual. This setup avoids the user having to change its main group (with the <command>newgrp</command> command) when working in a file tree shared between several users of the same dedicated group."
msgstr "Бит <literal>setgid</literal> применим и к каталогам. Любой вновь созданный файл внутри таких каталогов автоматически присваивается группе-владельцу родительского каталога вместо того, чтобы унаследовать основную группу создателя, как происходит обычно. Эта настройка позволяет пользователю не изменять свою основную группу (с помощью команды <command>newgrp</command>) при работе в дереве файлов, общих для нескольких пользователей из одной конкретной группы."

#, fuzzy
#| msgid "<primary><command>chgrp</command></primary>"
msgid "<primary><command>newgrp</command></primary>"
msgstr "<primary><command>chgrp</command></primary>"

msgid "<primary>sticky bit</primary>"
msgstr "<primary>sticky bit</primary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>permissions</primary><secondary><literal>t</literal></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "The “sticky” bit (symbolized by the letter “t”) is a permission that is only useful in directories. It is especially used for temporary directories where everybody has write access (such as <filename>/tmp/</filename>): it restricts deletion of files so that only their owner (or the owner of the parent directory) can do it. Lacking this, everyone could delete other users' files in <filename>/tmp/</filename>."
msgstr "Так называемый «sticky bit» (обозначаемый буквой «t») является разрешением, имеющим смысл только для каталогов. Он, в частности, используется для временных каталогов, куда у всех есть доступ на запись (например <filename>/tmp/</filename>): он ограничивает возможность удаления файлов, так что только их владелец (или владелец родительского каталога) может это сделать. Если бы данной функции не было, любой мог бы удалить файлы других пользователей в <filename>/tmp/</filename>."

msgid "Three commands control the permissions associated with a file:"
msgstr "Три команды для управления разрешениями, связанными с файлом:"

msgid "<primary><command>chown</command></primary>"
msgstr "<primary><command>chown</command></primary>"

msgid "<command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command> changes the owner of the file;"
msgstr "<command>chown <replaceable>пользователь</replaceable> <replaceable>файл</replaceable></command> изменяет владельца файла;"

msgid "<primary><command>chgrp</command></primary>"
msgstr "<primary><command>chgrp</command></primary>"

msgid "<command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command> alters the owner group;"
msgstr "<command>chgrp <replaceable>группа</replaceable> <replaceable>файл</replaceable></command> меняет группу-владельца;"

msgid "<primary><command>chmod</command></primary>"
msgstr "<primary><command>chmod</command></primary>"

msgid "<command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command> changes the permissions for the file."
msgstr "<command>chmod <replaceable>права</replaceable> <replaceable>файл</replaceable></command> изменяет разрешения на файл."

#, fuzzy
#| msgid "<primary>octal representation of rights</primary>"
msgid "<primary>symbolic representation of rights</primary>"
msgstr "<primary>восьмеричное представление прав</primary>"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgid "<primary>rights</primary><secondary>symbolic representation</secondary>"
msgstr "<primary>права</primary><secondary>восьмеричное представление</secondary>"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgid "<primary>permissions</primary><secondary>symbolic representation</secondary>"
msgstr "<primary>права</primary><secondary>восьмеричное представление</secondary>"

msgid "There are two ways of presenting rights. Among them, the symbolic representation is probably the easiest to understand and remember. It involves the letter symbols mentioned above. You can define rights for each category of users (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), by setting them explicitly (with <literal>=</literal>), by adding (<literal>+</literal>), or subtracting (<literal>-</literal>). Thus the <literal>u=rwx,g+rw,o-r</literal> formula gives the owner read, write, and execute rights, adds read and write rights for the owner group, and removes read rights for other users. Rights not altered by the addition or subtraction in such a command remain unmodified. The letter <literal>a</literal>, for “all”, covers all three categories of users, so that <literal>a=rx</literal> grants all three categories the same rights (read and execute, but not write)."
msgstr "Есть два способа представления прав. Из них символьное, пожалуй, более легко для понимания и запоминания. В нём используются указанные выше символы. Можно определить права для каждой категории пользователей (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), присвоив их явно (с помощью <literal>=</literal>), добавив (<literal>+</literal>) или отняв (<literal>-</literal>). Так, выражение <literal>u=rwx,g+rw,o-r</literal> даёт владельцу права на чтение, запись и исполнение, добавляет права на чтение и запись для группы-владельца и отнимает право на чтение у остальных пользователей. Права, не затрагиваемые добавлением или отъёмом, остаются без изменений. Буква <literal>a</literal> (от «all») обозначает все три категории пользователей, так что <literal>a=rx</literal> даёт всем трём категориям одинаковые права (читать и исполнять, но не записывать)."

msgid "<primary>octal representation of rights</primary>"
msgstr "<primary>восьмеричное представление прав</primary>"

msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgstr "<primary>права</primary><secondary>восьмеричное представление</secondary>"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgid "<primary>permissions</primary><secondary>octal representation</secondary>"
msgstr "<primary>права</primary><secondary>восьмеричное представление</secondary>"

msgid "The (octal) numeric representation associates each right with a value: 4 for read, 2 for write, and 1 for execute. We associate each combination of rights with the sum of the figures. Each value is then assigned to different categories of users by putting them end to end in the usual order (owner, group, others)."
msgstr "В цифровом (восьмеричном) представлении каждому праву соответствует конкретное значение: 4 — чтению, 2 — записи, 1 — исполнению. Каждая комбинация прав соответствует сумме этих чисел. Каждое значение затем присваивается своей категории пользователей, будучи записанным подряд с остальными в обычном порядке (владелец, группа, остальные)."

#, fuzzy
#| msgid "For instance, the <command>chmod 754 <replaceable>file</replaceable></command> command will set the following rights: read, write and execute for the owner (since 7 = 4 + 2 + 1); read and execute for the group (since 5 = 4 + 1); read-only for others. The <literal>0</literal> means no rights; thus <command>chmod 600 <replaceable>file</replaceable></command> allows for read/write rights for the owner, and no rights for anyone else. The most frequent right combinations are <literal>755</literal> for executable files and directories, and <literal>644</literal> for data files."
msgid "For instance, the <command>chmod 754 <replaceable>file</replaceable></command> command will set the following rights: read, write and execute for the owner (since 7 = 4 + 2 + 1); read and execute for the group (since 5 = 4 + 1); read-only for others. The <literal>0</literal> (zero) means no rights; thus <command>chmod 600 <replaceable>file</replaceable></command> allows for read/write rights for the owner, and no rights for anyone else. The most frequent right combinations are <literal>755</literal> for executable files and directories, and <literal>644</literal> for data files."
msgstr "Например, команда <command>chmod 754 <replaceable>файл</replaceable></command> установит следующие права: на чтение, запись и исполнение для владельца (поскольку 7 = 4 + 2 + 1); на чтение и исполнение для группы (поскольку 5 = 4 + 1); только на чтение для остальных. <literal>0</literal> означает отсутствие прав, так что <command>chmod 600 <replaceable>файл</replaceable></command> разрешает чтение и запись владельцу и не даёт никаких прав всем остальным. Наиболее распространённые комбинации прав — <literal>755</literal> для исполняемых файлов и каталогов и <literal>644</literal> для файлов с данными."

#, fuzzy
#| msgid "<primary><literal>setuid</literal>, right</primary>"
msgid "<primary><literal>setuid</literal></primary>"
msgstr "<primary><literal>setuid</literal>, право</primary>"

#, fuzzy
#| msgid "<primary><literal>setgid</literal>, right</primary>"
msgid "<primary><literal>setgid</literal></primary>"
msgstr "<primary><literal>setgid</literal>, право</primary>"

msgid "To represent special rights, you can prefix a fourth digit to this number according to the same principle, where the <literal>setuid</literal>, <literal>setgid</literal> and <literal>sticky</literal> bits are 4, 2 and 1, respectively. <command>chmod 4754</command> will associate the <literal>setuid</literal> bit with the previously described rights."
msgstr "Для представления в таком виде специальных прав можно указать в начале четвёртую цифру в соответствии с тем же принципом, где битам <literal>setuid</literal>, <literal>setgid</literal> <literal>sticky</literal> соответствуют 4, 2 и 1. <command>chmod 4754</command> установит бит <literal>setuid</literal> наравне с вышеописанными правами."

msgid "Note that the use of octal notation only allows to set all the rights at once on a file; you cannot use it to simply add a new right, such as read access for the group owner, since you must take into account the existing rights and compute the new corresponding numerical value."
msgstr "Заметьте, что для восьмеричного представления возможна только установка всех прав сразу, нельзя добавить новое правило, как например, доступ для чтения для владельца группы — пользователь должен, учитывая существующие права, вычислить новое соответствующее значение."

msgid "<emphasis>TIP</emphasis> Recursive operation"
msgstr "<emphasis>СОВЕТ</emphasis> Рекурсивная работа"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>octal representation</secondary>"
msgid "<primary>permissions</primary><secondary>recursive operation</secondary>"
msgstr "<primary>права</primary><secondary>восьмеричное представление</secondary>"

msgid "Sometimes we have to change rights for an entire file tree. All the commands above have a <literal>-R</literal> option to operate recursively in sub-directories."
msgstr "Иногда требуется изменить права для целого дерева файлов. У всех вышеуказанных команд есть опция <literal>-R</literal>, при использовании которой программа рекурсивно обходит подкаталоги."

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>permissions</primary><secondary><literal>X</literal></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

#, fuzzy
#| msgid "The distinction between directories and files sometimes causes problems with recursive operations. That is why the “X” letter has been introduced in the symbolic representation of rights. It represents a right to execute which applies only to directories (and not to files lacking this right). Thus, <command>chmod -R a+X <replaceable>directory</replaceable></command> will only add execute rights for all categories of users (<literal>a</literal>) for all of the sub-directories and files for which at least one category of user (even if their sole owner) already has execute rights."
msgid "The distinction between directories and files sometimes causes problems with recursive operations. That is why the “<literal>X</literal>” letter has been introduced in the symbolic representation of rights. It also represents the right to execute, but it applies differently to directories and files."
msgstr "Из-за различия между каталогами и файлами иногда случаются проблемы с рекурсивными операциями. Поэтому была дополнительно введена ещё одна опция прав доступа - буква “X”, которая правильно работает с символическими ссылками, имеющимися в каталоге. Она добавляет права доступа некоторым файлам в заданном каталоге (и не затрагивает другие файлы, которые имеют недостаточно прав). Таким образом, <command>chmod -R a+X <replaceable>directory</replaceable></command> добавит для всех подкаталогов и файлов, для которых ужѐ были ранее установлены права доступа на выполнение хотя бы для одной из категории пользователей (u - владелец, g - группа, o - другие), права выполнения для всех категорий пользователей (<literal>a</literal>)."

msgid "For directories it adds executable permissions to the chosen user(s). For files, it adds the executable bit <emphasis>only</emphasis> if at least one of the users (owner, group, or others) already has executable permissions. Let's demonstrate it, because this bit can be confusing:"
msgstr ""

msgid ""
"<computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rw-r--r-- 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  <computeroutput>$ </computeroutput><userinput>chmod u+X test.txt</userinput>\n"
"  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rw-r--r-- 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  <computeroutput>$ </computeroutput><userinput>chmod o+x test.txt</userinput>\n"
"  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rw-r--r-x 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  <computeroutput>$ </computeroutput><userinput>chmod u+X test.txt</userinput>\n"
"  <computeroutput>$ </computeroutput><userinput>ls test.txt</userinput>\n"
"  <computeroutput>-rwxr--r-x 1 daniel daniel 0 18. Nov 01:07 test.txt</computeroutput>\n"
"  "
msgstr ""

msgid "The example shows a typical file with its default permissions: its owner can read and write it, the owner's group and all other users can read it. The next operation (<literal>u+X</literal>) won't add executable permissions for the owner of the file, because permissions to execute have not been assigned. The operation has no effect on the file. Next we assign execute rights for \"other\" users and repeat the operation. This time it is successful, because at least one user group already had executable permissions."
msgstr ""

msgid "It is a misconception that this bit will only affect directories. If files and directories have mixed permissions, it is often a good idea to use the <command>find</command> command to locate the targets you want to operate on."
msgstr ""

#, fuzzy
#| msgid "<emphasis>TIP</emphasis> Changing the user and group"
msgid "<emphasis>TIP</emphasis> Changing the user and group together"
msgstr "<emphasis>СОВЕТ</emphasis> Смена пользователя и группы"

#, fuzzy
#| msgid "Frequently you want to change the group of a file at the same time that you change the owner. The <command>chown</command> command has a special syntax for that: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>"
msgid "Frequently you want to change the group of a file at the same time that you change the owner. The <command>chown</command> command has a special syntax for that: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>. This syntax can also be used to recursively (<literal>-R</literal>) change the ownership of a whole directory."
msgstr "Часто приходится одновременно выполнять две операции: изменить принадлежность файла к какой-то группе и сменить его владельца. Команда <command>chown</command> имеет специальный синтаксис для таких случаев: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>"

msgid "<emphasis>GOING FURTHER</emphasis> <command>umask</command>"
msgstr "<emphasis>УГЛУБЛЯЕМСЯ</emphasis> <command>umask</command>"

#, fuzzy
#| msgid "<primary><command>at</command></primary>"
msgid "<primary><command>umask</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "When an application creates a file, it assigns indicative permissions, knowing that the system automatically removes certain rights, given by the command <command>umask</command>. Enter <command>umask</command> in a shell; you will see a mask such as <computeroutput>0022</computeroutput>. This is simply an octal representation of the rights to be systematically removed (in this case, the write right for the group and other users)."
msgid "When an application creates a file, it assigns indicative permissions, knowing that the system automatically removes certain rights, given by the command <command>umask</command>. Enter <command>umask</command> in a shell; you will see a mask such as <computeroutput>0022</computeroutput>. This is simply an octal representation of the rights to be systematically removed. In this case, the write right for the group and other users: With the above umask value, the default for directories <literal>777</literal> becomes <literal>755</literal> and the default permissions for files <literal>666</literal> become <literal>644</literal>."
msgstr "Когда приложение создаёт файл, оно присваивает ему ориентировочные разрешения, зная, что система автоматически удаляет некоторые права, заданные командой <command>umask</command>. Введите <command>umask</command> в командной оболочке; вы увидите маску наподобие <computeroutput>0022</computeroutput>. Это всего лишь восьмеричное представление прав, которые методично удаляются (в данном случае — право записи для группы и для остальных пользователей)."

msgid "<primary>rights</primary><secondary>mask</secondary>"
msgstr "<primary>права</primary><secondary>маска</secondary>"

#, fuzzy
#| msgid "<primary>rights</primary><secondary>mask</secondary>"
msgid "<primary>permissions</primary><secondary>umask</secondary>"
msgstr "<primary>права</primary><secondary>маска</secondary>"

msgid "<primary>mask</primary><secondary>rights mask</secondary>"
msgstr "<primary>маска</primary><secondary>маска прав</secondary>"

#, fuzzy
#| msgid "All these details are documented in the <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgid "The system's default value is handled by <citerefentry><refentrytitle>pam_umask</refentrytitle> <manvolnum>8</manvolnum></citerefentry> and <filename>/etc/login.defs</filename>."
msgstr "Все эти подробности описаны на странице man <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/login.defs</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

#, fuzzy
#| msgid "If you give it a new octal value, the <command>umask</command> command modifies the mask. Used in a shell initialization file (for example, <filename>~/.bash_profile</filename>), it will effectively change the default mask for your work sessions."
msgid "If you give it a new octal value, the <command>umask</command> command modifies the mask. Used in a shell initialization file (for example, <filename>~/.bashrc</filename> or <filename>~/.profile</filename>), it will effectively change the default mask for your work sessions."
msgstr "Если передать ей новое восьмеричное значение, команда <command>umask</command> изменяет маску. При использовании в файле инициализации оболочки (например <filename>~/.bash_profile</filename>) она изменит маску во всех пользовательских сессиях."

msgid "ACLs - Access Control Lists"
msgstr ""

#, fuzzy
#| msgid "<primary>ACPI</primary>"
msgid "<primary>ACL</primary>"
msgstr "<primary>ACPI</primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>Access Control List</primary><see>ACL</see>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">acl</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">krdc</emphasis></primary>"

msgid "Many filesystems, e.g. Btrfs, Ext3, Ext4, JFS, XFS, etc., support the use of Access Control Lists (ACLs). These extend the basic features of file ownership and permission, described in the previous section, and allow for a more fine-grained control of each (file) object. For example: A user wants to share a file with another user and that user should only be able to read the file, but not write or change it."
msgstr ""

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/fstab</filename></secondary>"
msgstr "<primary>менеджер</primary><secondary>дисплея</secondary>"

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary>ACL</primary><secondary><literal>acl</literal></secondary>"
msgstr "<primary>клиент</primary><secondary>клиент-серверная архитектура</secondary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>ACL</primary><secondary><literal>noacl</literal></secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "For some of the filesystems, the usage of ACLs is enabled by default (e.g. Btrfs, Ext3, Ext4). For other filesystems or older systems it must be enabled using the <literal>acl</literal> mount option - either in the <command>mount</command> command directly or in <filename>/etc/fstab</filename>. In the same way the usage of ACLs can be disabled by using the <literal>noacl</literal> mount option. For Ext* filesystems one can also use the <command>tune2fs -o [no]acl /dev/<replaceable>device</replaceable></command> command to enable/disable the usage of ACLs by default. The default values for each filesystem can usually be found in their homonym manual pages in section 5 (<citerefentry><refentrytitle><replaceable>filesystem</replaceable></refentrytitle> <manvolnum>5</manvolnum></citerefentry>) or in <citerefentry><refentrytitle>mount</refentrytitle> <manvolnum>8</manvolnum></citerefentry>."
msgstr ""

msgid "After enabling ACLs, permissions can be set using the <citerefentry><refentrytitle>setfacl</refentrytitle> <manvolnum>1</manvolnum></citerefentry> command, while <citerefentry><refentrytitle>getfacl</refentrytitle> <manvolnum>1</manvolnum></citerefentry> allows one to retrieve the ACLs for a given object or path. These commands are part of the <emphasis role=\"pkg\">acl</emphasis> package. With <command>setfacl</command> one can also configure newly created files or directories to inherit permissions from the parent directory. It is important to note that ACLs are processed in their order and that an earlier entry that fits the situation has precedence over later entries."
msgstr ""

msgid "If a file has ACLs set, the output of the <command>ls -l</command> command will show a plus-sign after the traditional permissions. When using ACLs, the <command>chmod</command> command behaves slightly different, and <command>umask</command> might be ignored. The extensive documentation, e.g. <citerefentry><refentrytitle>acl</refentrytitle> <manvolnum>5</manvolnum></citerefentry> contains more information."
msgstr ""

msgid "Administration Interfaces"
msgstr "Интерфейсы для администрирования"

msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

msgid "<primary>administration, interfaces</primary>"
msgstr "<primary>административные интерфейсы</primary>"

msgid "Using a graphical interface for administration is interesting in various circumstances. An administrator does not necessarily know all the configuration details for all their services, and doesn't always have the time to go seeking out the documentation on the matter. A graphical interface for administration can thus accelerate the deployment of a new service. It can also simplify the setup of services which are hard to configure."
msgstr "Использование графического интерфейса для администрирования представляет интерес при разных обстоятельствах. Администратор не обязательно знает все подробности настройки всех своих сервисов, и у него не всегда есть время на поиск документации по этой теме. В таком случае графический интерфейс может ускорить развёртывание нового сервиса. Он также упрощает настройку сервисов, конфигурирование которых слишком сложно."

msgid "Such an interface is only an aid, and not an end in itself. In all cases, the administrator must master its behavior in order to understand and work around any potential problem."
msgstr "Такой интерфейс является лишь вспомогательным средством, а не самоцелью. В любом случае администратор должен освоить его, чтобы суметь понять и обойти любую потенциальную проблему."

msgid "Since no interface is perfect, you may be tempted to try several solutions. This is to be avoided as much as possible, since different tools are sometimes incompatible in their work methods. Even if they all aim to be very flexible and try to adopt the configuration file as a single reference, they are not always able to integrate external changes."
msgstr "Поскольку нет идеальных интерфейсов, у вас может появиться соблазн попробовать несколько разных решений. Насколько это возможно, таких ситуаций следует избегать, потому что различные средства иногда несовместимы в их методах работы. Даже если они все нацелены быть очень гибкими и пытаются адаптирровать свой файл настройки как единственный, рекомендованый для вашей системы, они не всегда имеют возможность учитывать и включать в себя ещё и внешние изменения."

msgid "Administrating on a Web Interface: <command>webmin</command>"
msgstr "Администрирование через веб-интерфейс: <command>webmin</command>"

msgid "<primary><emphasis>webmin</emphasis></primary>"
msgstr "<primary><emphasis>webmin</emphasis></primary>"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary>administration, interfaces</primary><secondary><emphasis>webmin</emphasis></secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

msgid "This is, without a doubt, one of the most successful administration interfaces. It is a modular system managed through a web browser, covering a wide array of areas and tools. Furthermore, it is internationalized and available in many languages."
msgstr "Это, несомненно, один из самых удачных интерфейсов для администрирования. Это модульная система, управляемая через веб-обозреватель и покрывающая широкий набор областей и инструментов. Кроме того, он интернационализирован и доступен на множестве языков."

msgid "Webmin dashboard"
msgstr ""

#, fuzzy
#| msgid "Sadly, <command>webmin</command> is no longer part of Debian. Its Debian maintainer — Jaldhar H. Vyas — removed the packages he created because he no longer had the time required to maintain them at an acceptable quality level. Nobody has officially taken over, so <emphasis role=\"distribution\">Jessie</emphasis> does not have the <command>webmin</command> package."
msgid "Sadly, <command>webmin</command> is no longer part of Debian. Its Debian maintainer removed the packages created because they no longer had the time required to maintain them at an acceptable quality level. Nobody has officially taken over, so Debian does not provide the <command>webmin</command> package."
msgstr "К сожаленью, программа <command>webmin</command> более не является частью Debian. Его Debian сопровождающий — Jaldhar H. Vyas — убрал пакеты, созданные им ранее, потому что перестал иметь возможность выделять достаточно времени на их поддержание на приемлемом уровне качества. Никто официально не взял на себя ответственность за сопровождение данного пакета далее, поэтому в <emphasis role=\"distribution\">Jessie</emphasis> и нет пакета <command>webmin</command>."

msgid "There is, however, an unofficial package distributed on the <literal>webmin.com</literal> website. Contrary to the original Debian packages, this package is monolithic; all of its configuration modules are installed and activated by default, even if the corresponding service is not installed on the machine."
msgstr "Однако существует неофициальный пакет, распространяемый на сайте <literal>webmin.com</literal>. В отличие от оригинальных пакетов Debian, этот пакет — монолитный; все его конфигурационные модули устанавливаются и включаются по умолчанию, даже если соответствующий сервис не установлен на машине."

msgid "<emphasis>SECURITY</emphasis> Changing the root password"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> Изменение пароля root"

#, fuzzy
#| msgid "On the first login, identification is conducted with the root username and its usual password. It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the root password for the server will not be involved, even if this confers important administrative rights to the machine."
msgid "On the first login, identification is conducted with the root username and its usual password (or any user's login credentials which belongs to the <literal>sudo</literal> group). It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the server's user accounts will not be involved, even if this confers important administrative rights to the machine."
msgstr "Для первого входа идентификация производится для пользователя - администратор с его паролем. Далее настоятельно рекомендуется изменить пароль, используемый для доступа к <command>webmin</command> так быстро, как возможно, потому что если он будет взломан, то пароль администратора для сервера не будет затронут данной компрометацией, даже если взломанный пароль даст значительные административные права на данной машине."

#, fuzzy
#| msgid "Beware! Since <command>webmin</command> has so many features, a malicious user accessing it could compromise the security of the entire system. In general, interfaces of this kind are not recommended for important systems with strong security constraints (firewall, sensitive servers, etc.)."
msgid "Beware! Since <command>webmin</command> has so many features, a malicious user accessing it could compromise the security of the entire system. In general, interfaces of this kind are not recommended for important systems with strong security constraints (firewall, sensitive servers, etc.), and they are not recommended to be exposed to the public either."
msgstr "Будьте осторожны! Поскольку <command>webmin</command> настолько функционален, злоумышленник получивший доступ к нему, может скомпроментировать безопасность всей системы. Как правило, интерфейсы такого рода не рекомендуются к использованию на важных системах со строгими требованиями к безопасности (межсетевых экранах, серверах с ценными данными и т. п.)."

msgid "Webmin is used through a web interface, but it does not require Apache to be installed. Essentially, this software has its own integrated mini web server. This server listens by default on port 10000 and accepts secure HTTP connections."
msgstr "Webmin используется при посредстве веб-интерфейса, но для него не требуется установка Apache. Дело в том, что в его состав входит свой собственный небольшой веб-сервер. Этот сервер по умолчанию слушает порт 10000 и принимает защищённые HTTP-соединения."

msgid "Included modules cover a wide variety of services, among which:"
msgstr "Входящие в поставку модули предназначены для широкого круга сервисов, среди которых:"

#, fuzzy
#| msgid "all base services: creation of users and groups, management of <filename>crontab</filename> files, init scripts, viewing of logs, etc."
msgid "all base services: creation of users and groups, management of <filename>crontab</filename> files, service scripts/files, viewing of logs, etc."
msgstr "все базовые сервисы: создание пользователей и групп, управление файлами <filename>crontab</filename>, сценариями инициализации, отображение журналов и т. п."

msgid "bind: DNS server configuration (name service);"
msgstr "bind: настройка сервера DNS (службы имён);"

msgid "postfix: SMTP server configuration (e-mail);"
msgstr "postfix: настройка SMTP-сервера (e-mail);"

#, fuzzy
#| msgid "inetd: configuration of the <command>inetd</command> super-server;"
msgid "network services: configuration of the <command>xinetd</command> super-server;"
msgstr "inetd: настройка суперсервера <command>inetd</command>;"

#, fuzzy
#| msgid "quota: user quota management;"
msgid "disk quota: user quota management;"
msgstr "quota: управление пользовательскими квотами;"

msgid "dhcpd: DHCP server configuration;"
msgstr "dhcpd: настройка сервера DHCP;"

msgid "proftpd: FTP server configuration;"
msgstr "proftpd: настройка сервера FTP;"

msgid "samba: Samba file server configuration;"
msgstr "samba: Настройка файлового сервера Samba;"

msgid "software: installation or removal of software from Debian packages and system updates."
msgstr "software: установка или удаление программного обеспечения из пакетов Debian и обновлений системы."

msgid "The administration interface is available in a web browser at <literal>https://localhost:10000</literal>. Beware! Not all the modules are directly usable. Sometimes they must be configured by specifying the locations of the corresponding configuration files and some executable files (program). Frequently the system will politely prompt you when it fails to activate a requested module."
msgstr "Административный интерфейс доступен в веб-обозревателе по адресу <literal>https://localhost:10000</literal>. Внимание! Не все модули сразу готовы к использованию. Иногда их надо настроить, указав расположение соответствующих конфигурационных файлов и некоторых исполняемых файлов (программ). Как правило, система любезно напоминает об этом, если не может активировать запрошенный модуль."

msgid "<emphasis>ALTERNATIVE</emphasis> GNOME control center"
msgstr "<emphasis>АЛЬТЕРНАТИВА</emphasis> Центр управления GNOME"

msgid "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">gnome-control-center</emphasis></primary>"

msgid "The GNOME project also provides multiple administration interfaces that are usually accessible via the “Settings” entry in the user menu on the top right. <command>gnome-control-center</command> is the main program that brings them all together but many of the system wide configuration tools are effectively provided by other packages (<emphasis role=\"pkg\">accountsservice</emphasis>, <emphasis role=\"pkg\">system-config-printer</emphasis>, etc.). Although they are easy to use, these applications cover only a limited number of base services: user management, time configuration, network configuration, printer configuration, and so on."
msgstr "Проект GNOME также поддерживает административный интерфейс для множественных настроек, получить доступ к которому можно через вкладку “Настройки” в меню пользователя в правом верхнем углу. Программа <command>gnome-control-center</command> является главной, которая взаимоувязывает их все вместе, но имеется также и много других средств с широким диапазоном настроек системы, включённых в другие пакеты, (<emphasis role=\"pkg\">accountsservice</emphasis>, <emphasis role=\"pkg\">system-config-printer</emphasis>, и т.д.). Несмотря на то, что они просты в использовании, их возможности охватывают ограниченное количество базовых сервисов: управление пользователями, настройка времени, сетевая настройка, настройка принтера, и тому подобное."

msgid "Configuring Packages: <command>debconf</command>"
msgstr "Настройка пакетов: <command>debconf</command>"

#, fuzzy
#| msgid "<primary><command>dpkg-reconfigure</command></primary>"
msgid "<primary><command>debconf</command></primary><seealso><command>dpkg-reconfigure</command></seealso>"
msgstr "<primary><command>dpkg-reconfigure</command></primary>"

#, fuzzy
#| msgid "<primary><command>dpkg-reconfigure</command></primary>"
msgid "<primary><command>dpkg-reconfigure</command></primary><seealso><command>debconf</command></seealso>"
msgstr "<primary><command>dpkg-reconfigure</command></primary>"

#, fuzzy
#| msgid "Many packages are automatically configured after asking a few questions during installation through the Debconf tool. These packages can be reconfigured by running <command>dpkg-reconfigure <replaceable>package</replaceable></command>."
msgid "Many packages are automatically configured after asking a few questions during installation through the Debconf tool. These packages can be reconfigured by running <command>dpkg-reconfigure -p<replaceable>level</replaceable> <replaceable>package</replaceable></command>."
msgstr "Многие пакеты автоматически настраиваются после того, как зададут несколько вопросов с помощью Debconf в ходе установки. Эти пакеты можно перенастроить, запустив <command>dpkg-reconfigure <replaceable>пакет</replaceable></command>."

msgid "For most cases, these settings are very simple; only a few important variables in the configuration file are changed. These variables are often grouped between two “demarcation” lines so that reconfiguration of the package only impacts the enclosed area. In other cases, reconfiguration will not change anything if the script detects a manual modification of the configuration file, in order to preserve these human interventions (because the script can't ensure that its own modifications will not disrupt the existing settings)."
msgstr "В большинстве случаев эти настройки очень просты; изменяются только некоторые важнейшие переменные конфигурационного файла. Эти переменные нередко содержатся между двумя «пограничными» строками, так что перенастройка пакета влияет только на ограниченную область. В других случаях перенастройка не будет ничего менять, если сценарий обнаружит, что конфигурационный файл был изменён вручную, чтобы сохранить результаты вмешательства человека (поскольку сценарий не может удостовериться, что вносимые им самим изменения не нарушат текущих настроек)."

msgid "<emphasis>DEBIAN POLICY</emphasis> Preserving changes"
msgstr "<emphasis>ПОЛИТИКА DEBIAN</emphasis> Сохранение изменений"

#, fuzzy
#| msgid "<primary>backup</primary><secondary>copy</secondary>"
msgid "<primary>Debian Project</primary><secondary>policy</secondary>"
msgstr "<primary>backup</primary><secondary>copy</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>configuration</primary><secondary>files</secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "The Debian Policy expressly stipulates that everything should be done to preserve manual changes made to a configuration file, so more and more scripts take precautions when editing configuration files. The general principle is simple: the script will only make changes if it knows the status of the configuration file, which is verified by comparing the checksum of the file against that of the last automatically generated file. If they are the same, the script is authorized to change the configuration file. Otherwise, it determines that the file has been changed and asks what action it should take (install the new file, save the old file, or try to integrate the new changes with the existing file). This precautionary principle has long been unique to Debian, but other distributions have gradually begun to embrace it."
msgstr "Политика Debian явно оговаривает, что необходимо делать всё возможное, чтобы сохранить внесённые вручную изменения в конфигурационных файлах. Главный принцип прост: сценарий будет вносить изменения только в том случае, если ему известен статус конфигурационного файла, который проверяется путём сверки контрольной суммы файла с той, которая была после того, как файл последний раз менялся автоматически. Если они совпадают, сценарий авторизуется для изменения конфигурационного файла. В противном случае он определяет, что файл был изменён, и спрашивает, какое действие ему следует предпринять (установить новый файл, сохранить старый файл или попытаться интегрировать изменения в существующий файл). Этот предупредительный принцип долгое время был уникален для Debian, но со временем и другие дистрибутивы стали перенимать его."

msgid "<primary><command>ucf</command></primary>"
msgstr "<primary><command>ucf</command></primary>"

msgid "The <command>ucf</command> program (from the Debian package of the same name) can be used to implement such a behavior."
msgstr "Для реализации такого поведения можно использовать программу <command>usf</command> (из одноимённого пакета Debian)."

msgid "<command>syslog</command> System Events"
msgstr "Системные события <command>syslog</command>"

msgid "<primary><command>rsyslogd</command></primary>"
msgstr "<primary><command>rsyslogd</command></primary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>file</primary><secondary>log file</secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

#, fuzzy
#| msgid "<primary>logs</primary><secondary>dispatching</secondary>"
msgid "<primary>log files</primary><secondary>dispatching</secondary>"
msgstr "<primary>журналы</primary><secondary>управление</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary>log files</primary><seealso><filename>/var/log</filename></seealso>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "Principle and Mechanism"
msgstr "Принципы и механизм"

msgid "The <command>rsyslogd</command> daemon is responsible for collecting service messages coming from applications and the kernel, then dispatching them into log files (usually stored in the <filename>/var/log/</filename> directory). It obeys the <filename>/etc/rsyslog.conf</filename> configuration file."
msgstr "Демон <command>rsyslogd</command> отвечает за сбор служебных сообщений от приложений и ядра и дальнейшее распределение их по файлам журналов (обычно хранящимся в каталоге <filename>/var/log/</filename>). Он управляется конфигурационным файлом <filename>/etc/rsyslog.conf</filename>."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/rsyslog.conf</filename></secondary><see><command>rsyslogd</command></see>"
msgstr ""

msgid "Each log message is associated with an application subsystem (called “facility” in the documentation):"
msgstr "Каждое сообщение в журнале соответствует подсистеме приложений (в документации называемой «facility»):"

#, fuzzy
#| msgid "<primary><command>rsyslogd</command></primary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>facility</secondary>"
msgstr "<primary><command>rsyslogd</command></primary>"

msgid "<literal>auth</literal> and <literal>authpriv</literal>: for authentication;"
msgstr "<literal>auth</literal> и <literal>authpriv</literal>: для аутентификации;"

msgid "<literal>cron</literal>: comes from task scheduling services, <command>cron</command> and <command>atd</command>;"
msgstr "<literal>cron</literal>: от сервисов планировки заданий, <command>cron</command> и <command>atd</command>;"

msgid "<literal>daemon</literal>: affects a daemon without any special classification (DNS, NTP, etc.);"
msgstr "<literal>daemon</literal>: относится к демонам, не выделенным в особую группу (DNS, NTP и т. д.);"

msgid "<literal>ftp</literal>: concerns the FTP server;"
msgstr "<literal>ftp</literal>: относится к FTP-серверу;"

msgid "<literal>kern</literal>: message coming from the kernel;"
msgstr "<literal>kern</literal>: сообщение от ядра;"

msgid "<literal>lpr</literal>: comes from the printing subsystem;"
msgstr "<literal>lpr</literal>: от подсистемы печати;"

msgid "<literal>mail</literal>: comes from the e-mail subsystem;"
msgstr "<literal>mail</literal>: от подсистемы электронной почты;"

msgid "<literal>news</literal>: Usenet subsystem message (especially from an NNTP — Network News Transfer Protocol — server that manages newsgroups);"
msgstr "<literal>news</literal>: сообщение подсистемы Usenet (в частности от сервера NNTP — Network News Transfer Protocol — управляющего новостными группами);"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>Network News Transfer Protocol</primary><seealso>NNTP</seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

msgid "<literal>syslog</literal>: messages from the <command>syslogd</command> server, itself;"
msgstr "<literal>syslog</literal>: сообщения от самого сервера <command>syslogd</command>;"

msgid "<literal>user</literal>: user messages (generic);"
msgstr "<literal>user</literal>: пользовательские сообщения (основные);"

msgid "<literal>uucp</literal>: messages from the UUCP server (Unix to Unix Copy Program, an old protocol notably used to distribute e-mail messages);"
msgstr "<literal>uucp</literal>: сообщения от сервера UUCP (Unix to Unix Copy Program, старый протокол, широко использовавшийся для распространения сообщений электронной почты);"

msgid "<literal>local0</literal> to <literal>local7</literal>: reserved for local use."
msgstr "с <literal>local0</literal> по <literal>local7</literal>: зарезервированы для локального использования."

msgid "Each message is also associated with a priority level. Here is the list in decreasing order:"
msgstr "Каждому сообщению также присваивается уровень приоритета. Вот их список в порядке убывания:"

#, fuzzy
#| msgid "<primary><command>rsyslogd</command></primary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>priority</secondary>"
msgstr "<primary><command>rsyslogd</command></primary>"

msgid "<literal>emerg</literal>: “Help!” There is an emergency, the system is probably unusable."
msgstr "<literal>emerg</literal>: “Помогите” Возникла аварийная ситуация, система возможно непригодна для использования."

msgid "<literal>alert</literal>: hurry up, any delay can be dangerous, action must be taken immediately;"
msgstr "<literal>alert</literal>: поспешите, промедление небезопасно, нужно срочно принимать меры;"

msgid "<literal>crit</literal>: conditions are critical;"
msgstr "<literal>crit</literal>: условия критические;"

msgid "<literal>err</literal>: error;"
msgstr "<literal>err</literal>: ошибка;"

msgid "<literal>warn</literal>: warning (potential error);"
msgstr "<literal>warn</literal>: предупреждение (возможная ошибка);"

msgid "<literal>notice</literal>: conditions are normal, but the message is important;"
msgstr "<literal>notice</literal>: условия нормальные, но сообщение важное;"

msgid "<literal>info</literal>: informative message;"
msgstr "<literal>info</literal>: информационное сообщение;"

msgid "<literal>debug</literal>: debugging message."
msgstr "<literal>debug</literal>: сообщение для отладки."

msgid "The Configuration File"
msgstr "Конфигурационный файл"

msgid "<primary><command>rsyslogd</command></primary><secondary>configuration</secondary><seealso><filename>/etc/rsyslog.conf</filename></seealso>"
msgstr ""

#, fuzzy
#| msgid "The syntax of the <filename>/etc/rsyslog.conf</filename> file is detailed in the <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page, but there is also HTML documentation available in the <emphasis role=\"pkg\">rsyslog-doc</emphasis> package (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). The overall principle is to write “selector” and “action” pairs. The selector defines all relevant messages, and the actions describes how to deal with them."
msgid "The syntax of the <filename>/etc/rsyslog.conf</filename> file is detailed in the <citerefentry><refentrytitle>rsyslog.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page, but there is also HTML documentation available in the <emphasis role=\"pkg\">rsyslog-doc</emphasis> package (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). The overall principle is to write “selector” and “action” pairs. The selector defines all relevant messages, and the action describes how to deal with them."
msgstr "Синтаксис файла <filename>/etc/rsyslog.conf</filename> описан на странице руководства <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>, но также есть и документация в формате HTML, доступная в пакете <emphasis role=\"pkg\">rsyslog-doc</emphasis> (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Общий принцип состоит в написании пар «селектор» и «действие». Селектор определяет подмножество сообщений, а действия описывают, что с ними делать."

msgid "Syntax of the Selector"
msgstr "Синтаксис селектора"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>selector</secondary>"
msgstr "<primary>владелец</primary><secondary>пользователь</secondary>"

msgid "The selector is a semicolon-separated list of <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> pairs (example: <literal>auth.notice;mail.info</literal>). An asterisk may represent all subsystems or all priorities (examples: <literal>*.alert</literal> or <literal>mail.*</literal>). Several subsystems can be grouped, by separating them with a comma (example: <literal>auth,mail.info</literal>). The priority indicated also covers messages of equal or higher priority; thus <literal>auth.alert</literal> indicates the <literal>auth</literal> subsystem messages of <literal>alert</literal> or <literal>emerg</literal> priority. Prefixed with an exclamation point (!), it indicates the opposite, in other words the strictly lower priorities; <literal>auth.!notice</literal>, thus, indicates messages issued from <literal>auth</literal>, with <literal>info</literal> or <literal>debug</literal> priority. Prefixed with an equal sign (=), it corresponds to precisely and only the priority indicated (<literal>auth.=notice</literal> only concerns messages from <literal>auth</literal> with <literal>notice</literal> priority)."
msgstr "Селектор представляет собой Разделённый точками с запятой список пар <literal><replaceable>подсистема</replaceable>.<replaceable>приоритет</replaceable></literal> (пример: <literal>auth.notice;mail.info</literal>). Звёздочка может означать все подсистемы или все приоритеты (примеры: <literal>*.alert</literal> или <literal>mail.*</literal>). Несколько подсистем можно сгруппировать, разделяя их запятой (пример: <literal>auth,mail.info</literal>). Указанный приоритет подразумевает сообщения того же или более высокого уровня; так, <literal>auth.alert</literal> соответствует сообщениям подсистемы <literal>auth</literal> с приоритетом <literal>alert</literal> или <literal>emerg</literal>. Если в начале стоит восклицательный знак, такая запись означает прямо противоположное, то есть строго более низкие приоритеты; <literal>auth.!notice</literal>, таким образом, означает сообщения от <literal>auth</literal> с приоритетом <literal>info</literal> или <literal>debug</literal>. Если в начале стоит знак равенства, такая запись означает точное соответствие указанному приоритету и только ему (<literal>auth.=notice</literal> соответствует сообщениям от <literal>auth</literal> с приоритетом <literal>notice</literal>)."

msgid "Each element in the list on the selector overrides previous elements. It is thus possible to restrict a set or to exclude certain elements from it. For example, <literal>kern.info;kern.!err</literal> means messages from the kernel with priority between <literal>info</literal> and <literal>warn</literal>. The <literal>none</literal> priority indicates the empty set (no priorities), and may serve to exclude a subsystem from a set of messages. Thus, <literal>*.crit;kern.none</literal> indicates all the messages of priority equal to or higher than <literal>crit</literal> not coming from the kernel."
msgstr "Каждый элемент в списке селектора переписывает предыдущие элементы. Благодаря этому возможно ограничить выборку или исключить из неё некоторые элементы. Например, <literal>kern.info;kern.!err</literal> означает сообщения от ядра с приоритетом между <literal>info</literal> и <literal>warn</literal>. Приоритет <literal>none</literal> указывает на пустую выборку (нет приоритетов) и может использоваться для исключения подсистемы из выборки сообщений. Так, <literal>*.crit;kern.none</literal> означает все сообщения с приоритетом, равным или более высоким, чем <literal>crit</literal>, исходящим не от ядра."

msgid "Syntax of Actions"
msgstr "Синтаксис действий"

#, fuzzy
#| msgid "<primary><command>rsyslogd</command></primary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>action</secondary>"
msgstr "<primary><command>rsyslogd</command></primary>"

msgid "<emphasis>BACK TO BASICS</emphasis> The named pipe, a persistent pipe"
msgstr "<emphasis>К ОСНОВАМ</emphasis> Именованный канал — постоянный канал"

msgid "<primary>named pipe</primary>"
msgstr "<primary>именованный канал</primary>"

#, fuzzy
#| msgid "<primary>backup</primary><secondary>on tape</secondary>"
msgid "<primary>pipe</primary><secondary>named pipe</secondary>"
msgstr "<primary>резервное копирование</primary><secondary>на плёнке</secondary>"

#, fuzzy
#| msgid "<primary><command>diff</command></primary>"
msgid "<primary><command>mkfifo</command></primary>"
msgstr "<primary><command>diff</command></primary>"

msgid "A named pipe is a particular type of file that operates like a traditional pipe (the pipe that you make with the “|” symbol on the command line), but via a file. This mechanism has the advantage of being able to relate two unrelated processes. Anything written to a named pipe blocks the process that writes until another process attempts to read the data written. This second process reads the data written by the first, which can then resume execution."
msgstr "Именованный канал — это специальный тип файла, работающий как обычный канал (канал, который создаётся с помощью символа «|» в командной строке), но через файл. Преимущество этого механизма заключается в возможности связи между двумя не взаимосвязанными процессами. Запись чего бы то ни было в именованный канал блокирует записывающий процесс до тех пор, пока другой процесс не попытается прочитать записанные данные. Этот второй процесс читает данные, записанные первым, которые после этого может продолжить работу."

msgid "Such a file is created with the <command>mkfifo</command> command."
msgstr "Такой файл создаётся с помощью команды <command>mkfifo</command>."

msgid "The various possible actions are:"
msgstr "В число возможных действий входят:"

msgid "add the message to a file (example: <filename>/var/log/messages</filename>);"
msgstr "добавление сообщения в файл (пример: <filename>/var/log/messages</filename>);"

msgid "send the message to a remote <command>syslog</command> server (example: <literal>@log.falcot.com</literal>);"
msgstr "отправка сообщения удалённому серверу <command>syslog</command> (пример: <literal>@log.falcot.com</literal>);"

msgid "send the message to an existing named pipe (example: <literal>|/dev/xconsole</literal>);"
msgstr "отправка сообщения в существующий именованный канал (пример: <literal>|/dev/xconsole</literal>);"

msgid "send the message to one or more users, if they are logged in (example: <literal>root,rhertzog</literal>);"
msgstr "отправка сообщения одному или нескольким пользователям, если они вошли в систему (пример: <literal>root,rhertzog</literal>);"

msgid "send the message to all logged in users (example: <literal>*</literal>);"
msgstr "отправка сообщения всем пользователям в системе (пример: <literal>*</literal>);"

msgid "write the message in a text console (example: <literal>/dev/tty8</literal>)."
msgstr "вывод сообщения в текстовую консоль (пример: <literal>/dev/tty8</literal>)."

msgid "<emphasis>SECURITY</emphasis> Forwarding logs"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> Пересылка журналов"

msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgstr "<primary>журнал</primary><secondary>пересылка</secondary>"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary><command>rsyslogd</command></primary><secondary>server</secondary>"
msgstr "<primary>владелец</primary><secondary>пользователь</secondary>"

msgid "It is a good idea to record the most important logs on a separate machine (perhaps dedicated for this purpose), since this will prevent any possible intruder from removing traces of their intrusion (unless, of course, they also compromise this other server). Furthermore, in the event of a major problem (such as a kernel crash), you have the logs available on another machine, which increases your chances of determining the sequence of events that caused the crash."
msgstr "Хорошей идеей будет записывать наиболее важные журналы на отдельной машине (возможно, специально выделенной для этой цели), поскольку это не позволит возможному взломщику удалить следы своего проникновения (если, конечно, он также не скомпроментировал и этот другой сервер). Кроме того, в случае большой проблемы (такой как сбой ядра) журналы будут доступны на другой машине, что повышает шансы на выявление последовательности событий, приведших к сбою."

msgid "To accept log messages sent by other machines, you must reconfigure <emphasis>rsyslog</emphasis>: in practice, it is sufficient to activate the ready-for-use entries in <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> and <literal>$UDPServerRun 514</literal>)."
msgstr "Чтобы принимать сообщения журнала, посылаемые другими машинами, нужно перенастроить <emphasis>rsyslog</emphasis>: нужно только активировать готовые записи в <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> и <literal>$UDPServerRun 514</literal>)."

msgid "The <command>inetd</command> Super-Server"
msgstr "Суперсервер <command>inetd</command>"

msgid "Inetd (often called “Internet super-server”) is a server of servers. It executes rarely used servers on demand, so that they do not have to run continuously."
msgstr "Inetd (часто называемый «Интернет-суперсервером») — это сервер серверов. Он запускает редко используемые серверы по требованию, так что им не приходится работать постоянно."

#, fuzzy
#| msgid "<primary><command>inetd</command></primary>"
msgid "<primary><command>inetd</command></primary><seealso>super-server</seealso>"
msgstr "<primary><command>inetd</command></primary>"

msgid "<primary>super-server</primary>"
msgstr "<primary>суперсервер</primary>"

msgid "The <filename>/etc/inetd.conf</filename> file lists these servers and their usual ports. The <command>inetd</command> command listens to all of them; when it detects a connection to any such port, it executes the corresponding server program."
msgstr "В файле <filename>/etc/inetd.conf</filename> перечисляются эти серверы и обычно используемые ими порты. Команда <command>inetd</command> слушает их все; когда она обнаруживает соединение с любым таким портом, она запускает соответствующую серверную программу."

#, fuzzy
#| msgid "<emphasis>DEBIAN POLICY</emphasis> Register a server in <filename>inetd.conf</filename>"
msgid "<emphasis>DEBIAN POLICY</emphasis> Register a server in <filename>/etc/inetd.conf</filename>"
msgstr "<emphasis>ПОЛИТИКА DEBIAN</emphasis> Регистрация сервера в <filename>inetd.conf</filename>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/inetd.conf</filename></secondary><see><command>inetd</command></see>"
msgstr ""

#, fuzzy
#| msgid "<primary><command>update-rc.d</command></primary>"
msgid "<primary><command>update-inetd</command></primary><seealso>super-server</seealso>"
msgstr "<primary><command>update-rc.d</command></primary>"

msgid "<primary>super-server</primary><secondary>register new server</secondary><seealso><command>update-inetd</command></seealso>"
msgstr ""

msgid "Packages frequently want to register a new server in the <filename>/etc/inetd.conf</filename> file, but Debian Policy prohibits any package from modifying a configuration file that it doesn't own. This is why the <command>update-inetd</command> script (in the package with the same name) was created: It manages the configuration file, and other packages can thus use it to register a new server to the super-server's configuration."
msgstr "Пакеты часто хотят выполнить регистрацию своих новых сервисов в файле  <filename>/etc/inetd.conf</filename>, но  Политикой Debian запрещено изменять чужие конфигурационные файлы любому пакету. Изменять файлы конфигурации имеет право только тот пакет, кто является их владельцем. Это объясняет, почему был создан сценарий <command>update-inetd</command> (в пакете с похожим именем): он управляет файлом настройки, и другие пакеты могут таким образом использовать этот сценарий для регистрации нового сервиса в файле настройки «Интернет-суперсервера»."

msgid "Each significant line of the <filename>/etc/inetd.conf</filename> file describes a server through seven fields (separated by spaces):"
msgstr "Каждая значащая строка файла <filename>/etc/inetd.conf</filename> описывает сервер в сми полях (разделённых пробелами):"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>super-server</primary><secondary>configuration</secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "The TCP or UDP port number, or the service name (which is mapped to a standard port number with the information contained in the <filename>/etc/services</filename> file)."
msgstr "Номер порта TCP или UDP или имя сервиса (которое преобразуется в стандартный номер порта с помощью информации, содержащейся в файле <filename>/etc/services</filename>)."

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/services</filename></secondary>"
msgstr "<primary>клиент</primary><secondary>клиент-серверная архитектура</secondary>"

msgid "The socket type: <literal>stream</literal> for a TCP connection, <literal>dgram</literal> for UDP datagrams."
msgstr "Тип сокета: <literal>stream</literal> для TCP-соединения, <literal>dgram</literal> для UDP-датаграмм."

#, fuzzy
#| msgid "The protocol: <literal>tcp</literal> or <literal>udp</literal>."
msgid "The protocol: <literal>tcp</literal>, <literal>tcp6</literal>, <literal>udp</literal>, or <literal>udp6</literal>."
msgstr "Протокол: <literal>tcp</literal> или <literal>udp</literal>."

msgid "The options: two possible values: <literal>wait</literal> or <literal>nowait</literal>, to tell <command>inetd</command> whether it should wait or not for the end of the launched process before accepting another connection. For TCP connections, easily multiplexable, you can usually use <literal>nowait</literal>. For programs responding over UDP, you should use <literal>nowait</literal> only if the server is capable of managing several connections in parallel. You can suffix this field with a period, followed by the maximum number of connections authorized per minute (the default limit is 256)."
msgstr "Опции: два возможных значения — <literal>wait</literal> или <literal>nowait</literal>, сообщающих <command>inetd</command>, следует ли ждать завершения запущенного процесса прежде чем принимать новое соединение. Для TCP-соединений, которые легко мультиплексируются, обычно можно использовать <literal>nowait</literal>. Для программ, отвечающих через UDP, следует использовать <literal>nowait</literal> только если сервер способен управляться с несколькими соединениями параллельно. В конце этой опции можно добавить точку, и после неё указать максимально разрешённое число сединений в минуту (по умолчанию используется ограничение в 256 соединений)."

#, fuzzy
#| msgid "The user name of the user under whose identity the server will run."
msgid "The user name of the user under whose identity the server will run. Optionally one can add the group too via <literal>user.group</literal> syntax."
msgstr "Имя пользователя, от имени которого будет запускаться сервер."

msgid "The full path to the server program to execute."
msgstr "Полный путь к серверной программе, которую нужно запустить."

msgid "The arguments: this is a complete list of the program's arguments, including its own name (<literal>argv[0]</literal> in C)."
msgstr "Аргументы: полный список аргументов программы, включая её собственное имя ((<literal>argv[0]</literal> в Си)."

#, fuzzy
#| msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> and <emphasis role=\"pkg\">xinetd</emphasis>."
msgid "The following example illustrates some use-cases after installing <emphasis role=\"pkg\">talkd</emphasis>, <emphasis role=\"pkg\">nullidentd</emphasis> (<emphasis role=\"pkg\">ident-server</emphasis>), and <emphasis role=\"pkg\">fingerd</emphasis>:"
msgstr "Хотя по умолчанию в Debian устанавливается <emphasis role=\"pkg\">openbsd-inetd</emphasis>, есть и немало альтернативных решений: упомянем <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> и <emphasis role=\"pkg\">xinetd</emphasis>."

msgid "Excerpt from <filename>/etc/inetd.conf</filename>"
msgstr "Выдержка из <filename>/etc/inetd.conf</filename>"

msgid ""
"#:BSD: Shell, login, exec and talk are BSD protocols.\n"
"talk   dgram   udp     wait    nobody.tty   /usr/sbin/in.talkd      in.talkd\n"
"ntalk  dgram   udp     wait    nobody.tty   /usr/sbin/in.ntalkd     in.ntalkd\n"
"\n"
"#:INFO: Info services\n"
"ident  stream  tcp     nowait  nobody       /usr/sbin/nullidentd    nullidentd\n"
"finger stream  tcp     nowait  nobody       /usr/sbin/tcpd          /usr/sbin/in.fingerd"
msgstr ""

msgid "<primary><command>tcpd</command></primary>"
msgstr "<primary><command>tcpd</command></primary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>super-server</primary><secondary>access limitation</secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

#, fuzzy
#| msgid "The <command>tcpd</command> program is frequently used in the <filename>/etc/inetd.conf</filename> file. It allows limiting incoming connections by applying access control rules, documented in the <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page, and which are configured in the <filename>/etc/hosts.allow</filename> and <filename>/etc/hosts.deny</filename> files. Once it has been determined that the connection is authorized, <command>tcpd</command> executes the real server (like <command>in.fingerd</command> in our example). It is worth noting that <command>tcpd</command> relies on the name under which it was invoked (that is the first argument, <literal>argv[0]</literal>) to identify the real program to run. So you should not start the arguments list with <literal>tcpd</literal> but with the program that must be wrapped."
msgid "The <command>tcpd</command> program is frequently used in the <filename>/etc/inetd.conf</filename> file. It allows limiting incoming connections by applying access control rules, documented in the <citerefentry><refentrytitle>hosts_access</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page, and which are configured in the <filename>/etc/hosts.allow</filename> and <filename>/etc/hosts.deny</filename> files. Once it has been determined that the connection is authorized, <command>tcpd</command> executes the real server (like <command>in.fingerd</command> in our example). It is worth noting that <command>tcpd</command> relies on the name under which it was invoked (that is the first argument, <literal>argv[0]</literal>) to identify the real program to run. So you should not start the arguments list with <literal>tcpd</literal> but with the program that must be wrapped."
msgstr "Программа <command>tcpd</command> часто используется в файле <filename>/etc/inetd.conf</filename>. Она позволяет ограничить входящие сообщения, применяя правила контроля доступа, описанные на странице руководства <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> и настраиваемые в файлах <filename>/etc/hosts.allow</filename> и <filename>/etc/hosts.deny</filename>. Когда подтверждается, что соединение разрешено, <command>tcpd</command> запускает настоящий сервер (<command>in.fingerd</command> в нашем примере). Для <command>tcpd</command> ничего не стоит определить, какой сервис следует запустить, по имени, под которым он был вызван (которое является первым аргументом, <literal>argv[0]</literal>). Поэтому список аргументов должен начинаться не с <literal>tcpd</literal>, а с программы, для которой он служит обёрткой."

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/hosts.allow</filename></secondary>"
msgstr "<primary>вход</primary><secondary>удалённый вход</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/hosts.deny</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "<emphasis>COMMUNITY</emphasis> Wietse Venema"
msgstr "<emphasis>СООБЩЕСТВО</emphasis> Виетс Венема"

msgid "<primary>Wietse Venema</primary>"
msgstr "<primary>Виетс Венема</primary>"

msgid "<primary>Venema, Wietse</primary>"
msgstr "<primary>Венема, Виетс</primary>"

#, fuzzy
#| msgid "Wietse Venema, whose expertise in security has made him a renowned programmer, is the author of the <command>tcpd</command> program. He is also the main creator of Postfix, the modular e-mail server (SMTP, Simple Mail Transfer Protocol), designed to be safer and more reliable than <command>sendmail</command>, which features a long history of security vulnerabilities."
msgid "Wietse Venema, whose expertise in security has made him a renowned programmer, is the author of the <command>tcpd</command> program. He is also the main creator of Postfix, the modular e-mail server (SMTP, Simple Mail Transfer Protocol), designed to be safer and more reliable than <command>sendmail</command>, which features a long history of security vulnerabilities. We will have a closer look at this mail server in <xref linkend=\"sect.smtp-mail-server\" />."
msgstr "Виетс Венема, чья компетенция в области безопасности сделала его известным программистом, является автором программы <command>tcpd</command>. Он также и главный разработчик Postfix, модульного сервера электронной почты (SMTP, Simple Mail Transfer Protocol), спроектированного так, чтобы быть более безопасным и надёжным, чем <command>sendmail</command>, имевший долгую историю уязвимостей."

msgid "<emphasis>ALTERNATIVE</emphasis> Other <command>inetd</command> commands"
msgstr "<emphasis>АЛЬТЕРНАТИВА</emphasis> Другие команды <command>inetd</command>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">inet-superserver</emphasis></primary><seealso>super-server</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vnc4server</emphasis></primary>"

#, fuzzy
#| msgid "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"
msgid "<primary><emphasis role=\"pkg\">xinetd</emphasis></primary><seealso>super-server</seealso>"
msgstr "<primary><emphasis role=\"pkg\">vino</emphasis></primary>"

#, fuzzy
#| msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> and <emphasis role=\"pkg\">xinetd</emphasis>."
msgid "While Debian installs <emphasis role=\"pkg\">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis>, and <emphasis role=\"pkg\">xinetd</emphasis>, which all provide the virtual package <emphasis role=\"pkg\">inet-superserver</emphasis>."
msgstr "Хотя по умолчанию в Debian устанавливается <emphasis role=\"pkg\">openbsd-inetd</emphasis>, есть и немало альтернативных решений: упомянем <emphasis role=\"pkg\">inetutils-inetd</emphasis>, <emphasis role=\"pkg\">micro-inetd</emphasis>, <emphasis role=\"pkg\">rlinetd</emphasis> и <emphasis role=\"pkg\">xinetd</emphasis>."

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/xinetd.d/</filename></secondary><seealso><command>xinetd</command></seealso>"
msgstr ""

msgid "Most of these alternatives share the same configuration file <filename>/etc/inetd.conf</filename>."
msgstr ""

#, fuzzy
#| msgid "This last incarnation of a super-server offers very interesting possibilities. Most notably, its configuration can be split into several files (stored, of course, in the <filename>/etc/xinetd.d/</filename> directory), which can make an administrator's life easier."
msgid "This last incarnation of a super-server however, offers different syntax and very interesting possibilities. Most notably, its configuration can be split into several files (stored, of course, in the <filename>/etc/xinetd.d/</filename> directory), which can make an administrator's life easier. It is considered to be more powerful, but also more complex."
msgstr "Эта последняя инкарнация суперсервера предоставляет очень интересные возможности. Самой примечательной из них является возможность разбивки конфигурации на несколько файлов (хранящихся, разумеется, в каталоге <filename>/etc/xinetd.d/</filename>), что может облегчить жизнь администратора."

#, fuzzy
#| msgid "Last but not least, it is even possible to emulate <command>inetd</command>'s behaviour with <command>systemd</command>'s socket-activation mechanism (see <xref linkend=\"sect.systemd\" />)."
msgid "Last but not least, it is even possible to emulate <command>inetd</command>'s behavior with <command>systemd</command>'s socket-activation mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "Последнее, что стоит упомянуть, но не менее важное, это имеющаяся в наличии возможность эмулировать поведение <command>inetd</command> с сокет-активирующим механизмом <command>systemd</command> (смотри <xref linkend=\"sect.systemd\" />)."

msgid "Scheduling Tasks with <command>cron</command> and <command>atd</command>"
msgstr "Планирование задач с помощью <command>cron</command> и <command>atd</command>"

msgid "<primary><command>cron</command></primary>"
msgstr "<primary><command>cron</command></primary>"

msgid "<primary><command>atd</command></primary>"
msgstr "<primary><command>atd</command></primary>"

msgid "<primary>scheduled commands</primary>"
msgstr "<primary>планирование задач</primary>"

msgid "<primary>command scheduling</primary>"
msgstr "<primary>задачи, планирование</primary>"

#, fuzzy
#| msgid "<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every day, every week, etc.); <command>atd</command> is that which deals with commands to be executed a single time, but at a specific moment in the future."
msgid "<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every hour, every day, every week, etc.). <command>atd</command> deals with commands to be executed a single time, but at a specific moment in the future."
msgstr "<command>cron</command> — это демон, отвечающий за запуск запланированных и повторяющихся команд (каждый день, каждую неделю и т. д.); <command>atd</command> — демон, работающий с командами ,которые должны запускаться однократно, но в конкретный момент времени в будущем."

msgid "In a Unix system, many tasks are scheduled for regular execution:"
msgstr "В системе Unix многие задачи планируются для регулярного запуска:"

msgid "rotating the logs;"
msgstr "ротация журналов;"

msgid "updating the database for the <command>locate</command> program;"
msgstr "обновление базы данных для программы <command>locate</command>;"

msgid "back-ups;"
msgstr "резервное копирование;"

msgid "maintenance scripts (such as cleaning out temporary files)."
msgstr "сценарии обслуживания (такие как удаление временных файлов)."

#, fuzzy
#| msgid "<primary><command>cron</command></primary>"
msgid "<primary><command>crontab</command></primary>"
msgstr "<primary><command>cron</command></primary>"

msgid "By default, all users can schedule the execution of tasks. Each user has thus their own <emphasis>crontab</emphasis> in which they can record scheduled commands. It can be edited by running <command>crontab -e</command> (its content is stored in the <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> file)."
msgstr "По умолчанию все пользователи могут планировать запуск задач. У каждого пользователя есть свой собственный <emphasis>crontab</emphasis>, в который он может записывать запланированные команды. Его можно отредактировать, запустив <command>crontab -e</command> (его содержимое хранится в файле <filename>/var/spool/cron/crontabs/<replaceable>пользователь</replaceable></filename>)."

msgid "<emphasis>SECURITY</emphasis> Restricting <command>cron</command> or <command>atd</command>"
msgstr "<emphasis>БЕЗОПАСНОСТЬ</emphasis> Ограничение использования <command>cron</command> или <command>atd</command>"

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/at.allow</filename></secondary><seealso><command>atd</command></seealso>"
msgstr ""

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/at.deny</filename></secondary><seealso><command>atd</command></seealso>"
msgstr ""

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.allow</filename></secondary><seealso><command>cron</command></seealso>"
msgstr ""

msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.deny</filename></secondary><seealso><command>cron</command></seealso>"
msgstr ""

#, fuzzy
#| msgid "You can restrict access to <command>cron</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files."
msgid "You can restrict access to <command>crontab</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files (also described in their manual pages)."
msgstr "Доступ к <command>cron</command> можно ограничить, создав файл авторизации (белый список) в <filename>/etc/cron.allow</filename>, где указываются только пользователи, которым разрешено планировать задачи. Все остальные автоматически будут лишены такой возможности. Наоборот, чтобы заблокировать только одного-двух бедокуров, можно вписать их имена в файл блокировки (чёрный список), <filename>/etc/cron.deny</filename>. Такая же возможность есть и для <command>atd</command>, соответствующие файлы называются <filename>/etc/at.allow</filename> и <filename>/etc/at.deny</filename>."

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/crontab</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.d/</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "The root user has their own <emphasis>crontab</emphasis>, but can also use the <filename>/etc/crontab</filename> file, or write additional <emphasis>crontab</emphasis> files in the <filename>/etc/cron.d</filename> directory. These last two solutions have the advantage of being able to specify the user identity to use when executing the command."
msgstr "У пользователя root есть свой собственный <emphasis>crontab</emphasis>, но он также может использовать файл <filename>/etc/crontab</filename> или создавать дополнительные файлы <emphasis>crontab</emphasis> в каталоге <filename>/etc/cron.d</filename>. У последних двух решений есть то преимущество, что можно указать пользователя, от имени которого запускается команда."

msgid "The <emphasis>cron</emphasis> package includes by default some scheduled commands that execute:"
msgstr "Пакет <emphasis>cron</emphasis> по умолчанию содержит некоторые запланированные задачи, которые выполняются:"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.hourly/</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "programs in the <filename>/etc/cron.hourly/</filename> directory once per hour;"
msgstr "программы из каталога <filename>/etc/cron.hourly/</filename> — каждый час;"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.daily/</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "programs in <filename>/etc/cron.daily/</filename> once per day;"
msgstr "программы из каталога <filename>/etc/cron.daily/</filename> — каждый день;"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.weekly/</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "programs in <filename>/etc/cron.weekly/</filename> once per week;"
msgstr "программы из каталога <filename>/etc/cron.weekly/</filename> — каждую неделю;"

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/cron.monthly/</filename></secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

msgid "programs in <filename>/etc/cron.monthly/</filename> once per month."
msgstr "программы из каталога <filename>/etc/cron.monthly/</filename> — раз в месяц."

msgid "Many Debian packages rely on this service: by putting maintenance scripts in these directories, they ensure optimal operation of their services."
msgstr "Многие пакеты Debian зависят от этого сервиса: помещая сценарии обслуживания в эти каталоги, они обеспечивают оптимальную работу своих сервисов."

msgid "Format of a <filename>crontab</filename> File"
msgstr "Формат файла <filename>crontab</filename>"

#, fuzzy
#| msgid "<primary>manager</primary><secondary>display manager</secondary>"
msgid "<primary><command>crontab</command></primary><secondary><filename>crontab</filename> file format</secondary>"
msgstr "<primary>менеджер</primary><secondary>дисплея</secondary>"

msgid "<emphasis>TIP</emphasis> Text shortcuts for <command>cron</command>"
msgstr "<emphasis>СОВЕТ</emphasis> Текстовые сокращения для <command>cron</command>"

msgid "<command>cron</command> recognizes some abbreviations which replace the first five fields in a <filename>crontab</filename> entry. They correspond to the most classic scheduling options:"
msgstr "<command>cron</command> распознаёт некоторые сокращения, заменяющие первые пять полей в записи <filename>crontab</filename>. Они соответствуют наиболее классическим опциям планирования:"

msgid "<literal>@yearly</literal>: once per year (January 1, at 00:00);"
msgstr "<literal>@yearly</literal> — раз в год (1 января, в 00:00);"

msgid "<literal>@monthly</literal>: once per month (the 1st of the month, at 00:00);"
msgstr "<literal>@monthly</literal> — раз в месяц (1 числа, в 00:00);"

msgid "<literal>@weekly</literal>: once per week (Sunday at 00:00);"
msgstr "<literal>@weekly</literal> — раз в неделю (в воскресенье, в 00:00);"

msgid "<literal>@daily</literal>: once per day (at 00:00);"
msgstr "<literal>@daily</literal> — раз в день (в 00:00);"

msgid "<literal>@hourly</literal>: once per hour (at the beginning of each hour)."
msgstr "<literal>@hourly</literal> — раз в час (в начале каждого часа)."

#, fuzzy
#| msgid "The protocol: <literal>tcp</literal> or <literal>udp</literal>."
msgid "More abbreviations are recognized, like <literal>@reboot</literal>or <literal>@midnight</literal>."
msgstr "Протокол: <literal>tcp</literal> или <literal>udp</literal>."

msgid "<emphasis>SPECIAL CASE</emphasis> <command>cron</command> and daylight savings time"
msgstr "<emphasis>ОСОБЕННЫЙ СЛУЧАЙ</emphasis> Команда <command>cron</command> и учёт изменения светового дня (например в летний и зимний период)"

msgid "In Debian, <command>cron</command> takes the time change (for Daylight Savings Time, or in fact for any significant change in the local time) into account as best as it can. Thus, the commands that should have been executed during an hour that never existed (for example, tasks scheduled at 2:30 am during the Spring time change in France, since at 2:00 am the clock jumps directly to 3:00 am) are executed shortly after the time change (thus around 3:00 am DST). On the other hand, in autumn, when commands would be executed several times (2:30 am DST, then an hour later at 2:30 am standard time, since at 3:00 am DST the clock turns back to 2:00 am) are only executed once."
msgstr "В Debian <command>cron</command> учитывает смену времени (при переходе на летнее время, а фактически — при любом значительном изменении локального времени) лучшим образом, какой только возможен. Так, команды, которые должны были запуститься в течение часа, который никогда не существовал, (например задачи, запланированные на 2:30 утра при весенней смене времени во Франции, когда в 2:00 часы переводятся на 3:00) запускаются вскоре после изменения времени (то есть около 3:00 по летнему времени). С другой стороны, осенью, когда задачи могли бы запуститься дважды (в 2:30 по летнему времени, а потом в 2:30 по обычному времени, поскольку в 3:00 утра летнего времени часы переводятся на 2:00), запускаются только однократно."

msgid "Be careful, however, if the order in which the different scheduled tasks and the delay between their respective executions matters, you should check the compatibility of these constraints with <command>cron</command>'s behavior; if necessary, you can prepare a special schedule for the two problematic nights per year."
msgstr "Следует, однако, соблюдать осторожность, если порядок запуска разных запланированных задач и величина задержки между ними имеют значение. В таком случае следует проверить совместимость этих ограничений с поведением <command>cron</command>; при необходимости можно подготовить специальное расписание для двух проблемных ночей в году."

#, fuzzy
#| msgid "Each significant line of a <emphasis>crontab</emphasis> describes a scheduled command with the six (or seven) following fields:"
msgid "Each significant line of a <filename>crontab</filename> entry describes a scheduled command with the six (or seven) following fields:"
msgstr "Каждая значащая строка <emphasis>crontab</emphasis> описывает запланированную команду в следующих шести (или семи) полях:"

#, fuzzy
#| msgid "the value for the minute (number from 0 to 59);"
msgid "the value for the minute (from 0 to 59);"
msgstr "значение минуты (число от 0 до 59);"

msgid "the value for the hour (from 0 to 23);"
msgstr "значение часа (от 0 до 23);"

msgid "the value for the day of the month (from 1 to 31);"
msgstr "значение числа месяца (от 1 до 31);"

msgid "the value for the month (from 1 to 12);"
msgstr "значение месяца (от 1 до 12);"

msgid "the value for the day of the week (from 0 to 7, 1 corresponding to Monday, Sunday being represented by both 0 and 7; it is also possible to use the first three letters of the name of the day of the week in English, such as <literal>Sun</literal>, <literal>Mon</literal>, etc.);"
msgstr "значение дня недели (от 0 до 7, где 1 соответствует понедельнику, а воскресенье может быть представлено как 0 или 7; также можно использовать первые три буквы англоязычного названия дня недели, например <literal>Sun</literal>, <literal>Mon</literal> и т. д.);"

msgid "the user name under whose identity the command must be executed (in the <filename>/etc/crontab</filename> file and in the fragments located in <filename>/etc/cron.d/</filename>, but not in the users' own crontab files);"
msgstr "имя пользователя, от имени которого должна выполняться команда (в файле <filename>/etc/crontab</filename> и в фрагментах, расположенных в <filename>/etc/cron.d/</filename>, но не в пользовательских файлах crontab);"

msgid "the command to execute (when the conditions defined by the first five columns are met)."
msgstr "команда, которая должна быть запущена (при выполнении условий, определённых в первых пяти колонках)."

msgid "All these details are documented in the <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man page."
msgstr "Все эти подробности описаны на странице man <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."

#, fuzzy
#| msgid "Each value can be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values."
msgid "Each value can also be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values."
msgstr "Каждое значение может быть представлено в виде списка возможных значений (разделённого запятыми). Синтаксис <literal>a-b</literal> описывает интервал всех значений между <literal>a</literal> и <literal>b</literal>. Синтаксис <literal>a-b/c</literal> описывает интервал с промежутками <literal>c</literal> (пример: <literal>0-10/2</literal> означает <literal>0,2,4,6,8,10</literal>). Звёздочка <literal>*</literal> является шаблоном, означающим все допустимые значения."

#, fuzzy
#| msgid "Sample <filename>crontab</filename> file"
msgid "Sample user <filename>crontab</filename> file"
msgstr "Пример файла <filename>crontab</filename>"

#, fuzzy
#| msgid ""
#| "#Format\n"
#| "#min hour day mon dow  command\n"
#| "\n"
#| "# Download data every night at 7:25 pm\n"
#| " 25  19   *   *   *    $HOME/bin/get.pl\n"
#| "\n"
#| "# 8:00 am, on weekdays (Monday through Friday)\n"
#| " 00  08   *   *   1-5  $HOME/bin/dosomething\n"
#| "\n"
#| "# Restart the IRC proxy after each reboot\n"
#| "@reboot /usr/bin/dircproxy"
msgid ""
"#Format\n"
"#min hour day mon dow  command\n"
"\n"
"# Download data every night at 7:25 pm\n"
" 25  19   *   *   *    $HOME/bin/get.pl\n"
"\n"
"# 8:00 am, on weekdays (Monday through Friday)\n"
" 00  08   *   *   1-5  $HOME/bin/dosomething\n"
"\n"
"# every two hours\n"
" *  */2   *   *   *    $HOME/bin/dosomethingelse\n"
"\n"
"# Restart the IRC proxy after each reboot\n"
"@reboot /usr/bin/dircproxy"
msgstr ""
"#Format\n"
"#min hour day mon dow   command\n"
"\n"
"# Download data every night at 7:25 pm\n"
" 25  19   *   *   *    $HOME/bin/get.pl\n"
"\n"
"# 8:00 am, on weekdays (Monday through Friday)\n"
" 00  08   *   *   1-5  $HOME/bin/dosomething\n"
"\n"
"# Restart the IRC proxy after each reboot\n"
"@reboot /usr/bin/dircproxy"

msgid "<emphasis>TIP</emphasis> Executing a command on boot"
msgstr "<emphasis>СОВЕТ</emphasis> Запуск команды при загрузке"

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><command>cron</command></primary><secondary><literal>@reboot</literal></secondary>"
msgstr "<primary>клиент</primary><secondary>клиент-серверная архитектура</secondary>"

msgid "To execute a command a single time, just after booting the computer, you can use the <literal>@reboot</literal> macro (a simple restart of <command>cron</command> does not trigger a command scheduled with <literal>@reboot</literal>). This macro replaces the first five fields of an entry in the <emphasis>crontab</emphasis>."
msgstr "Для однократного запуска команды сразу после загрузки компьютера можно использовать макрос <literal>@reboot</literal> (простой перезапуск <command>cron</command> не вызовет команду, запланированную с использованием <literal>@reboot</literal>). Этот макрос заменяет первые пять полей записи <emphasis>crontab</emphasis>."

msgid "<emphasis>ALTERNATIVE</emphasis> Emulating <command>cron</command> with <command>systemd</command>"
msgstr "<emphasis>АЛЬТЕРНАТИВА</emphasis> Эмуляция команды <command>cron</command> с помощью команды <command>systemd</command>"

#, fuzzy
#| msgid "It is possible to emulate part of <command>cron</command>'s behaviour with <command>systemd</command>'s timer mechanism (see <xref linkend=\"sect.systemd\" />)."
msgid "It is possible to emulate part of <command>cron</command>'s behavior with <command>systemd</command>'s timer mechanism (see <xref linkend=\"sect.systemd\" />)."
msgstr "Возможно эмулировать часть функциональных возможностей поведения команды <command>cron</command> с механизмом таймера команды <command>systemd</command> (смотри <xref linkend=\"sect.systemd\" />)."

msgid "Using the <command>at</command> Command"
msgstr "Использование команды <command>at</command>"

msgid "<primary><command>at</command></primary>"
msgstr "<primary><command>at</command></primary>"

#, fuzzy
#| msgid "The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.15</literal> thus representing 27 July 2015), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2015-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (ie., <literal>12/25/15</literal> or <literal>12/25/2015</literal> will be December 25, 2015), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122515</literal> or <literal>12252015</literal> will, likewise, represent December 25, 2015). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory."
msgid "The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.22</literal> thus representing 27 July 2022), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2022-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (i.e., <literal>12/25/22</literal> or <literal>12/25/2022</literal> will be December 25, 2022), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122522</literal> or <literal>12252022</literal> will, likewise, represent December 25, 2022). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory."
msgstr "С помощью команды <command>at</command> осуществляется планирование какой-либо задачи в тот или иной момент в будущем. Команда принимает в качестве параметра командной строки время и дату, и её выполнение произойдёт в стандартном выводе. Команда будет выполнена таким образом, как будто она была выполнена в настоящей оболочке (shell). <command>at</command> даже возьмёт на себя заботу получить информацию о ваших переменных настоящего окружающего рабочего стола (environment) для того, чтобы в будущем, при выполнении задания, постараться воспроизвести хотя бы часть сегодняшних условий. Отображение времени следует обычным соглашениям: <literal>16:12</literal> или <literal>4:12pm</literal> соответствует 4:12 часа пополỳдня или 16 часов 12 минут. Дата может быть указана в нескольких европейских или западных форматах, включающих <literal>DD.MM.YY</literal> (значение <literal>27.07.15</literal> таким образом соответствует 27 июля 2015), <literal>YYYY-MM-DD</literal> (похожая дата будет выглядеть как <literal>2015-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (например, <literal>12/25/15</literal> или <literal>12/25/2015</literal> будут означать - Декабрь 25, 2015), или просто <literal>MMDD[CC]YY</literal> (то есть значения  <literal>122515</literal> или <literal>12252015</literal> будут, подобным образом, представлять Декабрь 25, 2015). Без этого, то есть без указания даты, команда будет выполнена в назначенное время, как только отсчёт времени достигнет его (в тот же день, или завтра, если указанное время сегодня уже было пропущено). Вы можете также просто написать “today” - сегодня или “tomorrow” - завтра, каждое из этих слов говорит само за себя."

#, fuzzy
#| msgid ""
#| "\n"
#| "<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
#| "<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
#| "<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
#| "<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
#| "<computeroutput>warning: commands will be executed using /bin/sh\n"
#| "job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"
msgid ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.22 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 1 at Wed Jul 27 09:00:00 2022</computeroutput>"
msgstr ""
"\n"
"<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>echo \"Don't forget to wish a Happy Birthday to Raphaël!\" \\</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>\n"
"<computeroutput>&gt; </computeroutput><userinput>END</userinput>\n"
"<computeroutput>warning: commands will be executed using /bin/sh\n"
"job 31 at Mon Jul 27 09:00:00 2015</computeroutput>"

msgid "An alternative syntax postpones the execution for a given duration: <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command>. The <replaceable>period</replaceable> can be <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal>, or <literal>weeks</literal>. The <replaceable>number</replaceable> simply indicates the number of said units that must elapse before execution of the command."
msgstr "Альтернативный синтаксис откладывает запуск на заданный промежуток времени: <command>at now + <replaceable>число</replaceable> <replaceable>период</replaceable></command>. Значение <replaceable>период</replaceable> может быть <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal> или <literal>weeks</literal>. Значение <replaceable>число</replaceable> указывает число указанных единиц, которое должно пройти перед запуском программы."

msgid "To cancel a task scheduled by <command>cron</command>, simply run <command>crontab -e</command> and delete the corresponding line in the <emphasis>crontab</emphasis> file. For <command>at</command> tasks, it is almost as easy: run <command>atrm <replaceable>task-number</replaceable></command>. The task number is indicated by the <command>at</command> command when you scheduled it, but you can find it again with the <command>atq</command> command, which gives the current list of scheduled tasks."
msgstr "Для отмены задачи, запланированной <command>cron</command>, нужно просто запустить <command>crontab -e</command> и удалить соответствующую строку в файле <emphasis>crontab</emphasis>. Для задач <command>at</command> это почти так же легко: надо запустить <command>atrm <replaceable>номер-задачи</replaceable></command>. Номер задачи указывается командой <command>at</command> при её планировании, а также её можно найти с помощью команды <command>atq</command>, выводящей текущий список запланированных задач."

msgid "<primary><command>atrm</command></primary>"
msgstr "<primary><command>atrm</command></primary>"

msgid "<primary><command>atq</command></primary>"
msgstr "<primary><command>atq</command></primary>"

msgid "Scheduling Asynchronous Tasks: <command>anacron</command>"
msgstr "Планирование асинхронных задач: <command>anacron</command>"

#, fuzzy
#| msgid "<primary><command>anacron</command></primary>"
msgid "<primary><command>anacron</command></primary><seealso><command>cron</command></seealso>"
msgstr "<primary><command>anacron</command></primary>"

#, fuzzy
#| msgid "<primary>files</primary><secondary>log files</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/anacrontab</filename></secondary>"
msgstr "<primary>файлы</primary><secondary>журналов</secondary>"

msgid "<command>anacron</command> is the daemon that completes <command>cron</command> for computers that are not on at all times. Since regular tasks are usually scheduled for the middle of the night, they will never be executed if the computer is off at that time. The purpose of <command>anacron</command> is to execute them, taking into account periods in which the computer is not working."
msgstr "<command>anacron</command> — это демон, дополняющий <command>cron</command> на компьютерах, которые не включены всё время. Поскольку регулярные задачи обычно планируются на середину ночи, они никогда не будут запускаться, если компьютер в это время выключен. Назначение <command>anacron</command> — запустить их, принимая во внимание периоды, в которые компьютер не работает."

#, fuzzy
#| msgid "<primary><command>init</command></primary>"
msgid "<primary><command>nice</command></primary>"
msgstr "<primary><command>init</command></primary>"

msgid "Please note that <command>anacron</command> will frequently execute such activity a few minutes after booting the machine, which can render the computer less responsive. This is why the tasks in the <filename>/etc/anacrontab</filename> file are started with the <command>nice</command> command, which reduces their execution priority and thus limits their impact on the rest of the system. Beware, the format of this file is not the same as that of <filename>/etc/crontab</filename>; if you have particular needs for <command>anacron</command>, see the <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page."
msgstr "Обратите внимание, что <command>anacron</command> зачастую будет запускать такие действия через несколько минут после загрузки машины, что может привести к ухудшению отзывчивости системы. Поэтому задачи в файле <filename>/etc/anacrontab</filename> запускаются с помощью команды <command>nice</command>, понижающей приоритет их выполнения и тем самым ограничивающей их влияние на остальную систему. Будьте внимательны, формат этого файла отличается от <filename>/etc/crontab</filename>; при необходимости использовать <command>anacron</command> следует ознакомиться со страницей руководства <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>."

msgid "<emphasis>BACK TO BASICS</emphasis> Priorities and <command>nice</command>"
msgstr "<emphasis>К ОСНОВАМ</emphasis> Приоритеты и <command>nice</command>"

#, fuzzy
#| msgid "<primary><command>rsync</command></primary>"
msgid "<primary><command>renice</command></primary>"
msgstr "<primary><command>rsync</command></primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>niceness</primary><seealso><command>nice</command></seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "Unix systems (and thus Linux) are multi-tasking and multi-user systems. Indeed, several processes can run in parallel, and be owned by different users: the kernel mediates access to the resources between the different processes. As a part of this task, it has a concept of priority, which allows it to favor certain processes over others, as needed. When you know that a process can run in low priority, you can indicate so by running it with <command>nice <replaceable>program</replaceable></command>. The program will then have a smaller share of the CPU, and will have a smaller impact on other running processes. Of course, if no other processes needs to run, the program will not be artificially held back."
msgid "Unix systems (and thus Linux) are multi-tasking and multi-user systems. Indeed, several processes can run in parallel, and be owned by different users: the kernel mediates access to the resources between the different processes. As a part of this task, it has a concept of priority, which allows it to favor certain processes over others, as needed. When you know that a process can run in low priority, you can indicate so by running it with <command>nice <replaceable>program</replaceable></command>. The program will then have a smaller share of the CPU, and will have a smaller impact on other running processes. Of course, if no other process needs to run, the program will not be artificially held back."
msgstr "Unix-системы (включая Linux) — это многозадачные и многопользовательские системы. Несколько процессов могут работать параллельно и принадлежать разным пользователям: ядро регулирует доступ различных приложений к ресурсам. Для решения этой задачи служит концепция приоритетов, позволяющая при необходимости отдавать предпочтение одним процессам перед другими. Если известно, что процесс можно запустить с низким приоритетом, можно указать это, запустив его с помощью <command>nice <replaceable>программа</replaceable></command>. После этого программа будет получать меньше процессорного времени и оказывать меньшее влияние на другие работающие процессы. Разумеется, если других ожидающих выполнения процессов нет, программа не будет искусственно притормаживаться."

msgid "<command>nice</command> works with levels of “niceness”: the positive levels (from 1 to 19) progressively lower the priority, while the negative levels (from -1 to -20) will increase it — but only root can use these negative levels. Unless otherwise indicated (see the <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry> manual page), <command>nice</command> increases the current level by 10."
msgstr "<command>nice</command> работает с разными уровнями «уступчивости»: положительные уровни (с 1 по 19) постепенно понижают приоритет, в то время как отрицательные уровни (от −1 до −20) увеличат его — но такие отрицательные уровни дозволено использовать только root. Если не указано что-либо другое (см. страницу руководства <citerefentry><refentrytitle>nice</refentrytitle><manvolnum>1</manvolnum></citerefentry>), <command>nice</command> повышает текущий уровень на 10."

msgid "If you discover that an already running task should have been started with <command>nice</command> it is not too late to fix it; the <command>renice</command> command changes the priority of an already running process, in either direction (but reducing the “niceness” of a process is reserved for the root user)."
msgstr "Если вы обнаружите, что уже работающая задача должна была быть запущена с <command>nice</command>, то ещё не поздно исправить это; команда <command>renice</command> изменит приоритет уже запущенного процесса, в любом направлении (но учтите, что понижение “уступчивости” процесса зарезервировано за пользователем - администратор)."

msgid "Installation of the <emphasis role=\"pkg\">anacron</emphasis> package deactivates execution by <command>cron</command> of the scripts in the <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, and <filename>/etc/cron.monthly/</filename> directories. This avoids their double execution by <command>anacron</command> and <command>cron</command>. The <command>cron</command> command remains active and will continue to handle the other scheduled tasks (especially those scheduled by users)."
msgstr "При установке пакета <emphasis role=\"pkg\">anacron</emphasis> отключается выполнение <command>cron</command> сценариев в каталогах <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, и <filename>/etc/cron.monthly/</filename>. Это позволяет избежать их двукратного запуска как <command>anacron</command> так и <command>cron</command>. Команда <command>cron</command> остаётся активной и продолжает обслуживать другие запланированные задания (в частности заданные пользователями)."

msgid "Quotas"
msgstr "Квоты"

msgid "<primary>quota</primary>"
msgstr "<primary>квота</primary>"

msgid "The quota system allows limiting disk space allocated to a user or group of users. To set it up, you must have a kernel that supports it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is the case with Debian kernels. The quota management software is found in the <emphasis role=\"pkg\">quota</emphasis> Debian package."
msgstr "Система квот позволяет ограничить размер дискового пространства, выделенного пользователю или группе пользователей. При желании использовать её, вы должны вначале убедиться, что имеете ядро с поддержкой квот (то есть ядро должно быть скомпилировано с опцией <varname>CONFIG_QUOTA</varname>) — как это реализовано в ядрах, собранных для дистибутивов Debian. Программное обеспечение для управления квотами находится в Debian пакете <emphasis role=\"pkg\">quota</emphasis>."

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary><literal>usrquota</literal></primary><seealso>quota</seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary><literal>grpquota</literal></primary><seealso>quota</seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

msgid "To activate quota in a filesystem, you have to indicate the <literal>usrquota</literal> and <literal>grpquota</literal> options in <filename>/etc/fstab</filename> for the user and group quotas, respectively. Rebooting the computer will then update the quotas in the absence of disk activity (a necessary condition for proper accounting of already used disk space)."
msgstr "Для активирования квоты в файловой системе, вам надо в явной форме указать опции <literal>usrquota</literal> и <literal>grpquota</literal> в файле <filename>/etc/fstab</filename>, применив их к тем пользователям и группам, которым вы хотите установить квоты, соответственно. Во время перезагрузки компьютера, при отсутствии активности жёсткого диска, будет выполнено обновление квот (это необходимое условия для правильного учёта уже использованного дискового пространства)."

msgid "<primary><command>edquota</command></primary>"
msgstr "<primary><command>edquota</command></primary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>quota</primary><secondary><command>edquota</command></secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "The <command>edquota <replaceable>user</replaceable></command> (or <command>edquota -g <replaceable>group</replaceable></command>) command allows you to change the limits while examining current disk space usage."
msgstr "команда <command>edquota <replaceable>пользователь</replaceable></command> (или <command>edquota -g <replaceable>группа</replaceable></command>) позволяет изменить лимиты, проверив текущее использование дискового пространства."

msgid "<emphasis>GOING FURTHER</emphasis> Defining quotas with a script"
msgstr "<emphasis>УГЛУБЛЯЕМСЯ</emphasis> Определение квот с помощью сценария"

msgid "<primary><command>setquota</command></primary>"
msgstr "<primary><command>setquota</command></primary>"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>quota</primary><secondary><command>setquota</command></secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "The <command>setquota</command> program can be used in a script to automatically change many quotas. Its <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> manual page details the syntax to use."
msgstr "Программа <command>setquota</command> может использоваться в сценарии для автоматического изменения множества квот. На её странице руководства <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> подробно описан используемый синтаксис."

msgid "The quota system allows you to set four limits:"
msgstr "Система квот позволяет задать четыре лимита:"

#, fuzzy
#| msgid "two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, a block contains 1024 bytes from the same file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will however be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total."
msgid "two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, the 1024 available bytes of each block can only be assigned to one file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will, however, be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total."
msgstr "два лимита (называемые «мягким» и «жёстким») соответствуют числу используемых блоков. Если файловая система создана с размером блока 1 кибибайт, блок содержит фрагмент файла длиной 1024 байта. Незаполненные блоки поэтому приводят к потере дискового пространства. Квота в 100 блоков, теоретически позволяющая хранить 102.400 байтов, будет исчерпана всего 100 файлами размером по 500 байтов каждый, что составляет в сумме всего 50.000 байтов."

#, fuzzy
#| msgid "two limits (soft and hard) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files."
msgid "two limits (“soft” and “hard”) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files."
msgstr "два лимита (мягкий и жёсткий) соответствуют числу использованных записей inode. Каждый файл занимает как минимум один inode для хранения информации о себе (разрешения, владелец, временная метка последнего доступа и т. д.). Поэтому фактически это лимит на число файлов пользователя."

msgid "<primary>inode</primary>"
msgstr "<primary>inode</primary>"

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary>quota</primary><secondary>soft limit</secondary>"
msgstr "<primary>вход</primary><secondary>удалённый вход</secondary>"

#, fuzzy
#| msgid "<primary>link</primary><secondary>hard link</secondary>"
msgid "<primary>quota</primary><secondary>hard limit</secondary>"
msgstr "<primary>ссылка</primary><secondary>жёсткая ссылка</secondary>"

msgid "A “soft” limit can be temporarily exceeded; the user will simply be warned that they are exceeding the quota by the <command>warnquota</command> command, which is usually invoked by <command>cron</command>. A “hard” limit can never be exceeded: the system will refuse any operation that will cause a hard quota to be exceeded."
msgstr "«Мягкий» лимит может быть временно превышен; пользователь просто получит предупреждение о превышении квоты от команды <command>warnquota</command>, обычно вызываемой <command>cron</command>. «Жёсткий» лимит никогда не может быть превышен: система отклонит любую операцию, приводящую к превышению жёсткой квоты."

#, fuzzy
#| msgid "<primary>log</primary><secondary>forwarding</secondary>"
msgid "<primary>quota</primary><secondary><command>warnquota</command></secondary>"
msgstr "<primary>журнал</primary><secondary>пересылка</secondary>"

msgid "<emphasis>VOCABULARY</emphasis> Blocks and inodes"
msgstr "<emphasis>СЛОВАРЬ</emphasis> Блоки и inode"

msgid "<primary>block (disk)</primary>"
msgstr "<primary>блок (на диске)</primary>"

msgid "The filesystem divides the hard drive into blocks — small contiguous areas. The size of these blocks is defined during creation of the filesystem, and generally varies between 1 and 8 kibibytes."
msgstr "Файловая система делит диск на блоки — маленькие неразрывные области. Размер этих областей определяется при создании файловой системы и обычно имеет значение от 1 до 8 кибибайт."

msgid "A block can be used either to store the real data of a file, or for meta-data used by the filesystem. Among this meta-data, you will especially find the inodes. An inode uses a block on the hard drive (but this block is not taken into consideration in the block quota, only in the inode quota), and contains both the information on the file to which it corresponds (name, owner, permissions, etc.) and the pointers to the data blocks that are actually used. For very large files that occupy more blocks than it is possible to reference in a single inode, there is an indirect block system; the inode references a list of blocks that do not directly contain data, but another list of blocks."
msgstr "Блок может использоваться или для хранения данных файла, или для хранения метаданных, используемых файловой системой. Среди этих метаданных особо выделяются inode. Inode занимает блок на жёстком диске (но этот блок не учитывается квотой на блоки, только квотой на inode) и содержит информацию о соответствующем файле (имя, владелец, разрешения и т. д.) и указатели на занятые блоки данных. Для очень больших файлов, занимающих слишком большое число блоков, чтобы на них можно было сослаться из одного inode, существует непрямая система блоков; inode ссылается на список блоков, которые содержат не сами данные, а другой список блоков."

msgid "With the <command>edquota -t</command> command, you can define a maximum authorized “grace period” within which a soft limit may be exceeded. After this period, the soft limit will be treated like a hard limit, and the user will have to reduce their disk space usage to within this limit in order to be able to write anything to the hard drive."
msgstr "С помощью команды <command>edquota -t</command> можно определить максимально дозволенный «кредитный период», в течение которого может быть превышен мягкий лимит. По истечении этого периода мягкий лимит будет обрабатываться как жёсткий, и пользователю нужно будет уменьшить использование дискового пространства в соответствии с этим лимитом, чтобы получить возможность записи чего бы то ни было на жёсткий диск."

msgid "<emphasis>GOING FURTHER</emphasis> Setting up a default quota for new users"
msgstr "<emphasis>УГЛУБЛЯЕМСЯ</emphasis> Установка квоты по умолчанию для новых пользователей"

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>quota</primary><secondary><varname>QUOTAUSER</varname></secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

#, fuzzy
#| msgid "<primary>service</primary><secondary>restart</secondary>"
msgid "<primary>environment variable</primary><secondary><varname>QUOTAUSER</varname></secondary>"
msgstr "<primary>сервис</primary><secondary>перезапуск</secondary>"

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/adduser.conf</filename></secondary>"
msgstr "<primary>клиент</primary><secondary>клиент-серверная архитектура</secondary>"

#, fuzzy
#| msgid "<primary>owner</primary><secondary>user</secondary>"
msgid "<primary>quota</primary><secondary>template user</secondary>"
msgstr "<primary>владелец</primary><secondary>пользователь</secondary>"

msgid "To automatically setup a quota for new users, you have to configure a template user (with <command>edquota</command> or <command>setquota</command>) and indicate their user name in the <varname>QUOTAUSER</varname> variable in the <filename>/etc/adduser.conf</filename> file. This quota configuration will then be automatically applied to each new user created with the <command>adduser</command> command."
msgstr "Чтобы автоматически устанавливать квоту для новых пользователей, нужно настроить шаблонного пользователя (с помощью <command>edquota</command> или <command>setquota</command>) и указать его имя пользователя в переменной <varname>QUOTAUSER</varname> в файле <filename>/etc/adduser.conf</filename>. Эта настройка квоты будет автоматически применяться ко всем новым пользователям, созданным с помощью команды <command>adduser</command>."

msgid "<primary>backup</primary>"
msgstr "<primary>резервное копирование</primary>"

msgid "<primary>restoration</primary>"
msgstr "<primary>восстановление</primary>"

msgid "Making backups is one of the main responsibilities of any administrator, but it is a complex subject, involving powerful tools which are often difficult to master."
msgstr "Создание резервных копий — одна из основных обязанностей любого администратора, но это сложная задача, для которой используются мощные инструменты, которыми подчас непросто овладеть."

msgid "<primary><command>amanda</command></primary>"
msgstr "<primary><command>amanda</command></primary>"

msgid "<primary><command>bacula</command></primary>"
msgstr "<primary><command>bacula</command></primary>"

#, fuzzy
#| msgid "<primary><command>atd</command></primary>"
msgid "<primary><command>dd</command></primary>"
msgstr "<primary><command>atd</command></primary>"

#, fuzzy
#| msgid "<primary><command>init</command></primary>"
msgid "<primary><command>duplicity</command></primary>"
msgstr "<primary><command>init</command></primary>"

#, fuzzy
#| msgid "<primary><command>chgrp</command></primary>"
msgid "<primary><command>fsarchiver</command></primary>"
msgstr "<primary><command>chgrp</command></primary>"

msgid "<primary><command>BackupPC</command></primary>"
msgstr "<primary><command>BackupPC</command></primary>"

#, fuzzy
#| msgid "<primary><command>diff</command></primary>"
msgid "<primary><command>rdiff-backup</command></primary>"
msgstr "<primary><command>diff</command></primary>"

#, fuzzy
#| msgid "<primary><command>rsh</command></primary>"
msgid "<primary><command>rsnapshot</command></primary>"
msgstr "<primary><command>rsh</command></primary>"

#, fuzzy
#| msgid "<primary><command>init</command></primary>"
msgid "<primary><command>timeshift</command></primary>"
msgstr "<primary><command>init</command></primary>"

#, fuzzy
#| msgid "Many programs exist, such as <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Those are client/server system featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. But Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>."
msgid "Many programs exist, such as <command>amanda</command>, <command>bacula</command>, or <command>BackupPC</command>. Those are client/server systems featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. For non-enterprise systems, administrators might want to check out <command>rsnapshot</command> or <command>rdiff-backup</command>. Users can easily create backups of their filesystems with <command>timeshift</command>, <command>fsarchiver</command>, <command>duplicity</command>, or even <command>dd</command>."
msgstr "Существует множество программ, таких как <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Это клиент-серверные системы, имеющие много опций, настройка которых довольно сложна. Некоторые из них предоставляют дружественный веб-интерфейс, чтобы компенсировать это. Но в Debian есть десятки других программ для резервного копирования на все возможные случаи, в чём можно легко убедиться с помощью <command>apt-cache search backup</command>."

msgid "Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>."
msgstr ""

msgid "Rather than detailing some of them, this section will present the thoughts of the Falcot Corp administrators when they defined their backup strategy."
msgstr "Вместо того, чтобы описывать некоторые из них, в этом разделе будут приведены рассуждения администраторов Falcot Corp при определении ими стратегии резервного копирования."

msgid "At Falcot Corp, backups have two goals: recovering erroneously deleted files, and quickly restoring any computer (server or desktop) whose hard drive has failed."
msgstr "В Falcot Corp резервные копии нужны для двух целей: восстановления ошибочно удалённых файлов и быстрого восстановления любого компьютера (сервера или рабочей станции) после отказа жёсткого диска."

msgid "Backing Up with <command>rsync</command>"
msgstr "Резервное копирование с помощью <command>rsync</command>"

msgid "<primary><command>rsync</command></primary>"
msgstr "<primary><command>rsync</command></primary>"

msgid "Backups on tape having been deemed too slow and costly, data will be backed up on hard drives on a dedicated server, on which the use of software RAID (see <xref linkend=\"sect.raid-soft\" />) will protect the data from hard drive failure. Desktop computers are not backed up individually, but users are advised that their personal account on their department's file server will be backed up. The <command>rsync</command> command (from the package of the same name) is used daily to back up these different servers."
msgstr "Поскольку резервные копии на магнитной ленте сочли слишком медленными и дорогими, данные будут сохраняться на жёстких дисках на выделенном сервере, на котором использование программного RAID (см. <xref linkend=\"sect.raid-soft\" />) защитит данные от сбоя диска. Резервные копии отдельных настольных компьютеров не делаются, но пользователи извещены, что будет выполняться резервное копирование их учётных записей на файловом сервере их отдела. Команда <command>rsync</command> ежедневно используется для резервного копирования этих серверов."

msgid "<emphasis>BACK TO BASICS</emphasis> The hard link, a second name for the file"
msgstr "<emphasis>К ОСНОВАМ</emphasis> Жёсткая ссылка, второе имя файла"

msgid "<primary>link</primary><secondary>hard link</secondary>"
msgstr "<primary>ссылка</primary><secondary>жёсткая ссылка</secondary>"

msgid "<primary>hard link</primary>"
msgstr "<primary>жёсткая ссылка</primary>"

#, fuzzy
#| msgid "<primary><command>telnet</command></primary>"
msgid "<primary><command>ln</command></primary>"
msgstr "<primary><command>telnet</command></primary>"

msgid "A hard link, as opposed to a symbolic link, cannot be differentiated from the linked file. Creating a hard link is essentially the same as giving an existing file a second name. This is why the deletion of a hard link only removes one of the names associated with the file. As long as another name is still assigned to the file, the data therein remain present on the filesystem. It is interesting to note that, unlike a copy, the hard link does not take up additional space on the hard drive."
msgstr "Жёсткую сылку, в противоположность символической ссылке, невозможно отличить от самого файла, на который она ссылается. По сути, создание жёсткой ссылки является как бы присвоением второго имени существующему файлу. Именно поэтому, если удалить жёсткую ссылку, то сам файл, на который ранее она ссылалась, не будет удалён (будет удалено только как бы второе имя файла). До тех пор, пока существует другое имя файла в системе, данные, включённые в него, будут оставаться записанными в файловой системе. Интересно отметить, что в отличие от копии файла, жёсткая ссылка не занимает дополнительного пространства на жёстком диске."

msgid "A hard link is created with the <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> command. The <replaceable>link</replaceable> file is then a new name for the <replaceable>target</replaceable> file. Hard links can only be created on the same filesystem, while symbolic links are not subject to this limitation."
msgstr "Жёсткая ссылка создаётся командой <command>ln <replaceable>цель</replaceable> <replaceable>ссылка</replaceable></command>. Файл <replaceable>ссылка</replaceable> станет новым именем для файла <replaceable>target</replaceable>. Жёсткие ссылки можно создавать только в пределах одной файловой системы, в то время как на символьные ссылки это ограничение не распространяется."

msgid "The available hard drive space prohibits implementation of a complete daily backup. As such, the <command>rsync</command> command is preceded by a duplication of the content of the previous backup with hard links, which prevents usage of too much hard drive space. The <command>rsync</command> process then only replaces files that have been modified since the last backup. With this mechanism a great number of backups can be kept in a small amount of space. Since all backups are immediately available and accessible (for example, in different directories of a given share on the network), you can quickly make comparisons between two given dates."
msgstr "Доступное дисковое пространство не позволяет реализовать полное ежедневное резервное копирование. Поэтому команде <command>rsync</command> предшествует дублирование содержимого предыдущей резервной копии с помощью жёстких ссылок, что предупреждает использование слишком большого дискового пространства. Процесс <command>rsync</command> затем заменяет только те файлы, которые были изменены с момента создания предыдущей копии. С помощью этого механизма огромное число резервных копий можно хранить на небольшом пространстве. Поскольку все резервные копии немедленно становятся доступными (например в разных каталогах на сетевом ресурсе), можно быстро выполнять сравнения между двумя заданными датами."

msgid "<primary>copy, backup copy</primary>"
msgstr "<primary>копия, резервная копия</primary>"

msgid "<primary>backup</primary><secondary>copy</secondary>"
msgstr "<primary>backup</primary><secondary>copy</secondary>"

msgid "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"
msgstr "<primary><emphasis role=\"pkg\">dirvish</emphasis></primary>"

msgid "This backup mechanism is easily implemented with the <command>dirvish</command> program. It uses a backup storage space (“bank” in its vocabulary) in which it places timestamped copies of sets of backup files (these sets are called “vaults” in the dirvish documentation)."
msgstr "Этот механизм резервного копирования легко реализуется с помощью программы <command>dirvish</command>. Она использует хранилище резервных копий («bank» — «банк» — в её терминологии), в котором размещает копии наборов файлов резервных копий с временными метками (в документации dirvish эти наборы называются «vaults» — «подвалы»)."

#, fuzzy
#| msgid "<primary>interface</primary><secondary>administration interface</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/dirvish/master.conf</filename></secondary>"
msgstr "<primary>интерфейс</primary><secondary>администрирования</secondary>"

msgid "The main configuration is in the <filename>/etc/dirvish/master.conf</filename> file. It defines the location of the backup storage space, the list of “vaults” to manage, and default values for expiration of the backups. The rest of the configuration is located in the <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> files and contains the specific configuration for the corresponding set of files."
msgstr "Основные настройки хранятся в файле <filename>/etc/dirvish/master.conf</filename>. Он определяет местоположение пространства для резервных копий, список управляемых «подвалов» и значения сроков хранения резервных копий по умолчанию. Остальные настройки находятся в файлах <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> и содержат конфигурацию соответствующего набора файлов."

msgid "The <filename>/etc/dirvish/master.conf</filename> file"
msgstr "Файл <filename>/etc/dirvish/master.conf</filename>"

msgid ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   MIN HR    DOM MON       DOW  STRFTIME_FMT\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"
msgstr ""
"bank:\n"
"    /backup\n"
"exclude:\n"
"    lost+found/\n"
"    core\n"
"    *~\n"
"Runall:\n"
"    root    22:00\n"
"expire-default: +15 days\n"
"expire-rule:\n"
"#   MIN HR    DOM MON       DOW  STRFTIME_FMT\n"
"    *   *     *   *         1    +3 months\n"
"    *   *     1-7 *         1    +1 year\n"
"    *   *     1-7 1,4,7,10  1"

#, fuzzy
#| msgid "The <literal>bank</literal> setting indicates the directory in which the backups are stored. The <literal>exclude</literal> setting allows you to indicate files (or file types) to exclude from the backup. The <literal>Runall</literal> is a list of file sets to backup with a time-stamp for each set, which allows you to assign the correct date to the copy, in case the backup is not triggered at precisely the assigned time. You have to indicate a time just before the actual execution time (which is, by default, 10:04 pm in Debian, according to <filename>/etc/cron.d/dirvish</filename>). Finally, the <literal>expire-default</literal> and <literal>expire-rule</literal> settings define the expiration policy for backups. The above example keeps forever backups that are generated on the first Sunday of each quarter, deletes after one year those from the first Sunday of each month, and after 3 months those from other Sundays. Other daily backups are kept for 15 days. The order of the rules does matter, Dirvish uses the last matching rule, or the <literal>expire-default</literal> one if no other <literal>expire-rule</literal> matches."
msgid "The <literal>bank</literal> setting indicates the directory in which the backups are stored. The <literal>exclude</literal> setting allows you to indicate files (or file types) to exclude from the backup. The <literal>Runall</literal> is a list of file sets to backup with a time-stamp for each set, which allows you to assign the correct date to the copy, in case the backup is not triggered at precisely the assigned time. You have to indicate a time just before the actual execution time (according to <filename>/etc/cron.d/dirvish</filename>). Finally, the <literal>expire-default</literal> and <literal>expire-rule</literal> settings define the expiration policy for backups. The above example keeps forever backups that are generated on the first Sunday of each quarter, deletes after one year those from the first Sunday of each month, and after 3 months those from other Sundays. Other daily backups are kept for 15 days. The order of the rules does matter, Dirvish uses the last matching rule, or the <literal>expire-default</literal> one if no other <literal>expire-rule</literal> matches."
msgstr "В настройке <literal>bank</literal> указывается каталог, в котором хранятся резервные копии. Настройка <literal>exclude</literal> позволяет указать файлы (или типы файлов), которые не должны включаться в резервную копию. <literal>Runall</literal> — это список наборов файлов для резервного копирования с временной меткой для каждого набора, что позволяет установить корректную дату копии, если резервное копирование ну запускается периодически в определённое время. Нужно указать время, непосредственно предшествующее времени запуска (по умолчанию в Debian это 22:04, в соответствии с файлом <filename>/etc/cron.d/dirvish</filename>). Наконец, настройки <literal>expire-default</literal> и <literal>expire-rule</literal> определяют политику хранения резервных копий. В приведённом выше примере резервные копии, созданные в первое воскресенье каждого квартала, хранятся вечно, созданные в первое воскресенье каждого месяца — удаляются через год, а созданные в другие воскресенья — через 3 месяца. Прочие ежедневные резервные копии хранятся 15 дней. Порядок правил имеет значение: Dirvish применяет последнее подходящее правило или <literal>expire-default</literal>, если ни одно из других правил <literal>expire-rule</literal> не подходит."

msgid "<emphasis>IN PRACTICE</emphasis> Scheduled expiration"
msgstr "<emphasis>НА ПРАКТИКЕ</emphasis> Запланированное истечение сроков хранения"

msgid "The expiration rules are not used by <command>dirvish-expire</command> to do its job. In reality, the expiration rules are applied when creating a new backup copy to define the expiration date associated with that copy. <command>dirvish-expire</command> simply peruses the stored copies and deletes those for which the expiration date has passed."
msgstr "Правила хранения не используются <command>dirvish-expire</command> для выполнения её работы. На самом деле эти правила применяются при создании новой резервной копии, чтобы определить дату истечения срока хранения, ассоциированную с этой копией. <command>dirvish-expire</command> просто просматривает сохранённые копии и удаляет те, для которых эта дата прошла."

msgid "The <filename>/backup/root/dirvish/default.conf</filename> file"
msgstr "Файл <filename>/backup/root/dirvish/default.conf</filename>"

msgid ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"
msgstr ""
"client: rivendell.falcot.com\n"
"tree: /\n"
"xdev: 1\n"
"index: gzip\n"
"image-default: %Y%m%d\n"
"exclude:\n"
"    /var/cache/apt/archives/*.deb\n"
"    /var/cache/man/**\n"
"    /tmp/**\n"
"    /var/tmp/**\n"
"    *.bak"

msgid "The above example specifies the set of files to back up: these are files on the machine <emphasis>rivendell.falcot.com</emphasis> (for local data backup, simply specify the name of the local machine as indicated by <command>hostname</command>), especially those in the root tree (<literal>tree: /</literal>), except those listed in <literal>exclude</literal>. The backup will be limited to the contents of one filesystem (<literal>xdev: 1</literal>). It will not include files from other mount points. An index of saved files will be generated (<literal>index: gzip</literal>), and the image will be named according to the current date (<literal>image-default: %Y%m%d</literal>)."
msgstr "В вышеприведённом примере определяется набор файлов для резервного копирования: это файлы на машине <emphasis>rivendell.falcot.com</emphasis> (для копирования локальных данных нужно просто указать имя локальной машины в том виде, как оно отображается командой <command>hostname</command>), а именно файлы корневого каталога (<literal>tree: /</literal>) за исключением тех, которые перечислены в <literal>exclude</literal>. Резервная копия будет ограничена содержимым одной файловой системы (<literal>xdev: 1</literal>). В неё не войдут файлы из других точек монтирования. Будет создан индекс сохранённых файлов (<literal>index: gzip</literal>), и имя образа будет соответствовать текущей дате (<literal>image-default: %Y%m%d</literal>)."

#, fuzzy
#| msgid "There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired."
msgid "There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired."
msgstr "Существует множество других опций, и все они описаны на странице руководства <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>. Когда конфигурационные файлы подготовлены, необходимо инициализировать каждый набор файлов с помощью команды <command>dirvish --vault <replaceable>vault</replaceable> --init</command>.После этого при ежедневном вызове <command>dirvish-runall</command> будет автоматически создаваться новая резервная копия после удаления устаревшей."

msgid "<emphasis>IN PRACTICE</emphasis> Remote backup over SSH"
msgstr "<emphasis>НА ПРАКТИКЕ</emphasis> Удалённое резервное копирование через SSH"

msgid "When dirvish needs to save data to a remote machine, it will use <command>ssh</command> to connect to it, and will start <command>rsync</command> as a server. This requires the root user to be able to automatically connect to it. The use of an SSH authentication key allows precisely that (see <xref linkend=\"sect.ssh-key-based-auth\" />)."
msgstr "Когда dirvish требуется сохранить данные на удалённой машине, он использует <command>ssh</command> для подключения к ней, и запускает <command>rsync</command> как сервер. Для этого необходимо, чтобы пользователь root мог автоматически подключиться к ней. Использование ключа аутентификации SSH позволяет сделать именно это (см. <xref linkend=\"sect.ssh-key-based-auth\" />)."

msgid "Restoring Machines without Backups"
msgstr "Восстановление машин без резервных копий"

#, fuzzy
#| msgid "Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs prepared with <emphasis>Simple-CDD</emphasis> (see <xref linkend=\"sect.simple-cdd\" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to dconf (see <xref linkend=\"sect.gnome-desktop\" /> for more information about this)."
msgid "Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs/USB sticks prepared with <emphasis role=\"pkg\">simple-cdd</emphasis> (see <xref linkend=\"sect.simple-cdd\" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to <command>dconf</command> (see <xref linkend=\"sect.gnome-desktop\" /> for more information about this)."
msgstr "На настольных компьютерах, резервное копирование которых не выполняется, будет легко переустановить программное обеспечение со специальных DVD-ROM, подготовленных с помощью <emphasis>Simple-CDD</emphasis> (см. <xref linkend=\"sect.simple-cdd\" />). Поскольку при этом происходит установка с нуля, все настройки, которые могли быть сделаны после предыдущей установки, теряются. Это не страшно, поскольку все системы привязаны к центральному каталогу LDAP с учётными записями, и большая часть настольных приложений предварительно настроены благодаря dconf (более подробно об этом см. в <xref linkend=\"sect.gnome-desktop\" />)."

msgid "The Falcot Corp administrators are aware of the limits in their backup policy. Since they can't protect the backup server as well as a tape in a fireproof safe, they have installed it in a separate room so that a disaster such as a fire in the server room won't destroy backups along with everything else. Furthermore, they do an incremental backup on DVD-ROM once per week — only files that have been modified since the last backup are included."
msgstr "Администраторы Falcot Corp осознают ограничения своей политики резервного копирования. Поскольку они не могут защитить сервер резервных копий так же хорошо, как магнитную ленту в несгораемом шкафу, они установили его в отдельной комнате, чтобы стихийное бедствие, такое как пожар в серверной комнате, не уничтожило резервные копии вместе со всем остальным. Кроме того, они делают инкрементальные резервные копии на DVD-ROM раз в неделю — туда включаются только те файлы, которые были изменены со времени предыдущего резервного копирования."

msgid "<emphasis>GOING FURTHER</emphasis> Backing up SQL and LDAP services"
msgstr "<emphasis>УГЛУБЛЯЕМСЯ</emphasis> Резервное копирование сервисов SQL и LDAP"

msgid "<primary><command>xdelta</command></primary>"
msgstr "<primary><command>xdelta</command></primary>"

msgid "<primary><command>diff</command></primary>"
msgstr "<primary><command>diff</command></primary>"

msgid "<primary>dump</primary>"
msgstr "<primary>дамп</primary>"

msgid "Many services (such as SQL or LDAP databases) cannot be backed up by simply copying their files (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times). As such, it is necessary to use an “export” mechanism to create a “data dump” that can be safely backed up. These are often quite large, but they compress well. To reduce the storage space required, you will only store a complete text file per week, and a <command>diff</command> each day, which is created with a command of the type <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. The <command>xdelta</command> program produces incremental differences from binary dumps."
msgstr "Многие сервисы (такие как базы данных SQL или LDAP) не могут быть запущены для резервного копирования простым копированием их файлов (кроме случаев, когда их работа была корректно завершена до начала старта резервного копирования, а это является проблемой, поскольку работа данных сервисов подразумевает быть доступными в любое время). В этих случаях необходимо использовать механизм экспорта (“export”) для создания  дампа данных, который поможет безопасно начать резервное копирование. Зачастую дамп достаточно большой, но он хорошо сжимается. Для уменьшения использования необходимого пространства в резервном хранилище, вам нужно будет только сохранять комплект текстовых файлов каждую неделю, и дополнительно делать команду <command>diff</command> каждый день, которая выглядит примерно так <command>diff <replaceable>файл_из_вчера</replaceable> <replaceable>файл_из_сегодня</replaceable></command>. Программа <command>xdelta</command> выполняет бесконечно малое приращение (инкрементальных) различий  бинарных дампов."

msgid "<emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>, the standard for tape backups"
msgstr "<emphasis>КУЛЬТУРА</emphasis> <emphasis>TAR</emphasis>, стандарт резервных копий на плёнке"

msgid "<primary>backup</primary><secondary>on tape</secondary>"
msgstr "<primary>резервное копирование</primary><secondary>на плёнке</secondary>"

msgid "<primary>tape, backup</primary>"
msgstr "<primary>плёнка, резервное копирование</primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary><acronym>TAR</acronym></primary><seealso>tape archive</seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>tape, backup</primary>"
msgid "<primary>tape archive</primary>"
msgstr "<primary>плёнка, резервное копирование</primary>"

msgid "Historically, the simplest means of making a backup on Unix was to store a <emphasis>TAR</emphasis> archive on a tape. The <command>tar</command> command even got its name from “Tape ARchive”."
msgstr "Исторически самым простым способом создания резервных копий в Unix было сохранение архива <emphasis>TAR</emphasis> на плёнке. Команда <command>tar</command> даже получила своё название от «Tape ARchive» — «плёночный архив»."

msgid "Hot Plugging: <emphasis>hotplug</emphasis>"
msgstr "Горячее подключение: <emphasis>hotplug</emphasis>"

msgid "Introduction"
msgstr "Введение"

msgid "<primary>hotplug</primary>"
msgstr "<primary>hotplug</primary>"

#, fuzzy
#| msgid "<primary>booting</primary><secondary>the system</secondary>"
msgid "<primary>kernel</primary><secondary>hotplug subsystem</secondary>"
msgstr "<primary>загрузка</primary><secondary>системы</secondary>"

#, fuzzy
#| msgid "<primary><command>inetd</command></primary>"
msgid "<primary><command>udevd</command></primary>"
msgstr "<primary><command>inetd</command></primary>"

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>/dev</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>device</primary><seealso><filename>/dev</filename></seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

msgid "<primary>USB</primary>"
msgstr "<primary>USB</primary>"

msgid "<primary>IEEE 1394</primary>"
msgstr "<primary>IEEE 1394</primary>"

msgid "<primary>PCMCIA</primary>"
msgstr "<primary>PCMCIA</primary>"

msgid "<primary>SATA</primary>"
msgstr "<primary>SATA</primary>"

#, fuzzy
#| msgid "The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be hotplugged: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory."
msgid "The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be “hotplugged“: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory."
msgstr "Подсистема ядра <emphasis>hotplug</emphasis> динамически обрабатывает подключение и отключение устройств, загружая соответствующие драйверы и создавая файлы устройств (с помощью <command>udevd</command>). С современным оборудованием и виртуализацией можно подключать «на лету» почти всё: от обычных периферийных устройств USB/PCMCIA/IEEE 1394 до жёстких дисков SATA, и даже процессоров и памяти."

msgid "The kernel has a database that associates each device ID with the required driver. This database is used during boot to load all the drivers for the peripheral devices detected on the different buses, but also when an additional hotplug device is connected. Once the device is ready for use, a message is sent to <command>udevd</command> so it will be able to create the corresponding entry in <filename>/dev/</filename>."
msgstr "У ядра есть база данных для сопоставления идентификатора каждого устройства необходимому драйверу. Эта база данных используется при загрузке для подключения драйверов всех периферийных устройств, обнаруженных на разных шинах, а также при горячем подключении дополнительного устройства. Когда устройство готово к использованию, отправляется сообщение <command>udevd</command>, чтобы он создал соответствующую запись в <filename>/dev/</filename>."

msgid "The Naming Problem"
msgstr "Проблема именования"

msgid "Before the appearance of hotplug connections, it was easy to assign a fixed name to a device. It was based simply on the position of the devices on their respective bus. But this is not possible when such devices can come and go on the bus. The typical case is the use of a digital camera and a USB key, both of which appear to the computer as disk drives. The first one connected may be <filename>/dev/sdb</filename> and the second <filename>/dev/sdc</filename> (with <filename>/dev/sda</filename> representing the computer's own hard drive). The device name is not fixed; it depends on the order in which devices are connected."
msgstr "До появления горячих подключений было очень просто присвоить устройству фиксированное имя. Оно основывалось просто на расположении устройств на их шине. Но это невозможно, когда такие устройства могут появиться и начать использовать шину. Типичным случаем является использование цифрового фотоаппарата или USB-брелока, которые представляются компьютеру как жёсткие диски. Первый подключённый может стать <filename>/dev/sdb</filename>, а второй — <filename>/dev/sdc</filename> (если <filename>/dev/sda</filename> представляет собой локальный жёсткий диск компьютера). Имя устройства не фиксировано; оно зависит от порядка, в котором устройства подключаются."

msgid "Additionally, more and more drivers use dynamic values for devices' major/minor numbers, which makes it impossible to have static entries for the given devices, since these essential characteristics may vary after a reboot."
msgstr "Кроме того, всё больше устройств используют динамические значения своих старшего и младшего номеров, из-за чего становится невозможным использовать для данных устройств статические записи, ведь эти важнейшие характеристики могут меняться после перезагрузки."

#, fuzzy
#| msgid "<primary>inode</primary>"
msgid "<primary>udev</primary>"
msgstr "<primary>inode</primary>"

msgid "<emphasis>udev</emphasis> was created precisely to solve this problem."
msgstr "<emphasis>udev</emphasis> был создан специально для решения этой проблемы."

msgid "How <emphasis>udev</emphasis> Works"
msgstr "Как работает <emphasis>udev</emphasis>"

#, fuzzy
#| msgid "<primary><filename>crontab</filename></primary>"
msgid "<primary><filename>/sys</filename></primary>"
msgstr "<primary><filename>crontab</filename></primary>"

#, fuzzy
#| msgid "<primary>client</primary><secondary>client/server architecture</secondary>"
msgid "<primary><filename>/etc</filename></primary><secondary><filename>/etc/udev/rules.d/</filename></secondary>"
msgstr "<primary>клиент</primary><secondary>клиент-серверная архитектура</secondary>"

#, fuzzy
#| msgid "<primary>modules</primary><secondary>kernel modules</secondary>"
msgid "<primary><filename>/lib</filename></primary><secondary><filename>/lib/udev/rules.d/</filename></secondary>"
msgstr "<primary>модули</primary><secondary>ядра</secondary>"

msgid "When <emphasis>udev</emphasis> is notified by the kernel of the appearance of a new device, it collects various information on the given device by consulting the corresponding entries in <filename>/sys/</filename>, especially those that uniquely identify it (MAC address for a network card, serial number for some USB devices, etc.)."
msgstr "Когда ядро уведомляет <emphasis>udev</emphasis> о появлении нового устройства, последний собирает различную информацию о данном устройстве из соответствующих записей в <filename>/sys/</filename>, особенно тех, которые позволяют уникально идентифицировать его (MAC-адрес сетевой карты, серийный номер некоторых USB-устройств и т. п.)."

#, fuzzy
#| msgid "<primary>user</primary><secondary>owner</secondary>"
msgid "<primary>udev</primary><secondary>rules</secondary>"
msgstr "<primary>пользователь</primary><secondary>владелец</secondary>"

msgid "Armed with all of this information, <emphasis>udev</emphasis> then consults all of the rules contained in <filename>/etc/udev/rules.d/</filename> and <filename>/lib/udev/rules.d/</filename>. In this process it decides how to name the device, what symbolic links to create (to give it alternative names), and what commands to execute. All of these files are consulted, and the rules are all evaluated sequentially (except when a file uses “GOTO” directives). Thus, there may be several rules that correspond to a given event."
msgstr "Вооружившись этой информацией, <emphasis>udev</emphasis> сверяется со всеми правилами, содержащимися в <filename>/etc/udev/rules.d/</filename> и <filename>/lib/udev/rules.d/</filename>. В ходе этого процесса он принимает решение, какое имя присвоить устройству, какие символьные ссылки создать (чтобы дать альтернативные имена) и какие команды запустить. Проверяются все эти файлы, и все правила выполняются последовательно (если в файлах не используются директивы «GOTO»). Так что может быть несколько правил, соответствующих отдельному событию."

msgid "The syntax of rules files is quite simple: each row contains selection criteria and variable assignments. The former are used to select events for which there is a need to react, and the latter defines the action to take. They are all simply separated with commas, and the operator implicitly differentiates between a selection criterion (with comparison operators, such as <literal>==</literal> or <literal>!=</literal>) or an assignment directive (with operators such as <literal>=</literal>, <literal>+=</literal> or <literal>:=</literal>)."
msgstr "Синтаксис файлов правил довольно прост: каждый ряд содержит критерии выбора и присваивание значений переменным. Первые используются для отбора событий, на которые нужно реагировать, а последние определяют действие, которое нужно предпринять. Они все разделяются запятыми, и оператор используется для того, чтобы косвенным образом отличить критерий выбора (с операторами сравнения, такими как <literal>==</literal> или <literal>!=</literal>) от директивы присваивания (с такими операторами как <literal>=</literal>, <literal>+=</literal> или <literal>:=</literal>)."

msgid "Comparison operators are used on the following variables:"
msgstr "Операторы сравнения используются со следующими переменными:"

msgid "<literal>KERNEL</literal>: the name that the kernel assigns to the device;"
msgstr "<literal>KERNEL</literal> — имя, которое ядро присваивает устройству;"

msgid "<literal>ACTION</literal>: the action corresponding to the event (“add” when a device has been added, “remove” when it has been removed);"
msgstr "<literal>ACTION</literal> — действие, соответствующее событию («add» при добавлении устройства, «remove» при его удалении);"

msgid "<literal>DEVPATH</literal>: the path of the device's <filename>/sys/</filename> entry;"
msgstr "<literal>DEVPATH</literal> — путь к записи устройства в <filename>/sys/</filename>;"

msgid "<literal>SUBSYSTEM</literal>: the kernel subsystem which generated the request (there are many, but a few examples are “usb”, “ide”, “net”, “firmware”, etc.);"
msgstr "<literal>SUBSYSTEM</literal> — подсистема ядра, от которой пришёл запрос (их много, например «usb», «ide», «net», «firmware» и т. п.);"

msgid "<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: file contents of the <replaceable>attribute</replaceable> file in the <filename>/sys/<replaceable>$devpath</replaceable>/</filename> directory of the device. This is where you find the MAC address and other bus specific identifiers;"
msgstr "<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: содержимое файла <replaceable>свойства</replaceable> файла в каталоге <filename>/sys/<replaceable>$devpath</replaceable>/</filename> устройства. Здесь вы можете найти MAC адрес и другие специфические идентификаторы шины;"

msgid "<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> and <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> are variations that will try to match the different options on one of the parent devices of the current device;"
msgstr "<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> и <literal>ATTRS{<replaceable>атрибуты</replaceable>}</literal> — это вариации, которые пытаются найти соответствие разным опциям одного из устройств, являющихся родительскими по отношению к текущему;"

msgid "<literal>PROGRAM</literal>: delegates the test to the indicated program (true if it returns 0, false if not). The content of the program's standard output is stored so that it can be reused by the <literal>RESULT</literal> test;"
msgstr "<literal>PROGRAM</literal> — делегирует проверку указанной программе (истина если она возвращает 0, ложь в противном случае). Содержимое стандартного вывода программы сохраняется, так что его можно использовать в проверке <literal>RESULT</literal>;"

msgid "<literal>RESULT</literal>: execute tests on the standard output stored during the last call to <literal>PROGRAM</literal>."
msgstr "<literal>RESULT</literal> — выполняет проверки стандартного вывода, сохранённого при последнем вызове <literal>PROGRAM</literal>."

msgid "The right operands can use pattern expressions to match several values at the same time. For instance, <literal>*</literal> matches any string (even an empty one); <literal>?</literal> matches any character, and <literal>[]</literal> matches the set of characters listed between the square brackets (or the opposite thereof if the first character is an exclamation point, and contiguous ranges of characters are indicated like <literal>a-z</literal>)."
msgstr "В правых операндах можно использовать шаблонные выражения, соответствующие нескольким значениям одновременно. Например, <literal>*</literal> соответствует любой строке (даже пустой); <literal>?</literal> соответствует любому символу, а <literal>[]</literal> соответствует набору символов, перечисленных внутри квадратных скобок (или наоборот, если первым символом является восклицательный знак, а непрерывные диапазоны символов указываются как <literal>a-z</literal>)."

msgid "Regarding the assignment operators, <literal>=</literal> assigns a value (and replaces the current value); in the case of a list, it is emptied and contains only the value assigned. <literal>:=</literal> does the same, but prevents later changes to the same variable. As for <literal>+=</literal>, it adds an item to a list. The following variables can be changed:"
msgstr "Что касается операторов присваивания, <literal>=</literal> присваивает значение (и заменяет текущее значение); в случае списка он очищается и содержит только присвоенное значение. <literal>:=</literal> делает то же самое, но запрещает изменение переменной в дальнейшем. <literal>+=</literal> добавляет запись в список. Можно изменять следующие переменные:"

msgid "<literal>NAME</literal>: the device filename to be created in <filename>/dev/</filename>. Only the first assignment counts; the others are ignored;"
msgstr "<literal>NAME</literal> — имя файла устройства, который надлежит создать в <filename>/dev/</filename>. Учитывается только первое присваивание, остальные игнорируются;"

msgid "<literal>SYMLINK</literal>: the list of symbolic links that will point to the same device;"
msgstr "<literal>SYMLINK</literal> — список символьных ссылок, которые будут указывать на то же устройство;"

msgid "<literal>OWNER</literal>, <literal>GROUP</literal> and <literal>MODE</literal> define the user and group that owns the device, as well as the associated permission;"
msgstr "<literal>OWNER</literal>, <literal>GROUP</literal> и <literal>MODE</literal> определяют пользователя и группу, владеющих устройством, а также назначенные ему разрешения;"

msgid "<literal>RUN</literal>: the list of programs to execute in response to this event."
msgstr "<literal>RUN</literal> — список программ, которые должны быть запущены в ответ на событие."

msgid "The values assigned to these variables may use a number of substitutions:"
msgstr "В значениях, присваиваемых этим переменным, могут использоваться следующие подстановки:"

msgid "<literal>$kernel</literal> or <literal>%k</literal>: equivalent to <literal>KERNEL</literal>;"
msgstr "<literal>$kernel</literal> или <literal>%k</literal> — эквивалент <literal>KERNEL</literal>;"

msgid "<literal>$number</literal> or <literal>%n</literal>: the order number of the device, for example, for <literal>sda3</literal>, it would be “3”;"
msgstr "<literal>$number</literal> или <literal>%n</literal> — порядковый номер устройства, например для <literal>sda3</literal> он был бы равен «3»;"

msgid "<literal>$devpath</literal> or <literal>%p</literal>: equivalent to <literal>DEVPATH</literal>;"
msgstr "<literal>$devpath</literal> или <literal>%p</literal> — эквивалент <literal>DEVPATH</literal>;"

msgid "<literal>$attr{<replaceable>attribute</replaceable>}</literal> or <literal>%s{<replaceable>attribute</replaceable>}</literal>: equivalent to <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;"
msgstr "<literal>$attr{<replaceable>атрибут</replaceable>}</literal> или <literal>%s{<replaceable>атрибут</replaceable>}</literal> — эквивалент <literal>ATTRS{<replaceable>атрибут</replaceable>}</literal>;"

msgid "<literal>$major</literal> or <literal>%M</literal>: the kernel major number of the device;"
msgstr "<literal>$major</literal> или <literal>%M</literal> — старший номер устройства в ядре;"

msgid "<literal>$minor</literal> or <literal>%m</literal>: the kernel minor number of the device;"
msgstr "<literal>$minor</literal> или <literal>%m</literal> — младший номер устройства в ядре;"

msgid "<literal>$result</literal> or <literal>%c</literal>: the string output by the last program invoked by <literal>PROGRAM</literal>;"
msgstr "<literal>$result</literal> или <literal>%c</literal> — строковый вывод последней программы, вызванной <literal>PROGRAM</literal>;"

msgid "and, finally, <literal>%%</literal> and <literal>$$</literal> for the percent and dollar sign, respectively."
msgstr "и наконец, <literal>%%</literal> и <literal>$$</literal> означают, соответственно, знак процента и знак доллара."

#, fuzzy
#| msgid "The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive."
msgid "The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle> <manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive."
msgstr "Вышеуказанный перечень не является полным (в него включены только наиболее важные параметры), но страница руководства <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry>  содержит более исчерпывающую информацию."

msgid "A concrete example"
msgstr "Конкретный пример"

msgid "Let us consider the case of a simple USB key and try to assign it a fixed name. First, you must find the elements that will identify it in a unique manner. For this, plug it in and run <command>udevadm info -a -n /dev/sdc</command> (replacing <replaceable>/dev/sdc</replaceable> with the actual name assigned to the key)."
msgstr "Рассмотрим случай простого USB-брелока и попробуем присвоить ему фиксированное имя. Во-первых, необходимо найти элементы, которые идентифицируют его уникальным образом. Для этого надо подключить его и запустить <command>udevadm info -a -n /dev/sdc</command> (заменив <replaceable>/dev/sdc</replaceable> на действительное имя, присвоенное брелоку)."

#, fuzzy
#| msgid ""
#| "<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
#| "<computeroutput>[...]\n"
#| "  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':\n"
#| "    KERNEL==\"sdc\"\n"
#| "    SUBSYSTEM==\"block\"\n"
#| "    DRIVER==\"\"\n"
#| "    ATTR{range}==\"16\"\n"
#| "    ATTR{ext_range}==\"256\"\n"
#| "    ATTR{removable}==\"1\"\n"
#| "    ATTR{ro}==\"0\"\n"
#| "    ATTR{size}==\"126976\"\n"
#| "    ATTR{alignment_offset}==\"0\"\n"
#| "    ATTR{capability}==\"53\"\n"
#| "    ATTR{stat}==\"      51      100     1208      256        0        0        0        0        0      192      25        6\"\n"
#| "    ATTR{inflight}==\"       0        0\"\n"
#| "[...]\n"
#| "  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':\n"
#| "    KERNELS==\"9:0:0:0\"\n"
#| "    SUBSYSTEMS==\"scsi\"\n"
#| "    DRIVERS==\"sd\"\n"
#| "    ATTRS{device_blocked}==\"0\"\n"
#| "    ATTRS{type}==\"0\"\n"
#| "    ATTRS{scsi_level}==\"3\"\n"
#| "    ATTRS{vendor}==\"I0MEGA  \"\n"
#| "    ATTRS{model}==\"UMni64MB*IOM2C4 \"\n"
#| "    ATTRS{rev}==\"    \"\n"
#| "    ATTRS{state}==\"running\"\n"
#| "[...]\n"
#| "    ATTRS{max_sectors}==\"240\"\n"
#| "[...]\n"
#| "  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':\n"
#| "    KERNELS==\"9:0:0:0\"\n"
#| "    SUBSYSTEMS==\"usb\"\n"
#| "    DRIVERS==\"usb\"\n"
#| "    ATTRS{configuration}==\"iCfg\"\n"
#| "    ATTRS{bNumInterfaces}==\" 1\"\n"
#| "    ATTRS{bConfigurationValue}==\"1\"\n"
#| "    ATTRS{bmAttributes}==\"80\"\n"
#| "    ATTRS{bMaxPower}==\"100mA\"\n"
#| "    ATTRS{urbnum}==\"398\"\n"
#| "    ATTRS{idVendor}==\"4146\"\n"
#| "    ATTRS{idProduct}==\"4146\"\n"
#| "    ATTRS{bcdDevice}==\"0100\"\n"
#| "[...]\n"
#| "    ATTRS{manufacturer}==\"USB Disk\"\n"
#| "    ATTRS{product}==\"USB Mass Storage Device\"\n"
#| "    ATTRS{serial}==\"M004021000001\"\n"
#| "[...]\n"
#| "</computeroutput>"
msgid ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{hidden}==\"0\"\n"
"    ATTR{events}==\"media_change\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{discard_alignment}==\"0\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{events_async}==\"\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"51\"\n"
"    ATTR{events_poll_msecs}==\"-1\"\n"
"    ATTR{stat}==\"130  0  6328  435  0  0  0  0  0  252  252  0  0  0  0\"\n"
"    ATTR{size}==\"15100224\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{inflight}==\"0  0\"\n"
"[...]\n"
"\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0':\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.0/usb2/2-1':\n"
"    KERNELS==\"2-1\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{bDeviceProtocol}==\"00\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{busnum}==\"2\"\n"
"    ATTRS{quirks}==\"0x0\"\n"
"    ATTRS{authorized}==\"1\"\n"
"    ATTRS{ltm_capable}==\"no\"\n"
"    ATTRS{speed}==\"480\"\n"
"    ATTRS{product}==\"TF10\"\n"
"    ATTRS{manufacturer}==\"TDK LoR\"\n"
"[...]\n"
"    ATTRS{serial}==\"07032998B60AB777\"\n"
"[...]\n"
"</computeroutput>"
msgstr ""
"<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>\n"
"<computeroutput>[...]\n"
"  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':\n"
"    KERNEL==\"sdc\"\n"
"    SUBSYSTEM==\"block\"\n"
"    DRIVER==\"\"\n"
"    ATTR{range}==\"16\"\n"
"    ATTR{ext_range}==\"256\"\n"
"    ATTR{removable}==\"1\"\n"
"    ATTR{ro}==\"0\"\n"
"    ATTR{size}==\"126976\"\n"
"    ATTR{alignment_offset}==\"0\"\n"
"    ATTR{capability}==\"53\"\n"
"    ATTR{stat}==\"      51      100     1208      256        0        0        0        0        0      192      25        6\"\n"
"    ATTR{inflight}==\"       0        0\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':\n"
"    KERNELS==\"9:0:0:0\"\n"
"    SUBSYSTEMS==\"scsi\"\n"
"    DRIVERS==\"sd\"\n"
"    ATTRS{device_blocked}==\"0\"\n"
"    ATTRS{type}==\"0\"\n"
"    ATTRS{scsi_level}==\"3\"\n"
"    ATTRS{vendor}==\"I0MEGA  \"\n"
"    ATTRS{model}==\"UMni64MB*IOM2C4 \"\n"
"    ATTRS{rev}==\"    \"\n"
"    ATTRS{state}==\"running\"\n"
"[...]\n"
"    ATTRS{max_sectors}==\"240\"\n"
"[...]\n"
"  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':\n"
"    KERNELS==\"9:0:0:0\"\n"
"    SUBSYSTEMS==\"usb\"\n"
"    DRIVERS==\"usb\"\n"
"    ATTRS{configuration}==\"iCfg\"\n"
"    ATTRS{bNumInterfaces}==\" 1\"\n"
"    ATTRS{bConfigurationValue}==\"1\"\n"
"    ATTRS{bmAttributes}==\"80\"\n"
"    ATTRS{bMaxPower}==\"100mA\"\n"
"    ATTRS{urbnum}==\"398\"\n"
"    ATTRS{idVendor}==\"4146\"\n"
"    ATTRS{idProduct}==\"4146\"\n"
"    ATTRS{bcdDevice}==\"0100\"\n"
"[...]\n"
"    ATTRS{manufacturer}==\"USB Disk\"\n"
"    ATTRS{product}==\"USB Mass Storage Device\"\n"
"    ATTRS{serial}==\"M004021000001\"\n"
"[...]\n"
"</computeroutput>"

msgid "To create a new rule, you can use tests on the device's variables, as well as those of one of the parent devices. The above case allows us to create two rules like these:"
msgstr "Чтобы создать новое правило, можно использовать проверки переменных как устройства, так и его родительских устройств. В приведённом примере можно создать два правила вроде этих:"

#, fuzzy
#| msgid ""
#| "KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/disk\"\n"
#| "KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/part%n\""
msgid ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"07032998B60AB777\", SYMLINK+=\"usb_key/part%n\""
msgstr ""
"KERNEL==\"sd?\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/disk\"\n"
"KERNEL==\"sd?[0-9]\", SUBSYSTEM==\"block\", ATTRS{serial}==\"M004021000001\", SYMLINK+=\"usb_key/part%n\""

msgid "Once these rules are set in a file, named for example <filename>/etc/udev/rules.d/010_local.rules</filename>, you can simply remove and reconnect the USB key. You can then see that <filename>/dev/usb_key/disk</filename> represents the disk associated with the USB key, and <filename>/dev/usb_key/part1</filename> is its first partition."
msgstr "После того, как эти правила прописаны в файле с именем, например, <filename>/etc/udev/rules.d/010_local.rules</filename>, можно просто отсоединить и заново подключить USB-брелок. После этого можно будет убедиться, что <filename>/dev/usb_key/disk</filename> представляет диск, ассоциированный с USB-брелоком, а <filename>/dev/usb_key/part1</filename> — его первый раздел."

msgid "<emphasis>GOING FURTHER</emphasis> Debugging <emphasis>udev</emphasis>'s configuration"
msgstr "<emphasis>УГЛУБЛЯЕМСЯ</emphasis> Отладка конфигурации <emphasis>udev</emphasis>"

#, fuzzy
#| msgid "<primary>login</primary><secondary>remote login</secondary>"
msgid "<primary><command>udevd</command></primary><secondary><filename>/var/log/daemon.log</filename></secondary>"
msgstr "<primary>вход</primary><secondary>удалённый вход</secondary>"

#, fuzzy
#| msgid "<primary><command>kdm</command></primary>"
msgid "<primary><command>udevadm</command></primary>"
msgstr "<primary><command>kdm</command></primary>"

msgid "Like many daemons, <command>udevd</command> stores logs in <filename>/var/log/daemon.log</filename>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <command>udevadm control --log-priority=info</command> command increases the verbosity level and solves this problem. <command>udevadm control --log-priority=err</command> returns to the default verbosity level."
msgstr "Подобно многим демонам, <command>udevd</command> сохраняет журналы событий в <filename>/var/log/daemon.log</filename>. Но записи по умолчанию не очень подробные, и их обычно недостаточно для понимания происходящего. Команда <command>udevadm control --log-priority=info</command> увеличит объём выдаваемой отладочной информации и решит эту проблему. А команда <command>udevadm control --log-priority=err</command> возвратит в состояние \"по умолчанию\" объём выводимой отладочной информации."

msgid "Power Management: Advanced Configuration and Power Interface (ACPI)"
msgstr "Управление питанием: ACPI"

#, fuzzy
#| msgid "<primary>SSH tunnel</primary><seealso>VPN</seealso>"
msgid "<primary>power management</primary><seealso>ACPI</seealso>"
msgstr "<primary>SSH-туннель</primary><seealso>VPN</seealso>"

#, fuzzy
#| msgid "<primary>management, power management</primary>"
msgid "<primary>management, power management</primary><seealso>ACPI</seealso>"
msgstr "<primary>питание, управление питанием</primary>"

msgid "<primary>ACPI</primary>"
msgstr "<primary>ACPI</primary>"

#, fuzzy
#| msgid "<primary>Advanced Configuration and Power Interface</primary>"
msgid "<primary>Advanced Configuration and Power Interface</primary><seealso>ACPI</seealso>"
msgstr "<primary>Advanced Configuration and Power Interface</primary>"

msgid "<primary><command>acpid</command></primary>"
msgstr "<primary><command>acpid</command></primary>"

msgid "The topic of power management is often problematic. Indeed, properly suspending the computer requires that all the computer's device drivers know how to put them to standby, and that they properly reconfigure the devices upon waking. Unfortunately, there are still a few devices unable to sleep well under Linux, because their manufacturers have not provided the required specifications."
msgstr "Тема управления питанием часто связана с проблемами. Действительно, для корректного перевода компьютера в режим ожидания необходимо, чтобы драйверы всех устройств знали, как переключить их в режим пониженного энергопотребления, и чтобы они корректно перенастроили устройства при возврате в обычный режим. К сожалению, иногда ещё встречаются устройства, неспособные правильно «уснуть» в Linux, поскольку их производители не предоставили необходимых спецификаций."

#, fuzzy
#| msgid "Linux supports ACPI (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role=\"pkg\">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response."
msgid "Linux supports <acronym>ACPI</acronym> (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role=\"pkg\">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response."
msgstr "Linux поддерживает ACPI (\"Advanced Configuration and Power Interface\" — усовершенствованный интерфейс управления конфигурацией и питанием) — самый последний стандарт управления питанием. Пакет <emphasis role=\"pkg\">acpid</emphasis> предоставляет демона, который следит за событиями, связанными с управлением питанием (переключение между питанием от сети и от батареи на ноутбуках и т. п.) и может запускать разные команды в ответ."

msgid "<emphasis>BEWARE</emphasis> Graphics card and standby"
msgstr "<emphasis>ОСТОРОЖНО</emphasis> Видеокарта и режим ожидания"

msgid "The graphics card driver is often the culprit when standby doesn't work properly. In that case, it is a good idea to test the latest version of the X.org graphics server."
msgstr "Драйвер видеокарты часто является виновником некорректной работы режима ошидания. В таком случае хорошей идеей будет проверить последнюю версию графического сервера X.org."

msgid "After this overview of basic services common to many Unix systems, we will focus on the environment of the administered machines: the network. Many services are required for the network to work properly. They will be discussed in the next chapter."
msgstr "После этого обзора базовых сервисов, общих для многих Unix-систем, мы сосредоточимся на окружении администрируемых машин — на сети. Для её корректной работы необходимо множество сервисов. Они будут обсуждаться в следующей главе."

#~ msgid "<emphasis role=\"pkg\">file-rc</emphasis> is a boot system with a very simple process. It keeps the principle of runlevels, but replaces the directories and symbolic links with a configuration file, which indicates to <command>init</command> the processes that must be started and their launch order."
#~ msgstr "<emphasis role=\"pkg\">file-rc</emphasis> — это очень просто устроенная система загрузки. Она сохраняет принцип уровней запуска, но заменяет каталоги и символьные ссылки конфигурационным файлом, указывающим <command>init</command>, какие процессы и в каком порядке должны быть запущены."

#~ msgid "As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed."
#~ msgstr "Как видно из примера, кода очень мало, только объявления. Также systemd описывает ход процесса, отслеживает их выполнение и даже перезапускает, если необходимо."

#~ msgid "<primary>Secure Shell</primary>"
#~ msgstr "<primary>Secure Shell</primary>"

#~ msgid "<primary>OpenSSH</primary>"
#~ msgstr "<primary>OpenSSH</primary>"

#~ msgid "VNC also works for mobile users, or company executives, who occasionally need to login from their home to access a remote desktop similar to the one they use at work. The configuration of such a service is more complicated: you first install the <emphasis role=\"pkg\">vnc4server</emphasis> package, change the configuration of the display manager to accept <literal>XDMCP Query</literal> requests (for <command>gdm3</command>, this can be done by adding <literal>Enable=true</literal> in the “xdmcp” section of <filename>/etc/gdm3/daemon.conf</filename>), and finally, start the VNC server with <command>inetd</command> so that a session is automatically started when a user tries to login. For example, you may add this line to <filename>/etc/inetd.conf</filename>:"
#~ msgstr "VNC также подходит для мобильных пользователей или для руководителей компании, которым время от времени требуется получать доступ к удалённому рабочему столу из своего дома, как если бы они были на работе. Настройка такого сервиса сложнее: сперва нужно установить пакет <emphasis role=\"pkg\">vnc4server</emphasis>, изменить настройки менеджера дисплея, чтобы он принимал запросы <literal>XDMCP Query</literal> (для <command>gdm3</command> это делается путём добавления строки <literal>Enable=true</literal> в раздел «xdmcp» файла <filename>/etc/gdm3/daemon.conf</filename>) и, наконец, запустить сервер VNC с помощью <command>inetd</command>, чтобы сессия автоматически запускалась при попытке пользователя войти в систему. Например, можно добавить следующую строчку в <filename>/etc/inetd.conf</filename>:"

#~ msgid "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"
#~ msgstr "5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none"

#~ msgid "Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <command>gdm3</command> login screen (or equivalent <command>kdm</command>, <command>xdm</command>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <command>vncviewer <replaceable>server</replaceable>:50</command>, because the port used is 5950."
#~ msgstr "Перенаправление входящих соединений к менеджеру рабочего стола решает проблему идентификации, т. к. только пользователи с локальными учётными записями могут быть зарегистрированы через <command>gdm3</command> (или эквиваленты <command>kdm</command>, <command>xdm</command>, и прочие). Так как возможны одновременные многочисленные регистрации (сервер должен быть достаточно мощным для этого), удалённые пользователи (или менее мощные системы, сконфигурированные как тонкие клиенты) могут использовать машину как полноценную систему. Пользователи должны регистрироваться с <command>vncviewer <replaceable>server</replaceable>:50</command>, т. к. используется порт 5950."

#~ msgid "<primary>rights</primary>"
#~ msgstr "<primary>права</primary>"

#~ msgid "<primary>umask</primary>"
#~ msgstr "<primary>umask</primary>"

#~ msgid "<primary><command>debconf</command></primary>"
#~ msgstr "<primary><command>debconf</command></primary>"

#~ msgid "<primary>pipe, named pipe</primary>"
#~ msgstr "<primary>канал, именованный</primary>"

#~ msgid "The following example illustrates the most common cases:"
#~ msgstr "Следующий пример иллюстрирует наиболее распространённые случаи:"

#~ msgid ""
#~ "talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
#~ "finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
#~ "ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"
#~ msgstr ""
#~ "talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd\n"
#~ "finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd\n"
#~ "ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i"

#~ msgid "<primary><command>warnquota</command></primary>"
#~ msgstr "<primary><command>warnquota</command></primary>"

#~ msgid "<primary><emphasis>hotplug</emphasis></primary>"
#~ msgstr "<primary><emphasis>hotplug</emphasis></primary>"

#~ msgid "<primary>power management</primary>"
#~ msgstr "<primary>управление питанием</primary>"

#~ msgid "<emphasis>IN PRACTICE</emphasis> Network card management"
#~ msgstr "<emphasis>НА ПРАКТИКЕ</emphasis> Управление сетевыми картами"

#~ msgid "Many computers have multiple network cards (sometimes two wired interfaces and a wifi interface), and with <emphasis>hotplug</emphasis> support on most bus types, the Linux kernel does not guarantee fixed naming of network interfaces. But users who want to configure their network in <filename>/etc/network/interfaces</filename> need a fixed name!"
#~ msgstr "Многие компьютеры имеют несколько сетевых карт (иногда два проводных интерфейса и интерфейс радиосвязи WiFi). Используемый сейчас механизм <emphasis>hotplug</emphasis> поддерживает большинство типов шин, однако ядро Linux не гарантирует фиксированных имён сетевых интерфейсов. Но пользователи, которые хотят настроить свои сети в файле <filename>/etc/network/interfaces</filename> нуждаются в определённых (фиксированных) именах!"

#~ msgid "It would be difficult to ask every user to create their own <emphasis>udev</emphasis> rules to address this problem. This is why <emphasis>udev</emphasis> was configured in a rather peculiar manner; on first boot (and, more generally, each time that a new network card appears) it uses the name of the network interface and its MAC address to create new rules that will reassign the same name on subsequent boots. These rules are stored in <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>."
#~ msgstr "Было бы сложно просить каждого пользователя создавать свои собственные правила <emphasis>udev</emphasis> для решения этой проблемы. Поэтому <emphasis>udev</emphasis> был настроен более своеобразным образом; при первой загрузке (и, в более общем случае, при появлении новой сетевой карты) он использует имя сетевой карты и её MAC-адрес, чтобы создать новые правила, которые будут вновь присваивать то же имя при последующих загрузках. Эти правила хранятся в <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>."

#~ msgid "This mechanism has some side effects that you should know about. Let's consider the case of a computer that has only one PCI network card. The network interface is named <literal>eth0</literal>, logically. Now say the card breaks down, and the administrator replaces it; the new card will have a new MAC address. Since the old card was assigned the name, <literal>eth0</literal>, the new one will be assigned <literal>eth1</literal>, even though the <literal>eth0</literal> card is gone for good (and the network will not be functional because <filename>/etc/network/interfaces</filename> likely configures an <literal>eth0</literal> interface). In this case, it is enough to simply delete the <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> file before rebooting the computer. The new card will then be given the expected <literal>eth0</literal> name."
#~ msgstr "Этот механизм имеет некоторые побочные эффекты, которые вы должны знать. Давайте рассмотрим случай,  когда компьютер имеет только одну сетевую карту PCI. Сетевой интерфейс называется <literal>eth0</literal>, что логично. Однако, давайте предположим, что сетевая карта eth0 сломалась, и администратор заменил её; новая карта будет иметь новый MAC адрес. Поскольку старой карте было ранее присвоено имя <literal>eth0</literal>, то новой карте будет присвоено имя <literal>eth1</literal>, даже несмотря на то, что старая карта <literal>eth0</literal> физически удалена из системы навсегда (и как следствие этого - сеть перестанет работать потому, что в файле <filename>/etc/network/interfaces</filename> вероятно ранее был вручную настроен интерфейс <literal>eth0</literal>). В этом случае, достаточно просто удалить файл <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> до перезагрузки компьютера. И после загрузки ядро и hotplug назначат новой карте ожидаемое имя <literal>eth0</literal>."
